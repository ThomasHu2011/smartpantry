{% extends "base.html" %}

{% block title %}Home - SmartPantry{% endblock %}

{% block extra_head %}
<style>
    /* Removed vague animations - cards appear instantly for better performance */
    .pantry-item-card {
        opacity: 1;
        position: relative;
        z-index: 10;
    }
    
    .pantry-item-wrapper {
        position: relative;
        z-index: 10;
    }
    
    #pantryItemsContainer {
        position: relative;
        z-index: 10;
    }
    
    /* Ensure pantry items appear above card header */
    .card-body {
        position: relative;
        z-index: 5;
    }
    
    .card-header {
        position: relative;
        z-index: 1;
    }
    
    /* Fix modal backdrop - proper isolation to prevent page blur */
    .modal-backdrop {
        background-color: rgba(0, 0, 0, 0.4) !important; /* Darker for better contrast, no blur */
        /* REMOVED backdrop-filter blur to prevent page blur bug */
        z-index: 1040 !important;
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        pointer-events: auto !important; /* Allow backdrop clicks to close modal */
    }
    
    .modal-backdrop.show {
        opacity: 1 !important;
        display: block !important;
    }
    
    /* Prevent body scroll when modal is open */
    body.modal-open {
        overflow: hidden !important;
        padding-right: 0 !important;
    }
    
    .modal {
        z-index: 1055 !important;
        pointer-events: none !important; /* Modal container doesn't capture clicks */
    }
    
    .modal.show {
        pointer-events: auto !important; /* When shown, allow clicks */
        display: block !important;
    }
    
    /* Ensure modal content is clickable and properly layered */
    .modal-content {
        pointer-events: auto !important;
        z-index: 1056 !important;
        position: relative;
        background: white !important; /* Ensure modal content has solid background */
        border-radius: 24px !important;
    }
    
    /* Ensure all modal elements are clickable */
    .modal.show .modal-content,
    .modal.show .modal-content * {
        pointer-events: auto !important;
    }
    
    /* Ensure modal dialog is above backdrop and responsive */
    .modal-dialog {
        z-index: 1055 !important;
        position: relative;
        pointer-events: auto !important;
        margin: 1rem auto !important;
        max-width: 90% !important;
    }
    
    .modal-dialog-centered {
        min-height: calc(100% - 2rem) !important;
        display: flex !important;
        align-items: center !important;
    }
    
    /* Photo upload modal - smaller width with responsive breakpoints */
    #photoModal .modal-dialog {
        max-width: 600px !important;
        width: 90% !important;
    }
    
    /* Tablet breakpoint (768x1024) */
    @media (max-width: 768px) {
        #photoModal .modal-dialog {
            max-width: 95% !important;
            width: 95% !important;
            margin: 0.5rem auto !important;
        }
        
        #photoModal .modal-body {
            padding: 1.5rem !important;
        }
        
        #photoModal .btn {
            padding: 0.5rem 1rem !important;
            font-size: 0.9rem !important;
        }
        
        #photoModal .row.g-2 {
            gap: 0.5rem !important;
        }
    }
    
    /* Mobile breakpoint (360x640) */
    @media (max-width: 576px) {
        #photoModal .modal-dialog {
            max-width: 98% !important;
            width: 98% !important;
            margin: 0.25rem auto !important;
        }
        
        #photoModal .modal-header {
            padding: 1rem !important;
        }
        
        #photoModal .modal-title {
            font-size: 1rem !important;
        }
        
        #photoModal .modal-body {
            padding: 1rem !important;
        }
        
        #photoModal .btn {
            padding: 0.5rem 0.75rem !important;
            font-size: 0.875rem !important;
        }
        
        /* Mobile keyboard handling - ensure inputs are visible when keyboard appears */
        @supports (-webkit-touch-callout: none) {
            /* iOS specific */
            .modal.show {
                position: fixed;
                height: 100vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .modal-dialog {
                margin: 1rem auto !important;
                min-height: auto !important;
            }
            
            /* Scroll input into view when focused */
            input:focus, textarea:focus, select:focus {
                scroll-margin-top: 100px;
            }
        }
        
        /* Android and general mobile */
        @media (max-height: 600px) {
            /* When keyboard is likely open */
            .modal-dialog-centered {
                align-items: flex-start !important;
                padding-top: 1rem;
            }
        }
        
        #photoModal .photo-upload-zone {
            padding: 1.5rem 1rem !important;
            min-height: 200px !important;
        }
        
        #photoModal .photo-upload-zone h5 {
            font-size: 1rem !important;
        }
        
        #photoModal .photo-upload-zone .display-1 {
            font-size: 3rem !important;
        }
        
        #photoModal .row.g-2 > div {
            padding: 0.25rem !important;
        }
    }
    
    /* Extra small mobile (360px and below) */
    @media (max-width: 360px) {
        #photoModal .modal-dialog {
            max-width: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            border-radius: 0 !important;
        }
        
        #photoModal .modal-content {
            border-radius: 0 !important;
        }
    }
    
    /* Responsive modal content */
    .modal-content {
        max-height: 90vh !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
    }
    
    /* Prevent backdrop from staying after modal closes */
    body:not(.modal-open) .modal-backdrop {
        display: none !important;
        opacity: 0 !important;
        visibility: hidden !important;
        pointer-events: none !important;
    }
    
    /* Ensure modal is always above header/navbar */
    .modal {
        z-index: 9999 !important;
    }
    
    .modal-backdrop {
        z-index: 9998 !important;
    }
    
    .modal-dialog {
        z-index: 9999 !important;
    }
    
    .modal-content {
        z-index: 10000 !important;
    }
    
    /* Ensure navbar/header stays below modal */
    .navbar {
        z-index: 1000 !important;
    }
    
    /* Prevent any page content from being blurred when modal is open */
    body.modal-open > *:not(.modal):not(.modal-backdrop) {
        filter: none !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
    }
    
    /* Ensure hero section and cards don't blur when modal opens */
    body.modal-open .hero-section,
    body.modal-open .card,
    body.modal-open .card-header .badge {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        filter: none !important;
    }
    
    /* Enhanced UI Styles */
    :root {
        --primary-purple: #8B5CF6;
        --primary-blue: #3B82F6;
        --success-green: #10B981;
        --danger-red: #EF4444;
        --warning-orange: #F59E0B;
        --gray-50: #F9FAFB;
        --gray-100: #F3F4F6;
        --gray-200: #E5E7EB;
        --gray-300: #D1D5DB;
        --gray-600: #4B5563;
        --gray-800: #1F2937;
        --gray-900: #111827;
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    /* Improved card styling */
    .card {
        border: none;
        box-shadow: var(--shadow-md);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
    }
    
    .card:hover {
        box-shadow: var(--shadow-lg);
        transform: translateY(-2px);
    }
    
    .card-header {
        background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        border-bottom: none;
        padding: 1.25rem 1.5rem;
        font-weight: 600;
    }
    
    .card-header.bg-gradient-success {
        background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
    }
    
    .card-header.bg-gradient-info {
        background: linear-gradient(135deg, var(--primary-blue) 0%, #2563EB 100%);
    }
    
    /* Enhanced pantry item cards */
    .pantry-item-card {
        overflow: hidden;
        will-change: transform;
        border: 1px solid var(--gray-200);
        background: white;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
    }
    
    .pantry-item-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .pantry-item-card:hover {
        border-color: var(--primary-purple);
        box-shadow: 0 16px 32px rgba(139, 92, 246, 0.2);
    }
    
    .pantry-item-card:hover::before {
        opacity: 1;
    }
    
    /* Enhanced item icon container */
    .pantry-item-card .bi-box-seam {
        filter: drop-shadow(0 2px 4px rgba(139, 92, 246, 0.2));
    }
    
    /* Improved badge spacing and layout */
    .pantry-item-card .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.375rem;
        white-space: nowrap;
    }
    
    /* Fix text overflow in pantry item names */
    .pantry-item-card .fw-bold {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 100%;
        display: block;
        word-break: break-word; /* Fallback for very long words */
    }
    
    /* Ensure card layout doesn't break with long names */
    .pantry-item-card {
        min-height: 120px;
        display: flex;
        flex-direction: column;
    }
    
    .pantry-item-card .card-body {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    /* Prevent delete button from overlapping text */
    .pantry-item-card .position-absolute {
        z-index: 10;
    }
    
    .pantry-item-card .fw-bold {
        padding-right: 40px; /* Space for delete button */
    }
    
    /* Prevent card hover overflow */
    .pantry-item-wrapper {
        overflow: visible;
    }
    
    /* Enhanced badge styling */
    .badge {
        font-weight: 500;
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .editable-quantity,
    .editable-expiration {
        cursor: pointer;
        user-select: none;
    }
    
    .editable-expiration.editing {
        pointer-events: none;
        opacity: 0.7;
        cursor: wait;
    }
    
    .editable-quantity.editing {
        pointer-events: none;
        opacity: 0.7;
        cursor: wait;
    }
    
    .editable-quantity:hover,
    .editable-expiration:hover {
        transform: scale(1.05);
        box-shadow: 0 2px 8px rgba(139, 92, 246, 0.2);
    }
    
    /* Enhanced button styling with reliable hover states */
    .btn {
        font-weight: 600;
        border-radius: 0.75rem;
        padding: 0.625rem 1.25rem;
        transition: all 0.2s ease;
        border: none;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        -webkit-tap-highlight-color: transparent;
    }
    
    .btn:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }
    
    .btn:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: var(--shadow-sm);
    }
    
    .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
    }
    
    /* Loading state for buttons */
    .btn.loading {
        pointer-events: none;
        opacity: 0.7;
    }
    
    .btn .spinner-border-sm {
        width: 1rem;
        height: 1rem;
        border-width: 0.15em;
    }
    
    .btn-lg {
        padding: 0.875rem 1.75rem;
        font-size: 1.125rem;
        border-radius: 1rem;
    }
    
    .btn-primary {
        background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        color: white;
        border: none;
    }
    
    .btn-primary:hover {
        background: linear-gradient(135deg, #7C3AED 0%, #2563EB 100%);
        color: white;
        transform: translateY(-1px);
    }
    
    .btn-success {
        background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
        color: white;
        border: none;
    }
    
    .btn-success:hover {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        color: white;
        transform: translateY(-1px);
    }
    
    .btn-outline-success {
        border: 2px solid var(--success-green);
        color: var(--success-green);
        background: transparent;
    }
    
    .btn-outline-success:hover {
        background: var(--success-green);
        color: white;
        border-color: var(--success-green);
    }
    
    .btn-outline-secondary {
        border: 2px solid var(--gray-300);
        color: var(--gray-600);
        background: transparent;
    }
    
    .btn-outline-secondary:hover {
        background: var(--gray-200);
        color: var(--gray-800);
        border-color: var(--gray-300);
    }
    
    .btn-outline-danger {
        border: 2px solid var(--danger-red);
        color: var(--danger-red);
        background: transparent;
    }
    
    .btn-outline-danger:hover {
        background: var(--danger-red);
        color: white;
        transform: scale(1.05);
    }
    
    /* Enhanced form inputs */
    .form-control,
    .form-select {
        border: 2px solid var(--gray-200);
        border-radius: 0.75rem;
        padding: 0.75rem 1rem;
        transition: all 0.2s ease;
    }
    
    .form-control:focus,
    .form-select:focus {
        border-color: var(--primary-purple);
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        outline: none;
    }
    
    /* Enhanced expiration badges */
    .expiration-badge {
        font-weight: 500;
        padding: 0.375rem 0.75rem;
        border-radius: 0.5rem;
        display: inline-flex;
        align-items: center;
        gap: 0.375rem;
    }
    
    .expiration-expired {
        background: rgba(239, 68, 68, 0.15);
        color: #DC2626;
    }
    
    .expiration-soon {
        background: rgba(245, 158, 11, 0.15);
        color: #D97706;
    }
    
    .expiration-fresh {
        background: rgba(16, 185, 129, 0.15);
        color: #059669;
    }
    
    /* Pantry item card background highlighting based on expiration */
    .pantry-item-card.expiration-expired-card {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.08) 0%, rgba(220, 38, 38, 0.05) 100%) !important;
        border-color: rgba(239, 68, 68, 0.3) !important;
    }
    
    .pantry-item-card.expiration-soon-card {
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.12) 0%, rgba(217, 119, 6, 0.08) 100%) !important;
        border-color: rgba(245, 158, 11, 0.4) !important;
    }
    
    .pantry-item-card.expiration-fresh-card {
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.08) 0%, rgba(5, 150, 105, 0.05) 100%) !important;
        border-color: rgba(16, 185, 129, 0.3) !important;
    }
    
    .expiration-none {
        background: rgba(156, 163, 175, 0.15);
        color: #6B7280;
    }
    
    /* Enhanced delete button */
    .delete-item-btn {
        transition: all 0.2s ease;
    }
    
    .delete-item-btn:hover {
        transform: scale(1.15) rotate(90deg);
    }
    
    /* Improved empty state */
    .empty-state {
        padding: 3rem 1rem;
    }
    
    .empty-state i {
        opacity: 0.5;
    }
    
    /* Enhanced modal styling */
    .modal-content {
        border: none;
        border-radius: 1.5rem;
        box-shadow: var(--shadow-xl);
        overflow: hidden;
        background: white;
    }
    
    .modal-header {
        background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        color: white;
        border-bottom: none;
        padding: 1.5rem;
    }
    
    .modal-header .modal-title {
        color: white;
        font-weight: 700;
        font-size: 1.5rem;
        letter-spacing: -0.02em;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    /* Visual hierarchy: Make modal title more prominent */
    #photoModal .modal-header .modal-title {
        font-size: 1.75rem;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .modal-header .btn-close {
        filter: invert(1);
        opacity: 0.9;
    }
    
    .modal-header .btn-close:hover {
        opacity: 1;
    }
    
    .modal-body {
        padding: 2rem;
        background: var(--gray-50);
        overflow-y: auto;
        overflow-x: hidden;
        max-height: calc(90vh - 120px);
    }
    
    /* Consistent spacing for modal buttons */
    #photoModal .modal-body .d-flex.gap-2 {
        gap: 0.75rem !important;
    }
    
    /* Better alignment for button groups */
    #photoModal .modal-body .btn-group,
    #photoModal .modal-body .d-flex {
        align-items: center;
        justify-content: center;
    }
    
    .modal-footer {
        border-top: 1px solid var(--gray-200);
        padding: 1.5rem;
        background: white;
    }
    
    /* Photo upload zone styling - responsive */
    .photo-upload-zone {
        border: 2px dashed #cbd5e0;
        border-radius: 16px;
        padding: 2rem 1.5rem;
        text-align: center;
        background: #f8f9fa;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        cursor: pointer;
        min-height: 200px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
    }
    
    /* Responsive styles for modal and photo upload */
    @media (max-width: 768px) {
        .photo-upload-zone {
            padding: 1.5rem 1rem;
            min-height: 150px;
        }
        
        .modal-dialog {
            margin: 0.5rem !important;
            max-width: calc(100% - 1rem) !important;
        }
        
        .modal-content {
            max-height: 95vh !important;
            border-radius: 16px !important;
        }
        
        .camera-preview {
            min-height: 250px;
        }
        
        .image-preview {
            max-height: 300px;
        }
    }
    
    @media (max-width: 576px) {
        .modal-dialog {
            margin: 0.25rem !important;
            max-width: calc(100% - 0.5rem) !important;
        }
        
        .modal-content {
            max-height: 98vh !important;
            border-radius: 12px !important;
        }
        
        .photo-upload-zone {
            padding: 1rem 0.75rem;
            min-height: 120px;
        }
        
        .photo-upload-zone h5 {
            font-size: 1rem;
        }
        
        .photo-upload-zone .display-1 {
            font-size: 2.5rem !important;
        }
    }
    
    .photo-upload-zone:hover {
        border-color: #8B5CF6;
        background: #f0f4ff;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.15);
    }
    
    .photo-upload-zone.dragover {
        border-color: #8B5CF6;
        background: #e6edff;
        transform: scale(1.02);
        box-shadow: 0 8px 24px rgba(139, 92, 246, 0.25);
    }
    
    .image-preview {
        max-width: 100%;
        max-height: 400px;
        border-radius: 16px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        margin: 1rem auto;
        display: block;
        object-fit: contain;
    }
    
    /* Camera preview styling */
    .camera-preview {
        position: relative;
        border-radius: 16px;
        overflow: hidden;
        background: #000;
        min-height: 300px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .camera-preview video {
        width: 100%;
        height: auto;
        display: block;
        max-height: 500px;
        object-fit: contain;
    }
    
    /* Preview section styling */
    #previewSection {
        transition: opacity 0.3s ease;
    }
    
    #previewSection[style*="display: block"] {
        animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Upload zone and camera view transitions */
    #uploadZone,
    #cameraView,
    #previewSection {
        transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    .camera-controls {
        position: absolute;
        bottom: 1rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 1rem;
        align-items: center;
    }
    
    .capture-btn {
        width: 64px;
        height: 64px;
        border-radius: 50%;
        border: 4px solid white;
        background: white;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.2s ease;
    }
    
    .capture-btn:hover {
        transform: scale(1.1);
    }
    
    .capture-btn:active {
        transform: scale(0.95);
    }
    
    /* Enhanced dropdown */
    .dropdown-menu {
        border: none;
        box-shadow: var(--shadow-lg);
        border-radius: 0.75rem;
        padding: 0.5rem;
        margin-top: 0.5rem;
    }
    
    .dropdown-item {
        border-radius: 0.5rem;
        padding: 0.625rem 1rem;
        transition: all 0.2s ease;
    }
    
    .dropdown-item:hover {
        background: rgba(139, 92, 246, 0.1);
        color: var(--primary-purple);
    }
    
    /* Improved stat cards */
    .stat-card {
        text-align: center;
        padding: 1.5rem;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.05) 0%, rgba(59, 130, 246, 0.05) 100%);
        border-radius: 1rem;
        transition: all 0.3s ease;
    }
    
    .stat-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
    }
    
    .stat-number {
        font-size: 2.5rem;
        font-weight: 700;
        background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    /* Enhanced hero section */
    .hero-section {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
        border-radius: 2rem;
        padding: 3rem 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(139, 92, 246, 0.2);
    }
    
    /* Page background improvements */
    body {
        background: linear-gradient(135deg, #F9FAFB 0%, #F3F4F6 100%);
        min-height: 100vh;
    }
    
    /* Smooth transitions for all interactive elements */
    * {
        transition: color 0.2s ease, background-color 0.2s ease, border-color 0.2s ease;
    }
    
    /* Improved container spacing */
    .container {
        padding-left: 1rem;
        padding-right: 1rem;
    }
    
    @media (min-width: 1200px) {
        .container {
            max-width: 1140px;
        }
    }
    
    /* Enhanced card header badges */
    .card-header .badge {
        background: rgba(255, 255, 255, 0.2) !important;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    /* Improved sort dropdown */
    .dropdown-toggle {
        border-radius: 0.5rem;
        padding: 0.5rem 1rem;
        font-weight: 500;
        transition: all 0.2s ease;
    }
    
    .dropdown-toggle:hover {
        background: rgba(139, 92, 246, 0.1);
        border-color: var(--primary-purple);
    }
    
    /* Better feedback messages */
    #addItemFeedback {
        border-radius: 0.75rem;
        padding: 1rem;
        margin-top: 1rem;
        font-weight: 500;
    }
    
    #addItemFeedback.alert-success {
        background: rgba(16, 185, 129, 0.1);
        color: #059669;
        border: 1px solid rgba(16, 185, 129, 0.2);
    }
    
    #addItemFeedback.alert-danger {
        background: rgba(239, 68, 68, 0.1);
        color: #DC2626;
        border: 1px solid rgba(239, 68, 68, 0.2);
    }
    
    #addItemFeedback.alert-warning {
        background: rgba(245, 158, 11, 0.1);
        color: #D97706;
        border: 1px solid rgba(245, 158, 11, 0.2);
    }
    
    /* Improved input fields in add items card */
    .form-control:not(.form-select) {
        border: 2px solid var(--gray-200);
    }
    
    .form-control:not(.form-select):focus {
        border-color: var(--primary-purple);
    }
    
    /* Better spacing */
    .card-body {
        padding: 1.5rem;
    }
    
    /* Enhanced quantity and expiration input styling */
    .quantity-input,
    .expiration-input {
        border: 2px solid var(--primary-purple) !important;
        border-radius: 0.5rem !important;
        padding: 0.5rem 0.75rem !important;
        font-weight: 500 !important;
        color: var(--primary-purple) !important;
    }
    
    .quantity-input:focus,
    .expiration-input:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2) !important;
    }
    
    /* Fix mobile responsiveness */
    @media (max-width: 768px) {
        .pantry-item-card {
            margin-bottom: 12px;
        }
        
        .card-body {
            padding: 16px !important;
        }
        
        .card-header {
            padding: 16px !important;
        }
        
        .hero-section {
            padding: 40px 0 !important;
        }
        
        .hero-section h1 {
            font-size: 2rem !important;
        }
        
        .btn-lg {
            padding: 12px 24px !important;
            font-size: 0.9rem !important;
        }
        
        .badge {
            font-size: 0.75rem !important;
            padding: 6px 12px !important;
        }
        
        .dropdown-menu {
            max-width: 100%;
            white-space: normal;
        }
        
        .dropdown-item {
            white-space: normal;
            word-wrap: break-word;
        }
    }
    
    /* Fix button text overflow */
    .btn {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .btn-lg {
        white-space: normal;
    }
    
    /* Fix badge display on small screens */
    .badge {
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: inline-block;
    }
    
    /* Ensure cards don't overflow container */
    .card {
        max-width: 100%;
        overflow: hidden;
    }
    
    /* Fix flex-grow text overflow */
    .flex-grow-1 {
        min-width: 0;
        overflow: hidden;
    }
    
    /* Recipe card improvements */
    .recipe-card {
        overflow: hidden;
    }
    
    .recipe-card .card-title {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    
    /* Fix sort dropdown on mobile */
    @media (max-width: 576px) {
        .dropdown-toggle {
            font-size: 0.875rem;
            padding: 6px 12px;
        }
        
        .card-header .d-flex {
            flex-direction: column;
            align-items: flex-start !important;
            gap: 12px;
        }
        
        .card-header .d-flex > div:last-child {
            width: 100%;
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- Hero Section -->
<div class="hero-section text-white py-5 mb-4">
    <div class="container">
        <div class="row align-items-center">
            <div class="col-lg-8">
                <div class="d-flex align-items-center mb-4">
                    <img src="{{ url_for('static', filename='logo.png') }}" alt="Smart Pantry" height="80" class="me-3" style="max-width: 80px;">
                    <div>
                        <h1 class="display-4 fw-bold mb-1" style="text-shadow: 0 2px 8px rgba(0,0,0,0.2);">SmartPantry</h1>
                        <p class="mb-0 opacity-90" style="font-size: 1.1rem;">Your intelligent kitchen companion</p>
                    </div>
                </div>
                {% if username %}
                    <p class="lead mb-3 opacity-95" style="font-size: 1.2rem;">Welcome back, <strong>{{ username }}</strong>!</p>
                {% endif %}
                <div class="d-flex flex-wrap gap-3 mt-4">
                    <span class="badge px-4 py-2 border-0" style="background: rgba(255,255,255,0.25); backdrop-filter: blur(10px); color: white; border-radius: 12px;">
                        <i class="bi bi-camera-fill me-2"></i>Photo Recognition
                    </span>
                    <span class="badge px-4 py-2 border-0" style="background: rgba(255,255,255,0.25); backdrop-filter: blur(10px); color: white; border-radius: 12px;">
                        <i class="bi bi-book me-2"></i>Smart Recipes
                    </span>
                    <span class="badge px-4 py-2 border-0" style="background: rgba(255,255,255,0.25); backdrop-filter: blur(10px); color: white; border-radius: 12px;">
                        <i class="bi bi-graph-up me-2"></i>Nutrition Tracking
                    </span>
                </div>
            </div>
            <div class="col-lg-4 text-center mt-4 mt-lg-0">
                <div style="width: 140px; height: 140px; background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.1) 100%); border-radius: 35px; display: flex; align-items: center; justify-content: center; margin: 0 auto; box-shadow: 0 12px 32px rgba(0,0,0,0.2); backdrop-filter: blur(10px);">
                    <i class="bi bi-house-heart" style="font-size: 4rem; opacity: 0.9;"></i>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="container py-4">
    <div class="row">
        <!-- Main Content -->
        <div class="col-lg-8">
            <!-- Quick Actions Card - Cleaner Design -->
            <div class="card shadow-sm border-0 mb-4" style="border-radius: 20px; overflow: hidden;">
                <div class="card-body p-4">
                    <div class="row g-4">
                        <!-- Manual Add Item -->
                        <div class="col-md-6">
                            <div class="h-100 p-4" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08) 0%, rgba(59, 130, 246, 0.05) 100%); border-radius: 18px; border: 1px solid rgba(139, 92, 246, 0.15);">
                                <div class="d-flex align-items-center mb-4">
                                    <div class="me-3" style="width: 48px; height: 48px; background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border-radius: 14px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);">
                                        <i class="bi bi-plus-circle-fill text-white" style="font-size: 1.5rem;"></i>
                                    </div>
                                    <h5 class="mb-0 fw-bold" style="color: #1e293b;">Add Items</h5>
                                </div>
                                <form action="/add" method="post" id="addItemForm" onsubmit="return handleAddItem(event);">
                                    <div class="mb-3">
                                        <label class="form-label fw-semibold small text-muted mb-2">Item Name</label>
                                        <input type="text" name="item" id="itemInput" class="form-control form-control-lg" 
                                               placeholder="e.g., Milk, Bread, Eggs" required autocomplete="off"
                                               style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 14px 16px;">
                                        <div class="row g-2 mt-2">
                                            <div class="col-6">
                                                <label class="form-label fw-semibold small text-muted mb-1">Quantity</label>
                                                <input type="text" name="quantity" id="quantityInput" class="form-control" 
                                                       placeholder="1" value="1" autocomplete="off"
                                                       style="border-radius: 10px; border: 2px solid #e2e8f0;">
                                            </div>
                                            <div class="col-6">
                                                <label class="form-label fw-semibold small text-muted mb-1">Expires <span class="text-muted" style="font-weight: normal;">(optional)</span></label>
                                                <input type="date" name="expiration_date" id="expirationInput" class="form-control"
                                                       style="border-radius: 10px; border: 2px solid #e2e8f0;"
                                                       value="">
                                            </div>
                                        </div>
                                    </div>
                                    <button type="submit" class="btn btn-primary btn-lg w-100" id="addItemBtn"
                                            style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border: none; border-radius: 12px; padding: 14px; font-weight: 600; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3); transition: all 0.3s ease;">
                                        <i class="bi bi-plus-circle-fill me-2"></i><span id="addItemBtnText">Add to Pantry</span>
                                    </button>
                                </form>
                                <div id="addItemFeedback" class="mt-3" style="display: none;"></div>
                            </div>
                        </div>
                        
                        <!-- Photo Upload -->
                        <div class="col-md-6">
                            <div class="h-100 p-4" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08) 0%, rgba(5, 150, 105, 0.05) 100%); border-radius: 18px; border: 1px solid rgba(16, 185, 129, 0.15);">
                                <div class="d-flex align-items-center mb-4">
                                    <div class="me-3" style="width: 48px; height: 48px; background: linear-gradient(135deg, #10B981 0%, #059669 100%); border-radius: 14px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);">
                                        <i class="bi bi-camera-fill text-white" style="font-size: 1.5rem;"></i>
                                    </div>
                                    <h5 class="mb-0 fw-bold" style="color: #1e293b;">Photo Upload</h5>
                                </div>
                                <p class="text-muted small mb-3">Upload a photo and let AI detect food items automatically</p>
                                <button type="button" class="btn btn-success btn-lg w-100" data-bs-toggle="modal" data-bs-target="#photoModal"
                                        style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); border: none; border-radius: 12px; padding: 14px; font-weight: 600; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); transition: all 0.3s ease;">
                                    <i class="bi bi-camera-fill me-2"></i>Take/Upload Photo
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pantry Overview - Cleaner Design -->
            <div class="card shadow-sm border-0" style="border-radius: 20px; overflow: visible; position: relative; z-index: 1;">
                <div class="card-header border-0" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.08) 100%); padding: 20px 24px; position: relative; z-index: 1; overflow: visible;">
                    <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                        <h5 class="mb-0 fw-bold" style="color: #1e293b; font-size: 1.25rem;">
                            <i class="bi bi-basket-fill me-2" style="color: #8B5CF6;"></i>Your Pantry
                        </h5>
                        <div class="d-flex align-items-center gap-2">
                            {% if items %}
                            <span class="badge px-3 py-2" style="background: linear-gradient(135deg, #7C3AED 0%, #2563EB 100%) !important; color: #ffffff !important; border-radius: 10px; font-size: 0.875rem; font-weight: 700; text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); box-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);">
                                <i class="bi bi-basket-fill me-1"></i>{{ items|length }} {{ 'item' if items|length == 1 else 'items' }}
                            </span>
                            {% endif %}
                        </div>
                    </div>
                </div>
                <div class="card-body p-4" style="position: relative; z-index: 5; overflow: visible;">
                    <!-- Search Bar -->
                    <div class="mb-3">
                        <div class="input-group" style="max-width: 100%;">
                            <span class="input-group-text bg-white border-end-0" style="border: 2px solid #e2e8f0; border-radius: 10px 0 0 10px; padding: 0.75rem 1rem;">
                                <i class="bi bi-search text-muted"></i>
                            </span>
                            <input type="text" 
                                   class="form-control border-start-0" 
                                   id="searchItemsInput" 
                                   placeholder="Search items..." 
                                   style="border: 2px solid #e2e8f0; border-left: none; border-radius: 0 10px 10px 0; padding: 0.75rem 1rem; font-size: 0.95rem;"
                                   autocomplete="off">
                        </div>
                    </div>
                    
                    <!-- Sort Controls - Positioned above items -->
                            {% if items is defined and items is not none and items|length > 1 %}
                    <div class="d-flex justify-content-between align-items-center mb-3 pb-3" style="border-bottom: 2px solid rgba(139, 92, 246, 0.1);">
                        <div class="d-flex align-items-center gap-2">
                            <span class="text-muted small fw-semibold" style="color: #64748b; font-size: 0.875rem;">
                                <i class="bi bi-sort-down me-1"></i>Sort by:
                            </span>
                            <div class="dropdown">
                                <button class="btn btn-sm btn-outline-primary dropdown-toggle" type="button" id="sortDropdown" data-bs-toggle="dropdown" aria-expanded="false" style="border-radius: 8px; border-color: #8B5CF6; color: #8B5CF6; font-weight: 600;">
                                    <i class="bi bi-grid-3x3-gap me-1"></i><span id="currentSortLabel">Category</span>
                                </button>
                                <ul class="dropdown-menu dropdown-menu-start" aria-labelledby="sortDropdown" style="border-radius: 12px; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12); border: 1px solid rgba(139, 92, 246, 0.1);">
                                    <li><a class="dropdown-item" href="#" onclick="sortPantry('category'); updateSortLabel('Category'); return false;" style="padding: 10px 16px; font-weight: 600;"><i class="bi bi-grid-3x3-gap me-2" style="color: #8B5CF6;"></i>Category</a></li>
                                    <li><hr class="dropdown-divider" style="margin: 8px 0;"></li>
                                    <li><a class="dropdown-item" href="#" onclick="sortPantry('name'); updateSortLabel('Name (A-Z)'); return false;" style="padding: 10px 16px;"><i class="bi bi-sort-alpha-down me-2"></i>Name (A-Z)</a></li>
                                    <li><a class="dropdown-item" href="#" onclick="sortPantry('name-desc'); updateSortLabel('Name (Z-A)'); return false;" style="padding: 10px 16px;"><i class="bi bi-sort-alpha-up me-2"></i>Name (Z-A)</a></li>
                                    <li><hr class="dropdown-divider" style="margin: 8px 0;"></li>
                                    <li><a class="dropdown-item" href="#" onclick="sortPantry('expiration'); updateSortLabel('Expiration (Soonest)'); return false;" style="padding: 10px 16px;"><i class="bi bi-calendar-check me-2"></i>Expiration (Soonest)</a></li>
                                    <li><a class="dropdown-item" href="#" onclick="sortPantry('expiration-desc'); updateSortLabel('Expiration (Latest)'); return false;" style="padding: 10px 16px;"><i class="bi bi-calendar-x me-2"></i>Expiration (Latest)</a></li>
                                </ul>
                            </div>
                        </div>
                        <div id="categoryGroupInfo" class="text-muted small" style="display: none; color: #64748b; font-size: 0.8rem;">
                            <i class="bi bi-info-circle me-1"></i>Grouped by category
                    </div>
                </div>
                    {% endif %}
                    {% if items is defined and items is not none and items|length > 0 %}
                    <div class="row g-3" id="pantryItemsContainer" style="position: relative; z-index: 10;">
                        {% for item in items %}
                        {% set item_name = (item.get('name', '') if item|is_dict else (item if item else ''))|string|trim %}
                        {% set item_name = item_name if item_name else 'Unnamed Item' %}
                        {% set exp_date = (item.get('expirationDate', '') if item|is_dict else '')|string|trim %}
                        {% set quantity = (item.get('quantity', '1') if item|is_dict else '1')|string|trim %}
                        {% set quantity = quantity if quantity else '1' %}
                        {% set item_id = (item.get('id', '') if item|is_dict else '')|string|trim %}
                        <div class="col-md-6 col-lg-4 pantry-item-wrapper" 
                             data-item-name="{{ item_name|lower|default('unnamed') }}"
                             data-item-id="{{ item_id }}"
                             data-expiration-date="{% if exp_date and exp_date|length >= 10 %}{{ exp_date[:10] }}{% elif exp_date %}{{ exp_date|trim }}{% else %}9999-12-31{% endif %}"
                             style="position: relative; z-index: 10;">
                            <div class="pantry-item-card card border-0 bg-white h-100" 
                                 style="border-radius: 20px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); border: 1px solid #e2e8f0; cursor: pointer; overflow: hidden; position: relative;"
                                 onmouseover="this.style.transform='translateY(-8px) scale(1.02)'; this.style.boxShadow='0 16px 32px rgba(139, 92, 246, 0.2)'; this.style.borderColor='#8B5CF6';"
                                 onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.08)'; this.style.borderColor='#e2e8f0';">
                                <!-- Accent bar at top -->
                                <div style="height: 4px; background: linear-gradient(90deg, #8B5CF6 0%, #3B82F6 100%); width: 100%;"></div>
                                
                                <div class="card-body p-4">
                                    <div class="d-flex justify-content-between align-items-start mb-3">
                                        <!-- Item name with icon -->
                                        <div class="flex-grow-1" style="min-width: 0; overflow: hidden;">
                                            <div class="d-flex align-items-center mb-3">
                                                <div class="me-3" style="width: 40px; height: 40px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                                    <i class="bi bi-box-seam" style="font-size: 1.25rem; color: #8B5CF6;"></i>
                                                </div>
                                                <div class="flex-grow-1" style="min-width: 0;">
                                                    <h6 class="mb-0 fw-bold text-dark" style="font-size: 1.1rem; line-height: 1.3; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="{{ item_name }}">
                                                    {{ item_name }}
                                                    </h6>
                                            </div>
                                            </div>
                                            
                                            <!-- Quantity and Expiration badges in a row -->
                                            {% if item|is_dict %}
                                                <div class="d-flex flex-wrap gap-2 align-items-center">
                                                    {% if item_id and item_id.strip() %}
                                                    <!-- Editable Quantity Badge -->
                                                    <span class="badge editable-quantity" 
                                                          data-item-id="{{ item_id }}"
                                                          data-item-name="{{ item_name }}"
                                                          data-current-quantity="{{ quantity }}"
                                                          data-expiration-date="{{ exp_date }}"
                                                          data-added-date="{{ item.get('addedDate', '') if item.get('addedDate') else '' }}"
                                                          style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(59, 130, 246, 0.12) 100%); color: #8B5CF6; border-radius: 10px; font-size: 0.8rem; font-weight: 600; padding: 0.5rem 0.75rem; cursor: pointer; transition: all 0.2s ease; border: 1px solid rgba(139, 92, 246, 0.2);"
                                                          title="Click to edit quantity"
                                                          onmouseover="this.style.background='linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(59, 130, 246, 0.2) 100%)'; this.style.transform='scale(1.05)'; this.style.borderColor='#8B5CF6';"
                                                          onmouseout="this.style.background='linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(59, 130, 246, 0.12) 100%)'; this.style.transform='scale(1)'; this.style.borderColor='rgba(139, 92, 246, 0.2)';">
                                                        <i class="bi bi-hash me-1" style="font-size: 0.85rem;"></i><span class="quantity-value fw-bold">{{ quantity }}</span>
                                                        </span>
                                                    {% elif quantity and quantity != '1' %}
                                                    <!-- Non-editable Quantity Badge -->
                                                    <span class="badge" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(59, 130, 246, 0.12) 100%); color: #8B5CF6; border-radius: 10px; font-size: 0.8rem; font-weight: 600; padding: 0.5rem 0.75rem; border: 1px solid rgba(139, 92, 246, 0.2);">
                                                        <i class="bi bi-hash me-1" style="font-size: 0.85rem;"></i>{{ quantity }}
                                                    </span>
                                                {% endif %}
                                                    
                                                    {% if item_id and item_id.strip() %}
                                                        <!-- Editable Expiration Badge -->
                                                {% if exp_date and exp_date != 'None' and exp_date != '' %}
                                                        <span class="badge editable-expiration expiration-badge expiration-fresh" 
                                                              data-item-id="{{ item_id }}"
                                                              data-item-name="{{ item_name }}"
                                                              data-current-quantity="{{ quantity }}"
                                                              data-current-expiration="{{ exp_date }}"
                                                              data-added-date="{{ item.get('addedDate', '') if item.get('addedDate') else '' }}"
                                                              data-exp-date="{{ exp_date }}" 
                                                              style="font-size: 0.75rem; font-weight: 600; padding: 0.4rem 0.6rem; border-radius: 10px; cursor: pointer; transition: all 0.2s ease; border: 1px solid rgba(16, 185, 129, 0.2); min-width: 150px; max-width: 100%; display: inline-flex; align-items: center; justify-content: flex-start; overflow: visible;"
                                                              title="Click to edit expiration date"
                                                              onmouseover="this.style.opacity='0.9'; this.style.transform='scale(1.05)'; this.style.boxShadow='0 2px 8px rgba(16, 185, 129, 0.2)';"
                                                              onmouseout="this.style.opacity='1'; this.style.transform='scale(1)'; this.style.boxShadow='none';">
                                                            <i class="bi bi-clock-fill me-1" style="font-size: 0.75rem;"></i>
                                                            <span class="expiration-value" style="white-space: nowrap; overflow: visible; text-overflow: clip;">
                                                                {% if exp_date and exp_date != 'None' and exp_date != '' and exp_date != 'null' %}
                                                                    {% set date_str = exp_date|trim %}
                                                                    {% if date_str|length >= 10 and date_str.count('-') >= 2 %}
                                                                        {% set date_part = date_str[:10] %}
                                                                        {% if date_part|length == 10 and date_part[4] == '-' and date_part[7] == '-' %}
                                                                            {{ date_part }}
                                                            {% else %}
                                                                            Add Date
                                                                        {% endif %}
                                                                    {% else %}
                                                                        Add Date
                                                                    {% endif %}
                                                                {% else %}
                                                                    Add Date
                                                            {% endif %}
                                                        </span>
                                                        </span>
                                                        {% else %}
                                                        <span class="badge editable-expiration" 
                                                              data-item-id="{{ item_id }}"
                                                              data-item-name="{{ item_name }}"
                                                              data-current-quantity="{{ quantity }}"
                                                              data-current-expiration=""
                                                              data-added-date="{{ item.get('addedDate', '') if item.get('addedDate') else '' }}"
                                                              style="font-size: 0.75rem; font-weight: 600; padding: 0.4rem 0.6rem; cursor: pointer; background: linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(59, 130, 246, 0.12) 100%); color: #8B5CF6; border-radius: 10px; transition: all 0.2s ease; border: 1px solid rgba(139, 92, 246, 0.2); min-width: 150px; display: inline-flex; align-items: center; justify-content: flex-start;"
                                                              title="Click to add expiration date"
                                                              onmouseover="this.style.background='linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(59, 130, 246, 0.2) 100%)'; this.style.transform='scale(1.05)'; this.style.borderColor='#8B5CF6';"
                                                              onmouseout="this.style.background='linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(59, 130, 246, 0.12) 100%)'; this.style.transform='scale(1)'; this.style.borderColor='rgba(139, 92, 246, 0.2)';">
                                                            <i class="bi bi-clock me-1" style="font-size: 0.75rem;"></i>
                                                            <span class="expiration-value">Add Date</span>
                                                        </span>
                                                {% endif %}
                                                    {% elif exp_date and exp_date != 'None' and exp_date != '' %}
                                                        <!-- Non-editable Expiration Badge -->
                                                        <span class="expiration-badge expiration-fresh" data-exp-date="{{ exp_date }}" style="font-size: 0.75rem; font-weight: 600; padding: 0.4rem 0.6rem; border-radius: 10px; border: 1px solid rgba(16, 185, 129, 0.2); min-width: 150px; max-width: 100%; display: inline-flex; align-items: center; justify-content: flex-start; overflow: visible;">
                                                            <i class="bi bi-clock-fill me-1" style="font-size: 0.75rem;"></i>
                                                            <span style="white-space: nowrap; overflow: visible; text-overflow: clip;">
                                                                {% if exp_date and exp_date != 'None' and exp_date != '' and exp_date != 'null' %}
                                                                    {% set date_str = exp_date|trim %}
                                                                    {% if date_str|length >= 10 and date_str.count('-') >= 2 %}
                                                                        {% set date_part = date_str[:10] %}
                                                                        {% if date_part|length == 10 and date_part[4] == '-' and date_part[7] == '-' %}
                                                                            {{ date_part }}
                                                                        {% else %}
                                                                            No Date
                                                                        {% endif %}
                                                                    {% else %}
                                                                        No Date
                                                                    {% endif %}
                                                                {% else %}
                                                                    No Date
                                                                {% endif %}
                                                            </span>
                                                        </span>
                                            {% endif %}
                                        </div>
                                            {% endif %}
                                        </div>
                                        
                                        <!-- Delete button -->
                                        <button type="button"
                                           class="btn btn-sm delete-item-btn" 
                                           style="border-radius: 12px; width: 40px; height: 40px; padding: 0; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; flex-shrink: 0; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.2); color: #EF4444;"
                                           title="Remove item"
                                           data-item-name="{{ item_name|urlencode }}"
                                           onmouseover="this.style.background='#ef4444'; this.style.color='white'; this.style.transform='scale(1.1) rotate(90deg)'; this.style.borderColor='#ef4444';"
                                           onmouseout="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.color='#EF4444'; this.style.transform='scale(1) rotate(0deg)'; this.style.borderColor='rgba(239, 68, 68, 0.2)';">
                                            <i class="bi bi-trash3-fill" style="font-size: 0.9rem;"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                    {% else %}
                    <div class="empty-state text-center py-5">
                        <div class="mb-4">
                            <div style="width: 120px; height: 120px; margin: 0 auto; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.08) 100%); border-radius: 30px; display: flex; align-items: center; justify-content: center;">
                                <i class="bi bi-basket" style="font-size: 4rem; color: #8B5CF6; opacity: 0.6;"></i>
                            </div>
                        </div>
                        <h4 class="mt-4 mb-2 fw-bold" style="color: #1e293b;">Your pantry is empty</h4>
                        <p class="mb-4 text-muted" style="font-size: 1rem;">Start adding items to get personalized recipe suggestions!</p>
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="col-lg-4">
            <!-- Recipe Suggestions Card -->
            <div class="card shadow-sm border-0 mb-4">
                <div class="card-header bg-gradient-success text-white border-0">
                    <h5 class="mb-0 fw-bold">
                        <i class="bi bi-book me-2"></i>Smart Recipes
                    </h5>
                </div>
                <div class="card-body text-center">
                    <div class="mb-4">
                        <div style="width: 80px; height: 80px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2) 0%, rgba(5, 150, 105, 0.2) 100%); border-radius: 20px; display: flex; align-items: center; justify-content: center; margin: 0 auto;">
                            <i class="bi bi-book" style="font-size: 2.5rem; color: #10B981;"></i>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="expiringDays" class="form-label text-muted small fw-semibold mb-2 d-block">
                            <i class="bi bi-clock me-1"></i>Use items expiring within:
                        </label>
                        <select class="form-select form-select-lg" id="expiringDays" style="border-radius: 12px;">
                            <option value="">All items</option>
                            <option value="3">3 days</option>
                            <option value="7">7 days</option>
                            <option value="14">14 days</option>
                            <option value="30">30 days</option>
                        </select>
                    </div>
                    <a href="{{ url_for('suggest_recipe') }}" class="btn btn-success btn-lg w-100 mb-3" id="recipeBtn" style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); border: none; border-radius: 16px; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); transition: all 0.3s ease;">
                        <i class="bi bi-stars me-2"></i>Get Recipe Ideas
                    </a>
                    <p class="text-muted small mb-0">
                        <i class="bi bi-stars me-1"></i>AI-powered recipe suggestions
                    </p>
                </div>
            </div>

            <!-- Quick Stats -->
            <div class="card shadow-sm border-0 mb-4">
                <div class="card-header bg-gradient-info text-white border-0">
                    <h5 class="mb-0 fw-bold">
                        <i class="bi bi-graph-up me-2"></i>Pantry Stats
                    </h5>
                </div>
                <div class="card-body">
                    <div class="stat-card" id="pantryStatsCard">
                        <div class="stat-number mb-2" id="pantryStatsCount">{{ items|length if items else 0 }}</div>
                        <div class="text-muted fw-semibold">Total Items</div>
                    </div>
                </div>
            </div>

            <!-- Quick Tips -->
            <div class="card shadow-sm border-0">
                <div class="card-header bg-gradient-warning text-dark border-0">
                    <h5 class="mb-0 fw-bold">
                        <i class="bi bi-info-circle-fill me-2"></i>Pro Tips
                    </h5>
                </div>
                <div class="card-body">
                    <div class="d-flex mb-3 pb-3" style="border-bottom: 1px solid rgba(0,0,0,0.05);">
                        <div class="me-3" style="width: 32px; height: 32px; background: rgba(16, 185, 129, 0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <i class="bi bi-check-circle-fill text-success"></i>
                        </div>
                        <div>
                            <strong class="d-block mb-1">Smart Upload</strong>
                            <small class="text-muted">Use clear, well-lit photos for better AI recognition</small>
                        </div>
                    </div>
                    <div class="d-flex mb-3 pb-3" style="border-bottom: 1px solid rgba(0,0,0,0.05);">
                        <div class="me-3" style="width: 32px; height: 32px; background: rgba(139, 92, 246, 0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <i class="bi bi-stars text-primary"></i>
                        </div>
                        <div>
                            <strong class="d-block mb-1">Recipe Magic</strong>
                            <small class="text-muted">More items = better recipe suggestions</small>
                        </div>
                    </div>
                    <div class="d-flex">
                        <div class="me-3" style="width: 32px; height: 32px; background: rgba(59, 130, 246, 0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <i class="bi bi-graph-up-arrow text-info"></i>
                        </div>
                        <div>
                            <strong class="d-block mb-1">Nutrition Tracking</strong>
                            <small class="text-muted">Get detailed nutrition info for your recipes</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Photo Upload Modal -->
<div class="modal fade" id="photoModal" tabindex="-1" aria-labelledby="photoModalLabel" aria-hidden="true" data-bs-backdrop="true" data-bs-keyboard="true" role="dialog" aria-modal="true" style="pointer-events: auto;">
    <div class="modal-dialog modal-dialog-centered" style="pointer-events: auto; z-index: 9999; max-height: 90vh; margin: 1rem auto; max-width: 600px; width: 90%;">
        <div class="modal-content" style="border-radius: 24px; border: none; pointer-events: auto; z-index: 10000; position: relative; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header border-0 pb-0" style="pointer-events: auto;">
                <h5 class="modal-title fw-bold" id="photoModalLabel">
                    <i class="bi bi-camera-fill me-2 text-success"></i>Add Items with Photo
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close" style="pointer-events: auto; cursor: pointer; z-index: 10;"></button>
            </div>
            <div class="modal-body p-4">
                <!-- Camera View (Hidden by default) -->
                <div id="cameraView" class="camera-preview mb-3" style="display: none;">
                    <video id="cameraStream" autoplay playsinline></video>
                    <div class="camera-controls">
                        <button type="button" class="btn btn-light btn-sm me-2" id="closeCameraBtn">
                            <i class="bi bi-x-lg"></i> Close
                        </button>
                        <button type="button" class="capture-btn" id="captureBtn" title="Capture Photo"></button>
                    </div>
                </div>

                <!-- Upload Zone -->
                <div id="uploadZone">
                    <!-- Camera Buttons -->
                    <div class="row g-2 mb-3">
                        <div class="col-6">
                            <button type="button" class="btn btn-outline-success w-100" id="openCameraBtn">
                                <i class="bi bi-camera-video me-2"></i>Live Camera
                            </button>
                        </div>
                        <div class="col-6">
                            <button type="button" class="btn btn-success w-100" id="mobileCameraBtn">
                                <i class="bi bi-camera-fill me-2"></i>Take Photo
                            </button>
                        </div>
                    </div>

                    <div class="text-center mb-3">
                        <span class="text-muted">or</span>
                    </div>

                    <!-- Drag & Drop Zone -->
                    <div class="photo-upload-zone" id="dropZone">
                        <i class="bi bi-cloud-upload display-1 text-muted mb-3"></i>
                        <h5 class="mb-2">Drag & Drop Photo Here</h5>
                        <p class="text-muted mb-3">or click to browse</p>
                        <button type="button" class="btn btn-primary" id="browseBtn">
                            <i class="bi bi-folder2-open me-2"></i>Browse Files
                        </button>
                        <input type="file" id="photoInput" accept="image/*" style="display: none;">
                        <input type="file" id="mobileCameraInput" accept="image/*" capture="environment" style="display: none;">
                    </div>
                </div>

                <!-- Preview & Upload Section (Hidden by default) -->
                <div id="previewSection" style="display: none;">
                    <div class="text-center">
                        <!-- Loading/Feedback Message -->
                        <div id="uploadFeedback" class="feedback-message" style="display: none;"></div>
                        
                        <img id="imagePreview" class="image-preview" alt="Preview">
                        <div class="mt-3 d-flex flex-wrap justify-content-center gap-2">
                            <button type="button" class="btn btn-outline-secondary" id="cancelUploadBtn">
                                <i class="bi bi-x-circle me-2"></i>Cancel
                            </button>
                            <button type="button" class="btn btn-success btn-lg" id="uploadBtn">
                                <i class="bi bi-stars me-2"></i><span id="uploadBtnText">Analyze & Add Items</span>
                            </button>
                        </div>
                        <small class="text-muted d-block mt-2">AI will detect food items in your photo</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    let selectedFile = null;
    let cameraStream = null;

    // DOM Elements
    const photoModal = document.getElementById('photoModal');
    const photoInput = document.getElementById('photoInput');
    const mobileCameraInput = document.getElementById('mobileCameraInput');
    const dropZone = document.getElementById('dropZone');
    const browseBtn = document.getElementById('browseBtn');
    const mobileCameraBtn = document.getElementById('mobileCameraBtn');
    const uploadZone = document.getElementById('uploadZone');
    const previewSection = document.getElementById('previewSection');
    const imagePreview = document.getElementById('imagePreview');
    const uploadBtn = document.getElementById('uploadBtn');
    const cancelUploadBtn = document.getElementById('cancelUploadBtn');
    const uploadBtnText = document.getElementById('uploadBtnText');
    
    // Camera Elements
    const cameraView = document.getElementById('cameraView');
    const cameraStreamVideo = document.getElementById('cameraStream');
    const openCameraBtn = document.getElementById('openCameraBtn');
    const closeCameraBtn = document.getElementById('closeCameraBtn');
    const captureBtn = document.getElementById('captureBtn');

    // Browse button click
    if (browseBtn && photoInput) {
        browseBtn.addEventListener('click', () => photoInput.click());
    }

    // Mobile camera button (works without HTTPS)
    if (mobileCameraBtn && mobileCameraInput) {
        mobileCameraBtn.addEventListener('click', () => mobileCameraInput.click());
    }

    // File input change
    if (photoInput) {
        photoInput.addEventListener('change', handleFileSelect);
    }
    if (mobileCameraInput) {
        mobileCameraInput.addEventListener('change', handleFileSelect);
    }

    // Drag and drop handlers
    if (dropZone) {
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        dropZone.addEventListener('click', (e) => {
            if (e.target === dropZone || e.target.closest('#dropZone')) {
                if (photoInput) {
                    photoInput.click();
                }
            }
        });
    }

    // Handle file selection
    function handleFileSelect(e) {
        const files = e.target.files;
        if (files.length > 0) {
            handleFile(files[0]);
        }
    }

    // Handle file
    function handleFile(file) {
        if (!file.type.startsWith('image/')) {
            alert('Please select an image file');
            return;
        }

        selectedFile = file;
        const reader = new FileReader();
        reader.onload = (e) => {
            if (imagePreview) {
                imagePreview.src = e.target.result;
                imagePreview.style.opacity = '0';
                setTimeout(() => {
                    imagePreview.style.opacity = '1';
                }, 50);
            }
            
            // Smooth transition between upload zone and preview
            if (uploadZone) {
                uploadZone.style.opacity = '0';
                setTimeout(() => {
                    uploadZone.style.display = 'none';
                    uploadZone.style.opacity = '1';
                }, 150);
            }
            if (previewSection) {
                previewSection.style.display = 'block';
                previewSection.style.opacity = '0';
                setTimeout(() => {
                    previewSection.style.opacity = '1';
                }, 150);
            }
        };
        reader.readAsDataURL(file);
    }

    // Camera Functions
    if (openCameraBtn) {
        openCameraBtn.addEventListener('click', async () => {
            // Prevent multiple clicks
            if (openCameraBtn.disabled) {
                return;
            }
            
        // Check if getUserMedia is supported
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            alert('Camera access requires HTTPS or localhost.\n\nTo use camera:\n1. Access via https:// (requires SSL certificate)\n2. Access via http://localhost:5050 or http://127.0.0.1:5050\n\nFor now, please use "Browse Files" to upload a photo instead.');
            return;
        }

            // Disable button while requesting camera
            openCameraBtn.disabled = true;
            const originalText = openCameraBtn.textContent;
            openCameraBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Opening Camera...';

        try {
            cameraStream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment' } 
            });
            if (cameraStreamVideo) cameraStreamVideo.srcObject = cameraStream;
            
            // Smooth transition between upload zone and camera view
            if (uploadZone) {
                uploadZone.style.opacity = '0';
                setTimeout(() => {
                    uploadZone.style.display = 'none';
                    uploadZone.style.opacity = '1';
                }, 150);
            }
            if (cameraView) {
                cameraView.style.display = 'block';
                cameraView.style.opacity = '0';
                setTimeout(() => {
                    cameraView.style.opacity = '1';
                }, 150);
            }
        } catch (err) {
                // Stop any partial stream
                if (cameraStream) {
                    stopCamera();
                }
                
                let errorMessage = 'Could not access camera.';
            if (err.name === 'NotAllowedError') {
                    errorMessage = 'Camera permission denied. Please allow camera access and try again.';
            } else if (err.name === 'NotFoundError') {
                    errorMessage = 'No camera found on this device.';
            } else {
                    errorMessage = 'Could not access camera: ' + err.message + '\n\nPlease use "Browse Files" to upload a photo instead.';
            }
                alert(errorMessage);
            } finally {
                // Always re-enable button
                openCameraBtn.disabled = false;
                openCameraBtn.textContent = originalText;
        }
        });
    }

    if (closeCameraBtn) {
        closeCameraBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            stopCamera();
            
            // Smooth transition back to upload zone
            if (cameraView) {
                cameraView.style.opacity = '0';
                setTimeout(() => {
                    cameraView.style.display = 'none';
                    cameraView.style.opacity = '1';
                }, 150);
            }
            if (uploadZone) {
                uploadZone.style.display = 'block';
                uploadZone.style.opacity = '0';
                setTimeout(() => {
                    uploadZone.style.opacity = '1';
                }, 150);
            }
        });
        // Ensure button is clickable
        closeCameraBtn.style.pointerEvents = 'auto';
        closeCameraBtn.style.cursor = 'pointer';
        closeCameraBtn.style.zIndex = '10';
    }

    if (captureBtn && cameraStreamVideo) {
        captureBtn.addEventListener('click', () => {
        const canvas = document.createElement('canvas');
        canvas.width = cameraStreamVideo.videoWidth;
        canvas.height = cameraStreamVideo.videoHeight;
        canvas.getContext('2d').drawImage(cameraStreamVideo, 0, 0);
        
        canvas.toBlob((blob) => {
            selectedFile = new File([blob], 'camera-capture.jpg', { type: 'image/jpeg' });
            if (imagePreview) {
                imagePreview.src = canvas.toDataURL('image/jpeg');
                imagePreview.style.opacity = '0';
                setTimeout(() => {
                    imagePreview.style.opacity = '1';
                }, 50);
            }
            stopCamera();
            
            // Smooth transition between camera view and preview
            if (cameraView) {
                cameraView.style.opacity = '0';
                setTimeout(() => {
                    cameraView.style.display = 'none';
                    cameraView.style.opacity = '1';
                }, 150);
            }
            if (previewSection) {
                previewSection.style.display = 'block';
                previewSection.style.opacity = '0';
                setTimeout(() => {
                    previewSection.style.opacity = '1';
                }, 150);
            }
        }, 'image/jpeg');
        });
    }

    function stopCamera() {
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
        }
    }

    // Cancel upload
    if (cancelUploadBtn) {
        cancelUploadBtn.addEventListener('click', () => {
            resetPhotoUploadState();
        });
    }

    // Upload photo - Redone with better error handling and state management
    if (uploadBtn && uploadBtnText) {
        uploadBtn.addEventListener('click', async function handlePhotoUpload() {
            // Prevent multiple clicks
            if (uploadBtn.disabled) {
                return;
            }
            
            if (!selectedFile) {
                const feedback = document.getElementById('addItemFeedback');
                if (feedback) {
                    showFeedback('Please select a photo first', 'warning');
                } else {
                    alert('Please select a photo first');
                }
                return;
            }

            const formData = new FormData();
            formData.append('photo', selectedFile);

            // Set loading state
            uploadBtn.disabled = true;
            uploadBtn.classList.add('loading');
            const originalText = uploadBtnText.textContent;
            uploadBtnText.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Analyzing...';
            
            // Show loading feedback
            const uploadFeedback = document.getElementById('uploadFeedback');
            if (uploadFeedback) {
                uploadFeedback.className = 'feedback-message loading-feedback';
                uploadFeedback.innerHTML = '<span class="spinner-border spinner-border-sm"></span>Analyzing photo with AI...';
                uploadFeedback.style.display = 'flex';
            }

            try {
                const response = await fetch('{{ url_for("upload_photo") }}', {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    // Don't set Content-Type header - browser will set it automatically with boundary for FormData
                });

                if (response.ok) {
                    // Show success message in modal
                    const uploadFeedback = document.getElementById('uploadFeedback');
                    if (uploadFeedback) {
                        uploadFeedback.className = 'feedback-message success';
                        uploadFeedback.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i>Photo analyzed! Items added to pantry.';
                        uploadFeedback.style.display = 'flex';
                    }
                    
                    // Show success message on main page
                    const feedback = document.getElementById('addItemFeedback');
                    if (feedback) {
                        showFeedback('Photo analyzed! Items added to pantry.', 'success');
                    }
                    
                    // Close modal after short delay to show success message
                    setTimeout(() => {
                    closePhotoModal();
                    
                    // Reset upload state
                    resetPhotoUploadState();
                    
                    // Update pantry items after a short delay
                    setTimeout(async () => {
                        await reloadPantryItems();
                    }, 300);
                    }, 1500);
                } else {
                    // Handle error response
                    let errorMessage = 'Upload failed. Please try again.';
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        const errorText = await response.text();
                        if (errorText) {
                            errorMessage = errorText.substring(0, 100);
                        }
                    }
                    
                    // Show error in modal
                    const uploadFeedback = document.getElementById('uploadFeedback');
                    if (uploadFeedback) {
                        uploadFeedback.className = 'feedback-message error';
                        uploadFeedback.innerHTML = '<i class="bi bi-exclamation-triangle-fill me-2"></i>' + errorMessage;
                        uploadFeedback.style.display = 'flex';
                    }
                    
                    // Show error on main page
                    const feedback = document.getElementById('addItemFeedback');
                    if (feedback) {
                        showFeedback(errorMessage, 'danger');
                    } else {
                        alert(errorMessage);
                    }
                    
                    // Reset button state on error
                    resetPhotoUploadButton();
                }
            } catch (err) {
                console.error('Photo upload error:', err);
                const errorMessage = err.message || 'Network error. Please check your connection and try again.';
                
                // Show error in modal
                const uploadFeedback = document.getElementById('uploadFeedback');
                if (uploadFeedback) {
                    uploadFeedback.className = 'feedback-message error';
                    uploadFeedback.innerHTML = '<i class="bi bi-exclamation-triangle-fill me-2"></i>' + errorMessage;
                    uploadFeedback.style.display = 'flex';
                }
                
                // Show error on main page
                const feedback = document.getElementById('addItemFeedback');
                if (feedback) {
                    showFeedback(errorMessage, 'danger');
                } else {
                    alert('Upload error: ' + errorMessage);
                }
            } finally {
                // Always reset button state, even on error
                uploadBtn.classList.remove('loading');
                resetPhotoUploadButton();
            }
        });
    }
    
    // Helper function to close photo modal
    function closePhotoModal() {
        if (!photoModal) return;
        
        // Try Bootstrap modal API first
        try {
            if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                const bootstrapModal = bootstrap.Modal.getInstance(photoModal);
                if (bootstrapModal) {
                    bootstrapModal.hide();
                    return;
                }
            }
        } catch (e) {
            console.log('Bootstrap modal API not available:', e);
        }
        
        // Fallback: Use close button
        const closeBtn = photoModal.querySelector('[data-bs-dismiss="modal"]');
        if (closeBtn) {
            closeBtn.click();
        } else {
            // Last resort: Manual close
            photoModal.classList.remove('show');
            photoModal.style.display = 'none';
            photoModal.setAttribute('aria-hidden', 'true');
            
            // Remove backdrop
            const backdrops = document.querySelectorAll('.modal-backdrop');
            backdrops.forEach(backdrop => backdrop.remove());
            document.body.classList.remove('modal-open');
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
        }
    }
    
    // Helper function to reset photo upload state
    function resetPhotoUploadState() {
        selectedFile = null;
        if (photoInput) photoInput.value = '';
        if (mobileCameraInput) mobileCameraInput.value = '';
        
        // Clear feedback message
        const uploadFeedback = document.getElementById('uploadFeedback');
        if (uploadFeedback) {
            uploadFeedback.style.display = 'none';
            uploadFeedback.className = 'feedback-message';
            uploadFeedback.innerHTML = '';
        }
        
        // Reset display states with smooth transitions
        if (cameraView) {
            cameraView.style.opacity = '0';
            setTimeout(() => {
                cameraView.style.display = 'none';
                cameraView.style.opacity = '1';
            }, 150);
        }
        if (previewSection) {
            previewSection.style.opacity = '0';
            setTimeout(() => {
                previewSection.style.display = 'none';
                previewSection.style.opacity = '1';
            }, 150);
        }
        if (uploadZone) {
            uploadZone.style.display = 'block';
            uploadZone.style.opacity = '0';
            setTimeout(() => {
                uploadZone.style.opacity = '1';
            }, 50);
        }
        
        // Reset drag over state
        if (dropZone) {
            dropZone.classList.remove('dragover');
        }
        
        // Clear image preview
        if (imagePreview) {
            imagePreview.src = '';
        }
        
        stopCamera();
        resetPhotoUploadButton();
    }
    
    // Helper function to reset upload button
    function resetPhotoUploadButton() {
        if (uploadBtn) {
            uploadBtn.disabled = false;
            uploadBtn.classList.remove('loading');
        }
        if (uploadBtnText) {
            uploadBtnText.textContent = 'Analyze & Add Items';
        }
    }

    // Reset modal when closed
    if (photoModal) {
        // Handle modal shown
        photoModal.addEventListener('show.bs.modal', () => {
            // Prevent body scroll when modal opens
            const scrollY = window.scrollY;
            document.body.style.overflow = 'hidden';
            document.body.style.position = 'fixed';
            document.body.style.top = `-${scrollY}px`;
            document.body.style.width = '100%';
            document.body.classList.add('modal-open');
            document.body.classList.add('modal-open-no-animations');
            
            // Ensure modal content and all children are clickable
            const modalContent = photoModal.querySelector('.modal-content');
            const modalDialog = photoModal.querySelector('.modal-dialog');
            if (modalContent) {
                modalContent.style.pointerEvents = 'auto';
                modalContent.style.zIndex = '10000';
                modalContent.style.position = 'relative';
                // Ensure all interactive elements are clickable
                const allElements = modalContent.querySelectorAll('*');
                allElements.forEach(el => {
                    el.style.pointerEvents = 'auto';
                    if (el.tagName === 'BUTTON' || el.tagName === 'INPUT' || el.tagName === 'A' || el.getAttribute('role') === 'button') {
                        el.style.cursor = 'pointer';
                    }
                });
            }
            if (modalDialog) {
                modalDialog.style.pointerEvents = 'auto';
                modalDialog.style.zIndex = '9999';
                modalDialog.style.position = 'relative';
            }
            
            // Force enable pointer events on modal
            photoModal.style.pointerEvents = 'auto';
            photoModal.style.zIndex = '9999';
        });
        
        // Also handle when modal is fully shown - focus trap
        photoModal.addEventListener('shown.bs.modal', () => {
            // Focus trap - focus first focusable element
            const firstFocusable = photoModal.querySelector('button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])');
            if (firstFocusable) {
                firstFocusable.focus();
            }
            
            // Double-check all elements are clickable
            const modalContent = photoModal.querySelector('.modal-content');
            const modalDialog = photoModal.querySelector('.modal-dialog');
            if (modalContent) {
                modalContent.style.pointerEvents = 'auto';
                modalContent.style.zIndex = '10000';
                modalContent.style.position = 'relative';
                const allButtons = modalContent.querySelectorAll('button, input, a, [role="button"], .btn, .btn-close, select');
                allButtons.forEach(btn => {
                    btn.style.pointerEvents = 'auto';
                    btn.style.cursor = btn.tagName === 'INPUT' || btn.tagName === 'SELECT' ? 'default' : 'pointer';
                    btn.style.zIndex = '10';
                    btn.style.position = 'relative';
                });
            }
            if (modalDialog) {
                modalDialog.style.pointerEvents = 'auto';
                modalDialog.style.zIndex = '9999';
                modalDialog.style.position = 'relative';
            }
            
            // Ensure backdrop is properly configured
            setTimeout(() => {
                const backdrop = document.querySelector('.modal-backdrop');
                if (backdrop) {
                    // Backdrop should be clickable to close modal, but not block modal content
                    backdrop.style.pointerEvents = 'auto';
                    backdrop.style.zIndex = '9998';
                    // Ensure backdrop clicks close the modal
                    backdrop.addEventListener('click', function(e) {
                        // Only close if clicking directly on backdrop, not if event bubbled from modal
                        if (e.target === backdrop) {
                            const bootstrapModal = bootstrap.Modal.getInstance(photoModal);
                            if (bootstrapModal) {
                                bootstrapModal.hide();
                            }
                        }
                    }, { once: true });
                }
            }, 50);
            
            // Ensure close button works
            const closeBtn = photoModal.querySelector('[data-bs-dismiss="modal"]');
            if (closeBtn) {
                closeBtn.style.pointerEvents = 'auto';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.zIndex = '10';
                closeBtn.style.position = 'relative';
            }
        });
        
        // Add escape key handler
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && photoModal.classList.contains('show')) {
                const bootstrapModal = bootstrap.Modal.getInstance(photoModal);
                if (bootstrapModal) {
                    bootstrapModal.hide();
                } else {
                    const closeBtn = photoModal.querySelector('[data-bs-dismiss="modal"]');
                    if (closeBtn) {
                        closeBtn.click();
                    }
                }
            }
        });
        
        // Handle modal hiding (before close animation)
        photoModal.addEventListener('hide.bs.modal', () => {
            // Start cleanup early
            stopCamera();
            
            // Remove animation-disabling class (if it exists)
            document.body.classList.remove('modal-open-no-animations');
        });
        
        // Handle modal fully closed (after animation) - restore body scroll
        photoModal.addEventListener('hidden.bs.modal', () => {
            resetPhotoUploadState();
            
            // Restore body scroll position
            const scrollY = document.body.style.top;
            document.body.style.position = '';
            document.body.style.top = '';
            document.body.style.width = '';
            if (scrollY) {
                window.scrollTo(0, parseInt(scrollY || '0') * -1);
            }
            
            // Comprehensive cleanup - remove all backdrops and restore body
            const cleanup = () => {
                // Remove all modal backdrops
                const backdrops = document.querySelectorAll('.modal-backdrop');
                backdrops.forEach(backdrop => {
                    backdrop.style.display = 'none';
                    backdrop.style.opacity = '0';
                    backdrop.style.visibility = 'hidden';
                    backdrop.style.pointerEvents = 'none';
                    backdrop.remove();
                });
                
                // Remove modal-open class from body
                document.body.classList.remove('modal-open');
                
                // Restore body styles completely
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
                document.body.style.pointerEvents = '';
                document.body.style.position = '';
                document.body.style.overflowX = '';
                document.body.style.overflowY = '';
                
                // Ensure modal is properly hidden
                if (photoModal) {
                    photoModal.classList.remove('show');
                    photoModal.style.display = 'none';
                    photoModal.setAttribute('aria-hidden', 'true');
                    photoModal.removeAttribute('aria-modal');
                }
                
                // Force remove any remaining backdrop elements
                const remainingBackdrops = document.querySelectorAll('.modal-backdrop');
                remainingBackdrops.forEach(backdrop => {
                    backdrop.style.display = 'none';
                    backdrop.style.pointerEvents = 'none';
                    backdrop.remove();
                });
                
                // Ensure no backdrop classes remain
                document.body.classList.remove('modal-open');
                
                // Force enable pointer events on body
                document.body.style.pointerEvents = 'auto';
            };
            
            // Cleanup immediately and also after delays to catch any delayed Bootstrap cleanup
            cleanup();
            setTimeout(cleanup, 50);
            setTimeout(cleanup, 100);
            setTimeout(cleanup, 200);
            setTimeout(cleanup, 500);
            setTimeout(cleanup, 1000);
        });
        
        // Focus trap - prevent tabbing outside modal
        photoModal.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && photoModal.classList.contains('show')) {
                const focusableElements = photoModal.querySelectorAll(
                    'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
                );
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];
                
                if (e.shiftKey) {
                    // Shift + Tab
                    if (document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    }
                } else {
                    // Tab
                    if (document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            }
        });
    }

    // Check camera availability on page load
    window.addEventListener('DOMContentLoaded', () => {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            // Disable live camera button (getUserMedia not available)
            openCameraBtn.disabled = true;
            openCameraBtn.innerHTML = '<i class="bi bi-camera-video-off me-2"></i>HTTPS Only';
            openCameraBtn.title = 'Live camera requires HTTPS or localhost. Use "Take Photo" button instead.';
            openCameraBtn.classList.add('opacity-50');
            
            // Make "Take Photo" button more prominent
            mobileCameraBtn.classList.remove('btn-success');
            mobileCameraBtn.classList.add('btn-success', 'pulse');
        }

        // Handle expiration days selector for recipe suggestions
        const recipeBtn = document.getElementById('recipeBtn');
        const expiringDaysSelect = document.getElementById('expiringDays');
        
        if (recipeBtn && expiringDaysSelect) {
            recipeBtn.addEventListener('click', (e) => {
                const expiringDays = expiringDaysSelect.value;
                if (expiringDays && expiringDays.trim() !== '') {
                    // If expiring days is selected, add it to the URL
                    e.preventDefault();
                    const baseUrl = recipeBtn.getAttribute('href') || '{{ url_for("suggest_recipe") }}';
                    window.location.href = `${baseUrl}?expiring_days=${expiringDays}`;
                }
                // If no expiring days selected, let the link work normally (don't prevent default)
            });
        }
    });
    
    // Function to update expiration badge colors and card backgrounds - can be called multiple times
    function updateExpirationBadges() {
        // Update badges
        const badges = document.querySelectorAll('[data-exp-date]');
        if (!badges || badges.length === 0) {
            return;  // No badges to update
        }
        
        badges.forEach(function(badge) {
            try {
                if (!badge || !badge.getAttribute) {
                    return;  // Invalid badge element
                }
                
                const expDateStr = badge.getAttribute('data-exp-date');
                if (!expDateStr || expDateStr.trim() === '' || expDateStr === '9999-12-31' || expDateStr === 'None' || expDateStr === 'null') {
                    badge.classList.remove('expiration-expired', 'expiration-soon', 'expiration-fresh');
                    badge.classList.add('expiration-none');
                    return;
                }
                
                // Parse date string - handle both YYYY-MM-DD and ISO datetime formats
                let expiration;
                const dateStr = expDateStr.trim();
                
                // Check if it's a simple date format (YYYY-MM-DD)
                if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                    // Parse YYYY-MM-DD format (most reliable)
                    const parts = dateStr.split('-').map(Number);
                    if (parts.length === 3 && parts[0] > 1900 && parts[0] < 2100 && parts[1] >= 1 && parts[1] <= 12 && parts[2] >= 1 && parts[2] <= 31) {
                        expiration = new Date(parts[0], parts[1] - 1, parts[2]);
                    } else {
                        throw new Error('Invalid date parts');
                    }
                } else if (dateStr.includes('T')) {
                    // ISO datetime format
                    expiration = new Date(dateStr);
                } else {
                    // Try parsing as date string
                    expiration = new Date(dateStr);
                }
                
                // Check if date is valid
                if (!expiration || isNaN(expiration.getTime())) {
                    console.warn('Invalid expiration date format:', dateStr);
                    badge.classList.remove('expiration-expired', 'expiration-soon', 'expiration-fresh');
                    badge.classList.add('expiration-none');
                    return;
                }
                
                // Calculate days difference
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                expiration.setHours(0, 0, 0, 0);
                const daysDiff = Math.floor((expiration - today) / (1000 * 60 * 60 * 24));
                
                // Remove all expiration classes first
                badge.classList.remove('expiration-expired', 'expiration-soon', 'expiration-fresh', 'expiration-none');
                
                // Apply appropriate class based on days until expiration
                let expirationClass = '';
                if (daysDiff < 0) {
                    // Expired (past date)
                    expirationClass = 'expiration-expired';
                    badge.classList.add('expiration-expired');
                } else if (daysDiff < 3) {
                    // Expiring very soon (0-2 days) - red/orange
                    expirationClass = 'expiration-soon';
                    badge.classList.add('expiration-soon');
                } else if (daysDiff < 7) {
                    // Expiring soon (3-6 days) - orange/yellow
                    expirationClass = 'expiration-soon';
                    badge.classList.add('expiration-soon');
                } else {
                    // Fresh (7+ days) - green
                    expirationClass = 'expiration-fresh';
                    badge.classList.add('expiration-fresh');
                }
                
                // Also update the parent card background
                const card = badge.closest('.pantry-item-card');
                if (card) {
                    card.classList.remove('expiration-expired-card', 'expiration-soon-card', 'expiration-fresh-card');
                    card.classList.add(expirationClass + '-card');
                }
            } catch (e) {
                // If there's any error parsing the date, use default styling
                console.error('Error parsing expiration date:', badge?.getAttribute('data-exp-date'), e);
                if (badge && badge.classList) {
                    badge.classList.remove('expiration-expired', 'expiration-soon', 'expiration-fresh');
                    badge.classList.add('expiration-none');
                }
            }
        });
    }
    
    // Set default expiration date to one week from now
    function setDefaultExpirationDate() {
        const expirationInput = document.getElementById('expirationInput');
        if (expirationInput && !expirationInput.value) {
            const today = new Date();
            const oneWeekLater = new Date(today);
            oneWeekLater.setDate(today.getDate() + 7);
            const year = oneWeekLater.getFullYear();
            const month = String(oneWeekLater.getMonth() + 1).padStart(2, '0');
            const day = String(oneWeekLater.getDate()).padStart(2, '0');
            expirationInput.value = `${year}-${month}-${day}`;
        }
    }
    
    // Update pantry item card backgrounds based on expiration dates
    function updatePantryCardBackgrounds() {
        const wrappers = document.querySelectorAll('.pantry-item-wrapper[data-expiration-date]');
        wrappers.forEach(function(wrapper) {
            try {
                const expDateStr = wrapper.getAttribute('data-expiration-date');
                if (!expDateStr || expDateStr.trim() === '' || expDateStr === '9999-12-31' || expDateStr === 'None' || expDateStr === 'null') {
                    return;
                }
                
                // Parse date string
                let expiration;
                const dateStr = expDateStr.trim();
                
                if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                    const parts = dateStr.split('-').map(Number);
                    if (parts.length === 3 && parts[0] > 1900 && parts[0] < 2100 && parts[1] >= 1 && parts[1] <= 12 && parts[2] >= 1 && parts[2] <= 31) {
                        expiration = new Date(parts[0], parts[1] - 1, parts[2]);
                    } else {
                        return;
                    }
                } else if (dateStr.includes('T')) {
                    expiration = new Date(dateStr);
                } else {
                    expiration = new Date(dateStr);
                }
                
                if (!expiration || isNaN(expiration.getTime())) {
                    return;
                }
                
                // Calculate days difference
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                expiration.setHours(0, 0, 0, 0);
                const daysDiff = Math.floor((expiration - today) / (1000 * 60 * 60 * 24));
                
                // Update card background
                const card = wrapper.querySelector('.pantry-item-card');
                if (card) {
                    card.classList.remove('expiration-expired-card', 'expiration-soon-card', 'expiration-fresh-card');
                    if (daysDiff < 0) {
                        card.classList.add('expiration-expired-card');
                    } else if (daysDiff < 7) {
                        card.classList.add('expiration-soon-card');
                    } else {
                        card.classList.add('expiration-fresh-card');
                    }
                }
            } catch (e) {
                // Silently ignore errors
            }
        });
    }
    
    // Sort pantry items
    // Enhanced category detection function with better accuracy
    function getItemCategory(itemName) {
        const name = itemName.toLowerCase().trim();
        
        // More specific matching - check exact matches first, then partial
        // Proteins (meat, poultry, seafood, eggs)
        const proteins = {
            exact: ['chicken', 'beef', 'pork', 'fish', 'salmon', 'tuna', 'turkey', 'egg', 'eggs', 'tofu', 'meat', 'steak', 'bacon', 'sausage', 'ham', 'shrimp', 'prawn', 'crab', 'lobster', 'lamb', 'duck', 'pork', 'veal', 'venison', 'bison', 'chicken breast', 'chicken thigh', 'ground beef', 'ground turkey', 'ribeye', 'sirloin', 'tilapia', 'cod', 'halibut', 'mackerel', 'sardine', 'anchovy'],
            partial: ['chicken', 'beef', 'pork', 'fish', 'salmon', 'tuna', 'turkey', 'egg', 'eggs', 'tofu', 'meat', 'protein', 'steak', 'bacon', 'sausage', 'ham', 'shrimp', 'prawn', 'crab', 'lobster', 'lamb', 'duck', 'seafood', 'poultry']
        };
        if (proteins.exact.includes(name) || proteins.partial.some(p => name.includes(p))) return 'proteins';
        
        // Vegetables (more comprehensive list)
        const vegetables = {
            exact: ['broccoli', 'carrot', 'tomato', 'onion', 'garlic', 'lettuce', 'spinach', 'cucumber', 'pepper', 'potato', 'celery', 'corn', 'peas', 'bean', 'cabbage', 'cauliflower', 'zucchini', 'eggplant', 'asparagus', 'mushroom', 'kale', 'arugula', 'beet', 'bell pepper', 'brussels sprout', 'cabbage', 'carrot', 'celery', 'corn', 'cucumber', 'eggplant', 'green bean', 'leek', 'lettuce', 'onion', 'pepper', 'potato', 'radish', 'spinach', 'squash', 'tomato', 'zucchini'],
            partial: ['broccoli', 'carrot', 'tomato', 'onion', 'garlic', 'lettuce', 'spinach', 'cucumber', 'pepper', 'potato', 'celery', 'corn', 'peas', 'bean', 'vegetable', 'cabbage', 'cauliflower', 'zucchini', 'eggplant', 'asparagus', 'mushroom', 'kale', 'lettuce', 'greens', 'sprout']
        };
        if (vegetables.exact.includes(name) || vegetables.partial.some(v => name.includes(v))) return 'vegetables';
        
        // Dairy (milk products, cheese, yogurt)
        const dairy = {
            exact: ['milk', 'cheese', 'yogurt', 'butter', 'cream', 'sour cream', 'cottage cheese', 'mozzarella', 'cheddar', 'parmesan', 'feta', 'swiss', 'gouda', 'brie', 'ricotta', 'cream cheese', 'heavy cream', 'half and half', 'buttermilk', 'greek yogurt', 'yogurt'],
            partial: ['milk', 'cheese', 'yogurt', 'butter', 'cream', 'dairy', 'sour cream', 'cottage cheese', 'mozzarella', 'cheddar', 'parmesan', 'feta', 'dairy']
        };
        if (dairy.exact.includes(name) || dairy.partial.some(d => name.includes(d))) return 'dairy';
        
        // Fruits (fresh and dried)
        const fruits = {
            exact: ['apple', 'banana', 'orange', 'berry', 'strawberry', 'blueberry', 'grape', 'mango', 'pineapple', 'peach', 'pear', 'cherry', 'kiwi', 'lemon', 'lime', 'avocado', 'watermelon', 'cantaloupe', 'honeydew', 'plum', 'apricot', 'nectarine', 'grapefruit', 'tangerine', 'coconut', 'papaya', 'dragon fruit', 'passion fruit'],
            partial: ['apple', 'banana', 'orange', 'berry', 'strawberry', 'blueberry', 'grape', 'mango', 'pineapple', 'peach', 'pear', 'cherry', 'kiwi', 'lemon', 'lime', 'fruit', 'avocado']
        };
        if (fruits.exact.includes(name) || fruits.partial.some(f => name.includes(f))) return 'fruits';
        
        // Snacks (chips, crackers, sweets)
        const snacks = {
            exact: ['chip', 'cracker', 'cookie', 'biscuit', 'pretzel', 'popcorn', 'nuts', 'almond', 'peanut', 'cashew', 'trail mix', 'granola', 'bar', 'candy', 'chocolate', 'chips', 'crackers', 'cookies', 'pretzels', 'popcorn', 'almonds', 'peanuts', 'cashews', 'walnuts', 'pecans', 'pistachios'],
            partial: ['chip', 'cracker', 'cookie', 'biscuit', 'pretzel', 'popcorn', 'nuts', 'almond', 'peanut', 'cashew', 'trail mix', 'granola', 'bar', 'candy', 'chocolate', 'snack']
        };
        if (snacks.exact.includes(name) || snacks.partial.some(s => name.includes(s))) return 'snacks';
        
        // Grains (bread, rice, pasta, cereals)
        const grains = {
            exact: ['bread', 'rice', 'pasta', 'noodle', 'flour', 'wheat', 'oats', 'quinoa', 'barley', 'cereal', 'bagel', 'muffin', 'roll', 'bun', 'tortilla', 'wrap', 'pita', 'naan', 'white rice', 'brown rice', 'wild rice', 'spaghetti', 'penne', 'macaroni', 'fettuccine', 'linguine'],
            partial: ['bread', 'rice', 'pasta', 'noodle', 'flour', 'wheat', 'oats', 'quinoa', 'barley', 'cereal', 'grain']
        };
        if (grains.exact.includes(name) || grains.partial.some(g => name.includes(g))) return 'grains';
        
        // Beverages (drinks, juices, coffee, tea)
        const beverages = {
            exact: ['juice', 'soda', 'water', 'coffee', 'tea', 'beer', 'wine', 'drink', 'beverage', 'orange juice', 'apple juice', 'cranberry juice', 'lemonade', 'iced tea', 'green tea', 'black tea', 'herbal tea', 'espresso', 'latte', 'cappuccino', 'smoothie', 'shake'],
            partial: ['juice', 'soda', 'water', 'coffee', 'tea', 'beer', 'wine', 'drink', 'beverage']
        };
        if (beverages.exact.includes(name) || beverages.partial.some(b => name.includes(b))) return 'beverages';
        
        // Default
        return 'other';
    }
    
    // Get category display name and icon
    function getCategoryDisplay(category) {
        const categoryInfo = {
            'proteins': { name: 'Proteins', icon: 'bi-droplet-fill', color: '#EF4444' },
            'vegetables': { name: 'Vegetables', icon: 'bi-flower1', color: '#10B981' },
            'fruits': { name: 'Fruits', icon: 'bi-apple', color: '#F59E0B' },
            'dairy': { name: 'Dairy', icon: 'bi-cup-straw', color: '#3B82F6' },
            'grains': { name: 'Grains', icon: 'bi-wheat', color: '#8B5CF6' },
            'snacks': { name: 'Snacks', icon: 'bi-bag', color: '#EC4899' },
            'beverages': { name: 'Beverages', icon: 'bi-cup', color: '#06B6D4' },
            'other': { name: 'Other', icon: 'bi-box', color: '#64748B' }
        };
        return categoryInfo[category] || categoryInfo['other'];
    }
    
    // Category order for sorting
    const categoryOrder = {
        'proteins': 1,
        'vegetables': 2,
        'fruits': 3,
        'dairy': 4,
        'grains': 5,
        'snacks': 6,
        'beverages': 7,
        'other': 8
    };
    
    // Store current sort type to re-apply after reload
    let currentSortType = null;
    let currentSearchTerm = '';
    
    // Search functionality with case-insensitive filtering and debouncing
    let searchTimeout = null;
    const searchInput = document.getElementById('searchItemsInput');
    if (searchInput) {
        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.trim().toLowerCase();
            currentSearchTerm = searchTerm;
            
            // Debounce search to avoid excessive filtering
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filterPantryItems(searchTerm);
            }, 300); // 300ms delay
        });
        
        // Clear search on Escape key
        searchInput.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                e.target.value = '';
                currentSearchTerm = '';
                filterPantryItems('');
            }
        });
    }
    
    // Filter pantry items by search term (case-insensitive)
    function filterPantryItems(searchTerm) {
        const container = document.getElementById('pantryItemsContainer');
        if (!container) return;
        
        const items = container.querySelectorAll('.pantry-item-wrapper');
        let visibleCount = 0;
        
        items.forEach(item => {
            const itemName = item.getAttribute('data-item-name') || '';
            const itemNameLower = itemName.toLowerCase();
            
            // Case-insensitive search
            if (!searchTerm || itemNameLower.includes(searchTerm.toLowerCase())) {
                item.style.display = '';
                visibleCount++;
            } else {
                item.style.display = 'none';
            }
        });
        
        // Show/hide "no results" message
        let noResultsMsg = document.getElementById('noSearchResults');
        if (!noResultsMsg && searchTerm && visibleCount === 0) {
            noResultsMsg = document.createElement('div');
            noResultsMsg.id = 'noSearchResults';
            noResultsMsg.className = 'col-12 text-center py-5';
            noResultsMsg.innerHTML = `
                <i class="bi bi-search display-4 text-muted mb-3"></i>
                <h5 class="text-muted">No matching items</h5>
                <p class="text-muted small">Try a different search term</p>
            `;
            container.appendChild(noResultsMsg);
        } else if (noResultsMsg && (!searchTerm || visibleCount > 0)) {
            noResultsMsg.remove();
        }
    }
    
    function sortPantry(sortType) {
        const container = document.getElementById('pantryItemsContainer');
        if (!container) {
            console.warn('Pantry container not found');
            return;
        }
        
        // Get only visible items (respecting search filter)
        const items = Array.from(container.querySelectorAll('.pantry-item-wrapper:not([style*="display: none"])'));
        
        if (items.length === 0) {
            console.warn('No items to sort');
            return;
        }
        
        // Store sort type for re-application after reload
        currentSortType = sortType;
        sessionStorage.setItem('pantrySortType', sortType);
        
        items.sort((a, b) => {
            if (sortType === 'category') {
                const nameA = a.getAttribute('data-item-name') || '';
                const nameB = b.getAttribute('data-item-name') || '';
                const catA = getItemCategory(nameA);
                const catB = getItemCategory(nameB);
                
                // Sort by category first
                if (catA !== catB) {
                    return (categoryOrder[catA] || 99) - (categoryOrder[catB] || 99);
                }
                // Then by name within category
                return nameA.localeCompare(nameB);
            } else if (sortType === 'name') {
                const nameA = a.getAttribute('data-item-name') || '';
                const nameB = b.getAttribute('data-item-name') || '';
                return nameA.localeCompare(nameB);
            } else if (sortType === 'name-desc') {
                const nameA = a.getAttribute('data-item-name') || '';
                const nameB = b.getAttribute('data-item-name') || '';
                return nameB.localeCompare(nameA);
            } else if (sortType === 'expiration') {
                const dateA = a.getAttribute('data-expiration-date') || '9999-12-31';
                const dateB = b.getAttribute('data-expiration-date') || '9999-12-31';
                return dateA.localeCompare(dateB);
            } else if (sortType === 'expiration-desc') {
                const dateA = a.getAttribute('data-expiration-date') || '9999-12-31';
                const dateB = b.getAttribute('data-expiration-date') || '9999-12-31';
                return dateB.localeCompare(dateA);
            }
            return 0;
        });
        
        // Clear container and re-append sorted items with category grouping
        container.innerHTML = '';
        
        if (sortType === 'category') {
            // Group items by category for better visual organization
            const categoryGroups = {};
            items.forEach(item => {
                const name = item.getAttribute('data-item-name') || '';
                const category = getItemCategory(name);
                if (!categoryGroups[category]) {
                    categoryGroups[category] = [];
                }
                categoryGroups[category].push(item);
            });
            
            // Add category headers and items
            const categoryKeys = Object.keys(categoryGroups).sort((a, b) => {
                return (categoryOrder[a] || 99) - (categoryOrder[b] || 99);
            });
            
            // Only show category headers if we have multiple categories or multiple items
            const totalItems = items.length;
            const showCategoryHeaders = categoryKeys.length > 1 || totalItems > 3;
            
            categoryKeys.forEach((category, categoryIndex) => {
                const categoryInfo = getCategoryDisplay(category);
                const groupItems = categoryGroups[category];
                
                // Add category header only if we should show them
                if (showCategoryHeaders) {
                    const categoryHeader = document.createElement('div');
                    categoryHeader.className = 'col-12';
                    // First category header shouldn't have top margin
                    const marginTop = categoryIndex === 0 ? '0' : '24px';
                    categoryHeader.style.cssText = `margin-top: ${marginTop}; margin-bottom: 12px; padding: 12px 16px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.08) 0%, rgba(59, 130, 246, 0.05) 100%); border-radius: 12px; border-left: 4px solid ${categoryInfo.color}; width: 100%;`;
                    categoryHeader.innerHTML = `
                        <div class="d-flex align-items-center gap-2">
                            <i class="bi ${categoryInfo.icon}" style="color: ${categoryInfo.color}; font-size: 1.1rem;"></i>
                            <h6 class="mb-0 fw-bold" style="color: #1e293b; font-size: 0.95rem;">${categoryInfo.name}</h6>
                            <span class="badge" style="background: ${categoryInfo.color}; color: white; font-size: 0.75rem; padding: 4px 8px; border-radius: 6px;">${groupItems.length} ${groupItems.length === 1 ? 'item' : 'items'}</span>
                        </div>
                    `;
                    container.appendChild(categoryHeader);
                }
                
                // Add items in this category
                groupItems.forEach((item, index) => {
                    const card = item.querySelector('.pantry-item-card');
                    if (card) {
                        card.style.animationDelay = (index * 0.05) + 's';
                    }
                    // Ensure item maintains proper column class structure
                    if (!item.classList.contains('col-md-6') && !item.classList.contains('col-lg-4')) {
                        item.classList.add('col-md-6', 'col-lg-4');
                    }
                    container.appendChild(item);
                });
            });
            
            // Show category info only if headers are shown
            const categoryInfo = document.getElementById('categoryGroupInfo');
            if (categoryInfo) {
                categoryInfo.style.display = showCategoryHeaders ? 'block' : 'none';
            }
        } else {
            // Regular sorting without category grouping
        items.forEach((item, index) => {
            const card = item.querySelector('.pantry-item-card');
            if (card) {
                card.style.animationDelay = (index * 0.05) + 's';
            }
            container.appendChild(item);
        });
            
            // Hide category info
            const categoryInfo = document.getElementById('categoryGroupInfo');
            if (categoryInfo) {
                categoryInfo.style.display = 'none';
            }
        }
        
        // Ensure container is visible
        container.style.display = '';
        
        // Hide empty state if it exists
        const emptyState = container.closest('.card-body')?.querySelector('.empty-state');
        if (emptyState) {
            emptyState.style.display = 'none';
        }
        
        // Re-initialize interactive elements after sorting
        initializeDeleteButtons();
        initializeQuantityEditing();
        initializeExpirationEditing();
        
        // Update expiration badges and card backgrounds after sorting
        setTimeout(() => {
            updateExpirationBadges();
            updatePantryCardBackgrounds();
        }, 100);
        
        // Show feedback for category sort
        if (sortType === 'category') {
            const feedback = document.getElementById('addItemFeedback');
            if (feedback) {
                showFeedback('Items grouped by category', 'success');
            }
        }
    }
    
    // Update sort label
    function updateSortLabel(label) {
        const labelElement = document.getElementById('currentSortLabel');
        if (labelElement) {
            labelElement.textContent = label;
        }
    }
    
    // Get label for sort type
    function getSortLabel(sortType) {
        const labels = {
            'category': 'Category',
            'name': 'Name (A-Z)',
            'name-desc': 'Name (Z-A)',
            'expiration': 'Expiration (Soonest)',
            'expiration-desc': 'Expiration (Latest)'
        };
        return labels[sortType] || 'Category';
    }
    
    // Run expiration badge updates on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            setDefaultExpirationDate();
            updateExpirationBadges();
            updatePantryCardBackgrounds();
            // Also run after a short delay to ensure all elements are rendered
            setTimeout(() => {
                updateExpirationBadges();
                updatePantryCardBackgrounds();
            }, 200);
        });
    } else {
        // DOM already loaded
        setDefaultExpirationDate();
        updateExpirationBadges();
        updatePantryCardBackgrounds();
        setTimeout(() => {
            updateExpirationBadges();
            updatePantryCardBackgrounds();
        }, 200);
    }
    
    // Handle add item form submission
    // Track if form is currently submitting to prevent race conditions
    let isSubmitting = false;
    
    function handleAddItem(event) {
        // Always prevent default form submission
        if (event) {
            event.preventDefault();
        }
        
        // Prevent race conditions - check if already submitting
        if (isSubmitting) {
            console.log('Form submission already in progress, ignoring duplicate request');
            return false;
        }
        
        const form = document.getElementById('addItemForm');
        if (!form) {
            console.error('Form not found');
            return false;
        }
        
        const formData = new FormData(form);
        const itemName = formData.get('item');
        const expirationDateInput = document.getElementById('expirationInput');
        const btn = document.getElementById('addItemBtn');
        const btnText = document.getElementById('addItemBtnText');
        const feedback = document.getElementById('addItemFeedback');
        const itemInput = document.getElementById('itemInput');
        const quantityInput = document.getElementById('quantityInput');
        
        // Validate quantity input
        if (quantityInput) {
            const quantityValue = quantityInput.value.trim() || '1';
            const quantityNum = parseInt(quantityValue, 10);
            if (isNaN(quantityNum) || quantityNum < 0) {
                if (feedback) {
                    showFeedback('Quantity must be a positive number', 'danger');
                }
                if (quantityInput) {
                    quantityInput.focus();
                    quantityInput.select();
                }
                return false;
            }
            formData.set('quantity', Math.max(0, quantityNum).toString());
        }
        
        // Ensure expiration_date is included in FormData (even if empty)
        if (expirationDateInput) {
            const expirationDateValue = expirationDateInput.value || '';
            formData.set('expiration_date', expirationDateValue);
        }
        
        // Validate input
        if (!itemName || !itemName.trim()) {
            if (feedback) {
                showFeedback('Please enter an item name', 'danger');
            }
            if (itemInput) {
                itemInput.focus();
            }
            return false;
        }
        
        // Set submitting flag and disable button
        isSubmitting = true;
        if (btn) {
            btn.disabled = true;
        }
        if (btnText) {
            btnText.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Adding...';
        }
        
        // Submit form using fetch
        fetch('/add', {
            method: 'POST',
            body: formData,
            credentials: 'same-origin', // Include cookies for session
            headers: {
                'X-Requested-With': 'XMLHttpRequest' // Identify as AJAX request
            }
        })
        .then(async response => {
            // Check if response is JSON (success) or HTML (redirect/error)
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                // JSON response (AJAX mode)
                return response.json().then(async data => {
                    if (data.success) {
                        // Success - show feedback and reload
                        if (feedback) {
                            showFeedback(data.message || 'Item added successfully!', 'success');
                        }
                        // Clear form
                        if (form) {
                            form.reset();
                            if (quantityInput) quantityInput.value = '1';
                            if (expirationDateInput) expirationDateInput.value = '';
                        }
                        // Reset button state immediately
                        resetButton();
                        // Update pantry items without reloading page
                        // Add small delay to ensure server has finished saving
                        setTimeout(async () => {
                            await reloadPantryItems();
                        }, 300);
                    } else {
                        // Error from server
                        if (feedback) {
                            showFeedback(data.error || 'Failed to add item. Please try again.', 'danger');
                        }
                        resetButton();
                    }
                });
            } else {
                // HTML response (redirect) - Flask redirects return 302, then 200
                if (response.ok || response.status === 200 || response.status === 302) {
                    // Success - show feedback and reload
                    if (feedback) {
                        showFeedback('Item added successfully!', 'success');
                    }
                    // Clear form
                    if (form) {
                        form.reset();
                        if (quantityInput) quantityInput.value = '1';
                        if (expirationDateInput) expirationDateInput.value = '';
                    }
                    // Reset button state
                    resetButton();
                    // Update pantry items without reloading page
                    // Add small delay to ensure server has finished saving
                    setTimeout(async () => {
                        await reloadPantryItems();
                    }, 300);
                } else {
                    // Error response
                    return response.text().then(text => {
                        console.error('Server error:', text);
                        if (feedback) {
                            showFeedback('Failed to add item. Please try again.', 'danger');
                        }
                        resetButton();
                    });
                }
            }
        })
        .catch(error => {
            console.error('Error adding item:', error);
            if (feedback) {
                showFeedback('Failed to add item: ' + error.message, 'danger');
            }
            resetButton();
        });
        
        function resetButton() {
            isSubmitting = false; // Reset submitting flag
            if (btn) {
                btn.disabled = false;
            }
            if (btnText) {
                btnText.innerHTML = '<i class="bi bi-plus-circle-fill me-2"></i>Add to Pantry';
            }
        }
        
        return false; // Prevent default form submission
    }
    
    function showFeedback(message, type) {
        const feedback = document.getElementById('addItemFeedback');
        if (!feedback) return;
        
        feedback.className = `alert alert-${type} alert-dismissible fade show mt-3`;
        feedback.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
        feedback.style.display = 'block';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            if (feedback) {
                feedback.style.display = 'none';
            }
        }, 5000);
    }
    
    // Reload pantry items without refreshing the page
    async function reloadPantryItems() {
        // Store scroll position before reload
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
        
        try {
            // Add cache busting to ensure we get fresh data
            const url = window.location.pathname + '?t=' + Date.now();
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                },
                cache: 'no-cache'  // Prevent browser caching
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const html = await response.text();
            if (!html || html.trim().length === 0) {
                throw new Error('Empty response from server');
            }
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Check for parsing errors
            const parserError = doc.querySelector('parsererror');
            if (parserError) {
                throw new Error('Failed to parse HTML response');
            }
            
            // Extract pantry items container and related elements
            // Find the pantry card by locating the container first, then finding its parent card
            const newContainer = doc.querySelector('#pantryItemsContainer');
            if (!newContainer) {
                console.error('Pantry items container not found in response, attempting full page reload');
                // Fallback: reload the entire page if container is missing from response
                window.location.reload();
                return;
            }
            
            // Find the parent card by traversing up the DOM tree
            let pantryCard = newContainer.closest('.card');
            if (!pantryCard) {
                // Fallback: try to find card containing "Your Pantry" text
                const allCards = doc.querySelectorAll('.card');
                pantryCard = Array.from(allCards).find(card => {
                    const header = card.querySelector('.card-header');
                    return header && header.textContent.includes('Your Pantry');
                }) || null;
            }
            
            const newCardBody = pantryCard ? pantryCard.querySelector('.card-body') : newContainer.parentElement;
            // Select the badge specifically from the pantry card header, not any badge on the page
            const pantryCardHeader = pantryCard ? pantryCard.querySelector('.card-header') : null;
            const newBadge = pantryCardHeader ? pantryCardHeader.querySelector('.badge') : null;
            const newEmptyState = (pantryCard || newCardBody) ? (pantryCard || newCardBody).querySelector('.empty-state') : doc.querySelector('.empty-state');
            const newSortDropdown = doc.querySelector('#sortDropdown')?.parentElement;
            
            // Find current elements - use the same reliable method
            const currentContainer = document.getElementById('pantryItemsContainer');
            if (!currentContainer) {
                console.warn('Current pantry items container not found, attempting full page reload');
                // Fallback: reload the entire page if container is missing
                window.location.reload();
                return;
            }
            
            // Find the current pantry card by traversing up from the container
            let currentPantryCard = currentContainer.closest('.card');
            if (!currentPantryCard) {
                // Fallback: try to find card containing "Your Pantry" text
                const allCards = document.querySelectorAll('.card');
                currentPantryCard = Array.from(allCards).find(card => {
                    const header = card.querySelector('.card-header');
                    return header && header.textContent.includes('Your Pantry');
                }) || null;
            }
            
            const currentCardBody = currentPantryCard ? currentPantryCard.querySelector('.card-body') : currentContainer.parentElement;
            const currentCardHeader = currentPantryCard ? currentPantryCard.querySelector('.card-header') : null;
            
            // Check if we have items or empty state
            // Always update if we have both containers
            if (newContainer && currentContainer) {
                // Update items container content
                currentContainer.innerHTML = newContainer.innerHTML;
                currentContainer.style.display = '';
                
                // Check if we have items or empty state
                if (newContainer.children.length > 0) {
                    // Items exist - hide empty state if it exists
                const emptyState = currentCardBody?.querySelector('.empty-state');
                if (emptyState) {
                    emptyState.style.display = 'none';
                }
                
                // Update item count badge - select specifically from pantry card header
                if (newBadge && currentCardHeader) {
                    const headerDiv = currentCardHeader.querySelector('.d-flex');
                    if (headerDiv) {
                        // Find existing badge in header
                        const currentBadge = headerDiv.querySelector('.badge');
                        if (currentBadge) {
                            currentBadge.outerHTML = newBadge.outerHTML;
                        } else {
                            // Insert badge if it doesn't exist
                            const dropdown = headerDiv.querySelector('.dropdown');
                            if (dropdown) {
                                headerDiv.insertBefore(newBadge.cloneNode(true), dropdown);
                            } else {
                                headerDiv.appendChild(newBadge.cloneNode(true));
                            }
                        }
                    }
                }
                
                // Update pantry stats card with actual item count (use current container after update)
                const itemCount = currentContainer.querySelectorAll('.pantry-item-wrapper').length;
                const statsCountElement = document.getElementById('pantryStatsCount');
                if (statsCountElement) {
                    statsCountElement.textContent = itemCount;
                }
                
                // Show/hide sort controls section based on item count
                const sortControlsSection = currentCardBody ? currentCardBody.querySelector('.d-flex.justify-content-between.align-items-center.mb-3.pb-3') : null;
                if (sortControlsSection) {
                    // Check if sort controls section exists (it's the one with border-bottom)
                    const hasMultipleItems = newContainer.children.length > 1;
                    sortControlsSection.style.display = hasMultipleItems ? 'flex' : 'none';
                }
                
                // Also update sort dropdown visibility (now in card body, not header)
                const currentSortDropdown = currentCardBody ? currentCardBody.querySelector('#sortDropdown') : document.querySelector('#sortDropdown');
                if (currentSortDropdown) {
                    currentSortDropdown.style.display = newContainer.children.length > 1 ? '' : 'none';
                }
                
                // Re-initialize delete buttons
                initializeDeleteButtons();
                
                    // Re-initialize quantity editing
                    initializeQuantityEditing();
                    
                    // Re-initialize expiration date editing
                    initializeExpirationEditing();
                
                // Re-apply sort if one was active
                const savedSortType = sessionStorage.getItem('pantrySortType');
                if (savedSortType && currentSortType === null) {
                    currentSortType = savedSortType;
                }
                if (currentSortType) {
                    // Update sort label
                    updateSortLabel(getSortLabel(currentSortType));
                    setTimeout(() => {
                        sortPantry(currentSortType);
                    }, 100);
                }
                
                // Re-apply search filter if one was active
                const searchInput = document.getElementById('searchItemsInput');
                if (currentSearchTerm && searchInput) {
                    searchInput.value = currentSearchTerm;
                    setTimeout(() => {
                        filterPantryItems(currentSearchTerm);
                    }, 150);
                }
                
                // Update expiration badges
                setTimeout(() => {
                    updateExpirationBadges();
                    updatePantryCardBackgrounds();
                }, 100);
                } else {
                    // No items - ensure empty state is visible
                    // The empty state should already be in the container.innerHTML we just set
                    // But let's make sure it's displayed
                    const emptyState = currentCardBody?.querySelector('.empty-state');
                    if (emptyState) {
                        emptyState.style.display = '';
                    }
                    
                    // Update pantry stats card to show 0 items
                    const statsCountElement = document.getElementById('pantryStatsCount');
                    if (statsCountElement) {
                        statsCountElement.textContent = '0';
                    }
                    
                    // Hide sort controls section
                    const sortControlsSection = currentCardBody ? currentCardBody.querySelector('.d-flex.justify-content-between.align-items-center.mb-3.pb-3') : null;
                    if (sortControlsSection) {
                        sortControlsSection.style.display = 'none';
                    }
                    
                    // Hide sort dropdown
                    const sortDropdown = currentCardBody ? currentCardBody.querySelector('#sortDropdown') : document.querySelector('#sortDropdown');
                    if (sortDropdown) {
                        sortDropdown.style.display = 'none';
                    }
                    
                    // Hide badge
                    if (currentCardHeader) {
                        const headerDiv = currentCardHeader.querySelector('.d-flex');
                        if (headerDiv) {
                            const badge = headerDiv.querySelector('.badge');
                            if (badge) {
                                badge.style.display = 'none';
                            }
                        }
                    }
                    
                    // Clear sort type when empty
                    currentSortType = null;
                    sessionStorage.removeItem('pantrySortType');
                }
            } else if (newEmptyState && currentCardBody) {
                // If no items, show empty state
                currentCardBody.innerHTML = newCardBody.innerHTML;
                
                // Hide container if it exists
                if (currentContainer) {
                    currentContainer.style.display = 'none';
                }
                
                // Hide sort controls section if it exists
                const sortControlsSection = currentCardBody ? currentCardBody.querySelector('.d-flex.justify-content-between.align-items-center.mb-3.pb-3') : null;
                if (sortControlsSection) {
                    sortControlsSection.style.display = 'none';
                }
                
                // Hide sort dropdown if it exists
                const sortDropdown = currentCardBody ? currentCardBody.querySelector('#sortDropdown') : document.querySelector('#sortDropdown');
                if (sortDropdown) {
                    sortDropdown.style.display = 'none';
                }
                
                // Hide badge if it exists - select specifically from pantry card header
                if (currentCardHeader) {
                    const headerDiv = currentCardHeader.querySelector('.d-flex');
                    if (headerDiv) {
                        const badge = headerDiv.querySelector('.badge');
                        if (badge) {
                            badge.style.display = 'none';
                        }
                    }
                }
                
                // Clear sort type when empty
                currentSortType = null;
                sessionStorage.removeItem('pantrySortType');
            } else if (currentContainer && newContainer) {
                // Fallback: just update the container
                currentContainer.innerHTML = newContainer.innerHTML;
                initializeDeleteButtons();
                initializeQuantityEditing();
                initializeExpirationEditing();
                
                // Re-apply sort if one was active
                const savedSortType = sessionStorage.getItem('pantrySortType');
                if (savedSortType && currentSortType === null) {
                    currentSortType = savedSortType;
                }
                if (currentSortType) {
                    setTimeout(() => {
                        sortPantry(currentSortType);
                    }, 100);
                }
                
                setTimeout(() => {
                    updateExpirationBadges();
                    updatePantryCardBackgrounds();
                }, 100);
            }
            
            // Restore scroll position
            window.scrollTo(0, scrollPosition);
            
        } catch (error) {
            console.error('Error reloading pantry items:', error);
            // Don't reload page - just show error message
            const feedback = document.getElementById('addItemFeedback');
            if (feedback) {
                showFeedback('Failed to reload items. Please refresh the page.', 'warning');
            }
        }
    }
    
    // Handle delete item via AJAX
    async function handleDeleteItem(itemName) {
        if (!itemName) {
            console.error('Item name is required for deletion');
            return;
        }
        
        // Store scroll position before deletion
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
        
        // Decode and sanitize item name
        const decodedName = decodeURIComponent(itemName);
        if (!confirm(`Remove "${decodedName}" from pantry?`)) {
            return;
        }
        
        try {
            // Properly encode the item name for URL
            const encodedName = encodeURIComponent(itemName);
            const response = await fetch(`/delete/${encodedName}`, {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                },
                cache: 'no-cache'  // Prevent caching
            });
            
            if (response.ok) {
                // Add small delay to ensure server has finished processing
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Reload items (this will restore scroll position internally)
                await reloadPantryItems();
                
                // Restore scroll position after reload
                setTimeout(() => {
                    window.scrollTo(0, scrollPosition);
                }, 100);
                
                // Show success feedback
                const feedback = document.getElementById('addItemFeedback');
                if (feedback) {
                    showFeedback('Item removed successfully!', 'success');
                }
            } else {
                const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                throw new Error(errorData.error || 'Failed to delete item');
            }
        } catch (error) {
            console.error('Error deleting item:', error);
            const feedback = document.getElementById('addItemFeedback');
            if (feedback) {
                showFeedback('Failed to delete item: ' + error.message, 'danger');
            } else {
                alert('Failed to delete item: ' + error.message);
            }
        }
    }
    
    // Initialize delete buttons
    function initializeDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.delete-item-btn');
        deleteButtons.forEach(btn => {
            // Remove existing listeners
            if (!btn.parentNode) return; // Skip if button is not in DOM
            
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            // Add new listener
            newBtn.addEventListener('click', function() {
                const itemName = this.getAttribute('data-item-name');
                if (!itemName || !itemName.trim()) {
                    console.error('Item name is missing for delete');
                    return;
                }
                handleDeleteItem(itemName);
            });
        });
    }
    
    // Handle item update via API (for both quantity and expiration date)
    async function handleUpdateItem(itemId, itemName, quantity, expirationDate, addedDate, updateType = 'item') {
        // Allow empty itemId - backend will fallback to name matching
        if (!itemName || !itemName.trim()) {
            console.error('Item name is required for update');
            showFeedback('Error: Item name missing', 'danger');
            return;
        }
        
        try {
            // Prepare update data
            const updateData = {
                name: itemName,
                quantity: quantity || '1',
                expirationDate: expirationDate || null,
                addedDate: addedDate || new Date().toISOString()
            };
            
            // Get user ID and client type from headers (if available)
            // For web requests, we rely on session cookies, but set X-Client-Type for clarity
            const headers = {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
                'X-Client-Type': 'web'  // Explicitly identify as web client
            };
            
            // Encode item ID for URL (use 'unknown' if empty to avoid invalid URL)
            const encodedItemId = itemId && itemId.trim() ? encodeURIComponent(itemId) : 'unknown';
            
            const response = await fetch(`/api/pantry/${encodedItemId}`, {
                method: 'PUT',
                headers: headers,
                body: JSON.stringify(updateData),
                credentials: 'same-origin'
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.success) {
                    // Check if item was deleted (quantity reached 0)
                    if (data.deleted) {
                        const feedback = document.getElementById('addItemFeedback');
                        if (feedback) {
                            showFeedback(data.message || 'Item removed (quantity reached 0)', 'info');
                        }
                    } else {
                        // Show success feedback
                        const feedback = document.getElementById('addItemFeedback');
                        if (feedback) {
                            const message = updateType === 'expiration' ? 'Expiration date updated successfully!' : 'Item updated successfully!';
                            showFeedback(message, 'success');
                        }
                    }
                    
                    // Reload pantry items to reflect the change
                    await reloadPantryItems();
                } else {
                    throw new Error(data.error || 'Failed to update item');
                }
            } else {
                const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                throw new Error(errorData.error || 'Failed to update item');
            }
        } catch (error) {
            console.error('Error updating item:', error);
            const feedback = document.getElementById('addItemFeedback');
            if (feedback) {
                const message = updateType === 'expiration' ? 'Failed to update expiration date: ' : 'Failed to update item: ';
                showFeedback(message + error.message, 'danger');
            } else {
                alert('Failed to update item: ' + error.message);
            }
        }
    }
    
    // Handle quantity update via API (backward compatibility)
    async function handleUpdateQuantity(itemId, itemName, newQuantity, expirationDate, addedDate) {
        await handleUpdateItem(itemId, itemName, newQuantity, expirationDate, addedDate, 'quantity');
    }
    
    // Handle expiration date update via API
    async function handleUpdateExpiration(itemId, itemName, quantity, newExpirationDate, addedDate) {
        await handleUpdateItem(itemId, itemName, quantity, newExpirationDate, addedDate, 'expiration');
    }
    
    // Initialize quantity editing
    function initializeQuantityEditing() {
        const quantityBadges = document.querySelectorAll('.editable-quantity');
        quantityBadges.forEach(badge => {
            // Remove existing listeners by cloning
            if (!badge.parentNode) return; // Skip if badge is not in DOM
            
            const newBadge = badge.cloneNode(true);
            badge.parentNode.replaceChild(newBadge, badge);
            
            // Add click listener
            newBadge.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card click
                
                // Prevent multiple simultaneous edits
                if (this.classList.contains('editing')) return;
                this.classList.add('editing');
                
                const itemId = this.getAttribute('data-item-id') || '';
                // Item ID can be empty - backend will use name matching as fallback
                
                const itemName = this.getAttribute('data-item-name');
                if (!itemName || !itemName.trim()) {
                    console.error('Item name is missing for quantity edit');
                    this.classList.remove('editing');
                    return;
                }
                
                const currentQuantity = this.getAttribute('data-current-quantity') || '1';
                // Get expiration date from the expiration badge if it exists, or from data attribute
                const expirationBadge = this.closest('.pantry-item-wrapper')?.querySelector('.editable-expiration');
                const expirationDate = expirationBadge?.getAttribute('data-current-expiration') || 
                                      this.getAttribute('data-expiration-date') || 
                                      null;
                const addedDate = this.getAttribute('data-added-date') || new Date().toISOString();
                
                // Create input field
                const quantityValue = this.querySelector('.quantity-value');
                if (!quantityValue) {
                    this.classList.remove('editing');
                    return;
                }
                
                const oldText = quantityValue.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentQuantity;
                input.style.cssText = 'background: white; border: 2px solid #8B5CF6; border-radius: 6px; padding: 2px 6px; font-size: 0.75rem; width: 60px; text-align: center; color: #8B5CF6;';
                input.className = 'quantity-input';
                
                // Replace text with input
                quantityValue.textContent = '';
                quantityValue.appendChild(input);
                input.focus();
                input.select();
                
                // Handle save on blur or Enter
                const saveQuantity = async () => {
                    // Remove event listeners to prevent double calls
                    input.removeEventListener('blur', saveQuantity);
                    
                    let newQuantity = input.value.trim() || '1';
                    // Validate quantity: must be a positive integer
                    const quantityNum = parseInt(newQuantity, 10);
                    if (isNaN(quantityNum) || quantityNum < 0) {
                        // Invalid input - restore original value
                        if (quantityValue) {
                            quantityValue.textContent = oldText;
                        }
                        newBadge.classList.remove('editing');
                        showFeedback('Quantity must be a positive number', 'danger');
                        return;
                    }
                    // Ensure quantity is at least 0 (0 will delete the item)
                    newQuantity = Math.max(0, quantityNum).toString();
                    
                    if (newQuantity !== currentQuantity) {
                        // Show loading state
                        quantityValue.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Saving...';
                        
                        try {
                            // Update the badge attribute
                            newBadge.setAttribute('data-current-quantity', newQuantity);
                            // Call API to update
                            await handleUpdateQuantity(itemId, itemName, newQuantity, expirationDate, addedDate);
                            // The reloadPantryItems() in handleUpdateQuantity will refresh the display
                        } catch (error) {
                            // On error, restore original display
                            if (quantityValue) {
                                quantityValue.textContent = oldText;
                            }
                        } finally {
                            // Always remove editing class
                            newBadge.classList.remove('editing');
                        }
                    } else {
                        // Restore original text if no change
                        if (quantityValue) {
                            quantityValue.textContent = oldText;
                        }
                        newBadge.classList.remove('editing');
                    }
                };
                
                const cancelEdit = () => {
                    if (quantityValue) {
                        quantityValue.textContent = oldText;
                    }
                    newBadge.classList.remove('editing');
                };
                
                input.addEventListener('blur', saveQuantity);
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
            });
        });
    }
    
    // Initialize expiration date editing
    function initializeExpirationEditing() {
        const expirationBadges = document.querySelectorAll('.editable-expiration');
        expirationBadges.forEach(badge => {
            // Remove existing listeners by cloning
            if (!badge.parentNode) return; // Skip if badge is not in DOM
            
            const newBadge = badge.cloneNode(true);
            badge.parentNode.replaceChild(newBadge, badge);
            
            // Add click listener
            newBadge.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card click
                
                // Prevent multiple simultaneous edits
                if (this.classList.contains('editing')) return;
                this.classList.add('editing');
                
                const itemId = this.getAttribute('data-item-id') || '';
                // Item ID can be empty - backend will use name matching as fallback
                
                const itemName = this.getAttribute('data-item-name');
                if (!itemName || !itemName.trim()) {
                    console.error('Item name is missing for expiration date edit');
                    this.classList.remove('editing');
                    return;
                }
                
                const currentQuantity = this.getAttribute('data-current-quantity') || '1';
                const currentExpiration = this.getAttribute('data-current-expiration') || '';
                const addedDate = this.getAttribute('data-added-date') || new Date().toISOString();
                
                // Create date input field
                const expirationValue = this.querySelector('.expiration-value');
                if (!expirationValue) {
                    this.classList.remove('editing');
                    return;
                }
                
                const oldText = expirationValue.textContent;
                const input = document.createElement('input');
                input.type = 'date';
                
                // Set current date value (format: YYYY-MM-DD)
                let currentDateValue = '';
                if (currentExpiration && currentExpiration !== 'None' && currentExpiration !== '' && currentExpiration !== 'null') {
                    // Extract date part if it's a full datetime string
                    const trimmedDate = currentExpiration.trim();
                    // Check if it's a valid date format (YYYY-MM-DD or longer)
                    if (trimmedDate.length >= 10) {
                        // Extract first 10 characters (YYYY-MM-DD)
                        const datePart = trimmedDate.substring(0, 10);
                        // Validate it's in YYYY-MM-DD format
                        if (/^\d{4}-\d{2}-\d{2}$/.test(datePart)) {
                            currentDateValue = datePart;
                        } else {
                            // Try to parse and reformat
                            try {
                                const dateObj = new Date(trimmedDate);
                                if (!isNaN(dateObj.getTime())) {
                                    currentDateValue = dateObj.toISOString().split('T')[0];
                                }
                            } catch (e) {
                                console.warn('Failed to parse expiration date:', trimmedDate);
                            }
                        }
                    } else if (trimmedDate.length > 0) {
                        // Try to parse shorter date strings
                        try {
                            const dateObj = new Date(trimmedDate);
                            if (!isNaN(dateObj.getTime())) {
                                currentDateValue = dateObj.toISOString().split('T')[0];
                            } else {
                                currentDateValue = trimmedDate;
                            }
                        } catch (e) {
                            currentDateValue = trimmedDate;
                        }
                    }
                }
                input.value = currentDateValue;
                
                // Set minimum date to today
                const today = new Date().toISOString().split('T')[0];
                input.min = today;
                
                input.style.cssText = 'background: white !important; border: 2px solid #8B5CF6 !important; border-radius: 8px !important; padding: 5px 8px !important; font-size: 0.75rem !important; font-weight: 600 !important; color: #8B5CF6 !important; width: 150px !important; min-width: 150px !important; display: inline-block !important; outline: none !important; box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1) !important;';
                input.className = 'expiration-input';
                
                // Clear and replace content properly
                expirationValue.innerHTML = '';
                expirationValue.style.display = 'inline-block';
                expirationValue.appendChild(input);
                
                // Focus and show picker after a small delay to ensure DOM is ready
            setTimeout(() => {
                    input.focus();
                    input.select();
                    // Try to show date picker if supported
                    if (input.showPicker && typeof input.showPicker === 'function') {
                        try {
                            input.showPicker();
                        } catch (e) {
                            // showPicker not supported, just focus
                            input.focus();
                        }
                    }
                }, 10);
                
                // Handle save on blur or change
                const saveExpiration = async () => {
                    const newExpiration = input.value.trim() || null;
                    const oldExpirationFormatted = currentDateValue || null;
                    
                    // Remove input event listeners to prevent double calls
                    input.removeEventListener('change', saveExpiration);
                    input.removeEventListener('blur', saveExpiration);
                    
                    if (newExpiration !== oldExpirationFormatted) {
                        // Show loading state
                        expirationValue.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Saving...';
                        
                        try {
                            // Update the badge attributes
                            newBadge.setAttribute('data-current-expiration', newExpiration || '');
                            newBadge.setAttribute('data-exp-date', newExpiration || '');
                            
                            // Call API to update
                            await handleUpdateExpiration(itemId, itemName, currentQuantity, newExpiration, addedDate);
                            
                            // The reloadPantryItems() in handleUpdateExpiration will refresh the display
                            // So we don't need to manually update here
                        } catch (error) {
                            // On error, restore original display (just text, icon is already outside)
                            if (expirationValue && oldText && oldText.trim() !== '') {
                                expirationValue.textContent = oldText;
                            } else if (expirationValue) {
                                expirationValue.textContent = 'Add Date';
                            }
                        } finally {
                            // Always remove editing class
                            newBadge.classList.remove('editing');
                        }
                    } else {
                        // Restore original display if no change (just text, icon is already outside)
                        if (expirationValue && oldText && oldText.trim() !== '') {
                            expirationValue.textContent = oldText;
                        } else if (expirationValue) {
                            expirationValue.textContent = 'Add Date';
                        }
                        newBadge.classList.remove('editing');
                    }
                };
                
                const cancelEdit = () => {
                    // Remove input event listeners
                    input.removeEventListener('change', saveExpiration);
                    input.removeEventListener('blur', saveExpiration);
                    
                    // Restore original display (just text, icon is already outside)
                    if (oldText && oldText.trim() !== '') {
                        expirationValue.textContent = oldText;
                    } else {
                        expirationValue.textContent = 'Add Date';
                    }
                };
                
                input.addEventListener('change', saveExpiration);
                input.addEventListener('blur', saveExpiration);
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
            });
        });
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        initializeDeleteButtons();
        initializeQuantityEditing();
        initializeExpirationEditing();
        
        // Update expiration badges and card backgrounds on initial load
        updateExpirationBadges();
        updatePantryCardBackgrounds();
        
        // Restore sort type if one was saved
        const savedSortType = sessionStorage.getItem('pantrySortType');
        if (savedSortType) {
            currentSortType = savedSortType;
            // Update sort label
            updateSortLabel(getSortLabel(savedSortType));
            // Apply sort after a short delay to ensure DOM is ready
            setTimeout(() => {
                sortPantry(savedSortType);
            }, 300);
        } else {
            // Even without sort, update backgrounds after a delay to ensure DOM is ready
            setTimeout(() => {
                updateExpirationBadges();
                updatePantryCardBackgrounds();
            }, 200);
        }
    });
</script>
{% endblock %}


