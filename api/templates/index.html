{% extends "base.html" %}

{% block title %}Home - SmartPantry{% endblock %}

{% block extra_head %}
<style>
    /* Removed vague animations - cards appear instantly for better performance */
    .pantry-item-card {
        opacity: 1;
        position: relative;
        z-index: 10;
    }
    
    .pantry-item-wrapper {
        position: relative;
        z-index: 10;
    }
    
    #pantryItemsContainer {
        position: relative;
        z-index: 10;
        visibility: visible !important;
        opacity: 1 !important;
    }
    
    /* Ensure pantry items appear above card header */
    .card-body {
        position: relative;
        z-index: 5;
    }
    
    .card-header {
        position: relative;
        z-index: 1;
    }
    
    /* Fix modal backdrop - DISABLED: No gray screen */
    .modal-backdrop {
        display: none !important; /* Completely hide backdrop */
        opacity: 0 !important;
        visibility: hidden !important;
        pointer-events: none !important;
        background-color: transparent !important;
    }
    
    /* Specifically hide backdrop for addItemModal */
    #addItemModal + .modal-backdrop,
    body:has(#addItemModal.show) .modal-backdrop {
        display: none !important;
        opacity: 0 !important;
        visibility: hidden !important;
        pointer-events: none !important;
    }
    
    /* Modal container - must be above backdrop - NO ANIMATIONS */
    .modal {
        z-index: 1050 !important; /* Bootstrap default */
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100% !important;
        height: 100% !important;
        display: none !important;
        overflow-x: hidden !important;
        overflow-y: auto !important;
        transition: none !important; /* Disable all transitions */
        opacity: 1 !important; /* Always visible when shown */
    }
    
    .modal.fade {
        transition: none !important; /* Disable fade transition */
        opacity: 1 !important;
    }
    
    .modal.show {
        display: flex !important; /* Use flex to center */
        align-items: center !important;
        justify-content: center !important;
        opacity: 1 !important; /* Instant show - no fade */
    }
    
    .modal.fade.show {
        opacity: 1 !important; /* Instant show even with fade class */
    }
    
    /* Ensure modal dialog is above backdrop and responsive */
    .modal-dialog {
        z-index: 1051 !important;
        position: relative;
        margin: 1rem auto !important;
        max-width: 720px !important;
        width: 90% !important;
        pointer-events: auto !important; /* Allow clicks on dialog */
    }
    
    .modal-dialog-centered {
        min-height: calc(100% - 2rem) !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
    }
    
    /* Ensure modal content is clickable and properly layered */
    .modal-content {
        z-index: 1052 !important;
        position: relative;
        background: white !important;
        border-radius: 16px !important;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.25) !important;
        pointer-events: auto !important; /* Content captures clicks */
    }
    
    /* Ensure all interactive elements in modal are clickable */
    .modal.show .modal-content,
    .modal.show .modal-content * {
        pointer-events: auto !important;
    }
    
    /* Prevent body scroll when modal is open */
    body.modal-open {
        overflow: hidden !important;
        padding-right: 0 !important;
    }
    
    /* Backdrop completely disabled - no gray screen */
    .modal-backdrop,
    .modal-backdrop.fade,
    .modal-backdrop.show,
    .modal-backdrop.fade.show {
        display: none !important;
        opacity: 0 !important;
        visibility: hidden !important;
        pointer-events: none !important;
        background-color: transparent !important;
        transition: none !important;
    }
    
    /* Disable modal dialog transitions */
    .modal-dialog {
        transition: none !important;
        transform: none !important;
    }
    
    .modal.fade .modal-dialog {
        transition: none !important;
        transform: none !important;
    }
    
    .modal.show .modal-dialog {
        transform: none !important; /* No slide/fade animations */
    }
    
    /* Photo upload modal - ensure it's on top */
    #photoModal {
        z-index: 1050 !important;
    }
    
    #photoModal.show {
        z-index: 1050 !important;
    }
    
    #photoModal .modal-dialog {
        max-width: 720px !important;
        width: 90% !important;
        z-index: 1051 !important;
    }
    
    #photoModal .modal-content {
        z-index: 1052 !important;
    }
    
    /* Add Item Modal - ensure it's on top */
    #addItemModal {
        z-index: 1050 !important;
    }
    
    #addItemModal.show {
        z-index: 1050 !important;
    }
    
    #addItemModal .modal-dialog {
        max-width: 720px !important;
        width: 90% !important;
        z-index: 1051 !important;
    }
    
    #addItemModal .modal-content {
        z-index: 1052 !important;
    }
    
    /* Add Item Modal Header Styling */
    #addItemModal .modal-header {
        background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%) !important;
        color: white !important;
        border-radius: 16px 16px 0 0 !important;
        padding: 1.5rem 1.75rem !important;
        border-bottom: none !important;
    }
    
    /* Photo Modal Header Styling */
    #photoModal .modal-header {
        background: linear-gradient(135deg, #10B981 0%, #059669 100%) !important;
        color: white !important;
        border-radius: 16px 16px 0 0 !important;
        padding: 1.5rem 1.75rem !important;
        border-bottom: none !important;
    }
    
    #photoModal .modal-header .modal-title {
        color: white !important;
        font-weight: 600 !important;
        font-size: 1.25rem !important;
    }
    
    #photoModal .modal-header .modal-title i {
        color: white !important;
    }
    
    #photoModal .modal-header .btn-close {
        filter: invert(1) grayscale(100%) brightness(200%) !important;
        opacity: 0.9 !important;
    }
    
    #photoModal .modal-header .btn-close:hover {
        opacity: 1 !important;
    }
    
    #addItemModal .modal-header .modal-title {
        color: white !important;
        font-weight: 600 !important;
        font-size: 1.25rem !important;
    }
    
    #addItemModal .modal-header .modal-title i {
        color: white !important;
    }
    
    #addItemModal .modal-header .btn-close {
        filter: invert(1) grayscale(100%) brightness(200%) !important;
        opacity: 0.9 !important;
    }
    
    #addItemModal .modal-header .btn-close:hover {
        opacity: 1 !important;
    }
    
    /* Tablet breakpoint (768x1024) */
    @media (max-width: 768px) {
        #photoModal .modal-dialog {
            max-width: 95% !important;
            width: 95% !important;
            margin: 0.5rem auto !important;
        }
        
        #photoModal .modal-body {
            padding: 1.5rem !important;
        }
        
        #photoModal .btn {
            padding: 0.75rem 1.25rem !important;
            font-size: 0.95rem !important;
            min-height: 44px !important;
            min-width: 44px !important;
        }
        
        /* Ensure all buttons are clickable on mobile */
        .btn, button {
            min-height: 44px !important;
            min-width: 44px !important;
            padding: 0.75rem 1.25rem !important;
            touch-action: manipulation !important;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1) !important;
        }
        
        /* Small buttons still accessible */
        .btn-sm {
            min-height: 38px !important;
            min-width: 38px !important;
            padding: 0.5rem 1rem !important;
        }
        
        #photoModal .row.g-2 {
            gap: 0.5rem !important;
        }
    }
    
    /* Mobile breakpoint (360x640) */
    @media (max-width: 576px) {
        #photoModal .modal-dialog {
            max-width: 98% !important;
            width: 98% !important;
            margin: 0.25rem auto !important;
        }
        
        /* Mobile button sizes for better touch targets */
        #photoModal .btn {
            padding: 0.875rem 1.5rem !important;
            font-size: 1rem !important;
            min-height: 48px !important;
            min-width: 48px !important;
        }
        
        /* Larger touch targets on small screens */
        .btn, button {
            min-height: 48px !important;
            min-width: 48px !important;
            padding: 0.875rem 1.5rem !important;
        }
        
        .btn-sm {
            min-height: 42px !important;
            min-width: 42px !important;
            padding: 0.625rem 1.125rem !important;
        }
        
        #photoModal .modal-header {
            padding: 1rem !important;
        }
        
        #photoModal .modal-title {
            font-size: 1rem !important;
        }
        
        #photoModal .modal-body {
            padding: 1rem !important;
        }
        
        #photoModal .btn {
            padding: 0.5rem 0.75rem !important;
            font-size: 0.875rem !important;
        }
        
        /* Mobile keyboard handling - ensure inputs are visible when keyboard appears */
        @supports (-webkit-touch-callout: none) {
            /* iOS specific */
            .modal.show {
                position: fixed;
                height: 100vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
    .modal-dialog {
                margin: 1rem auto !important;
                min-height: auto !important;
            }
            
            /* Scroll input into view when focused */
            input:focus, textarea:focus, select:focus {
                scroll-margin-top: 100px;
            }
        }
        
        /* Android and general mobile */
        @media (max-height: 600px) {
            /* When keyboard is likely open */
            .modal-dialog-centered {
                align-items: flex-start !important;
                padding-top: 1rem;
            }
        }
        
        #photoModal .photo-upload-zone {
            padding: 1.5rem 1rem !important;
            min-height: 200px !important;
        }
        
        #photoModal .photo-upload-zone h5 {
            font-size: 1rem !important;
        }
        
        #photoModal .photo-upload-zone .display-1 {
            font-size: 3rem !important;
        }
        
        #photoModal .row.g-2 > div {
            padding: 0.25rem !important;
        }
    }
    
    /* Extra small mobile (360px and below) */
    @media (max-width: 360px) {
        #photoModal .modal-dialog {
            max-width: 100% !important;
            width: 100% !important;
            margin: 0 !important;
            border-radius: 0 !important;
        }
        
        #photoModal .modal-content {
            border-radius: 0 !important;
        }
    }
    
    /* Responsive modal content */
    .modal-content {
        max-height: 90vh !important;
        overflow-y: auto !important;
        overflow-x: hidden !important;
    }
    
    /* Prevent backdrop from staying after modal closes */
    body:not(.modal-open) .modal-backdrop {
        display: none !important;
        opacity: 0 !important;
        visibility: hidden !important;
        pointer-events: none !important;
    }
    
    /* Force remove backdrop when no modals are showing */
    body:not(.modal-open) .modal-backdrop {
        display: none !important;
    }
    
    /* Ensure modals are always visible and clickable when shown */
    .modal.show {
        display: flex !important;
        z-index: 1050 !important;
        align-items: center !important;
        justify-content: center !important;
    }
    
    .modal.show .modal-dialog {
        z-index: 1051 !important;
        pointer-events: none !important; /* Dialog container doesn't capture clicks */
        max-width: 720px !important;
        width: 90% !important;
    }
    
    .modal.show .modal-content {
        z-index: 1052 !important;
        pointer-events: auto !important; /* Content captures clicks */
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.25) !important;
    }
    
    /* Ensure navbar/header stays below modal */
    .navbar {
        z-index: 100 !important;
    }
    
    /* Ensure sticky elements stay below modals */
    .sticky-action-bar,
    .sticky-top {
        z-index: 50 !important;
    }
    
    /* Prevent any page content from being blurred when modal is open */
    body.modal-open > *:not(.modal):not(.modal-backdrop) {
        filter: none !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
    }
    
    /* Ensure hero section and cards don't blur when modal opens */
    body.modal-open .hero-section,
    body.modal-open .card,
    body.modal-open .card-header .badge {
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        filter: none !important;
    }
    
    /* Enhanced UI Styles */
    :root {
        --primary-purple: #8B5CF6;
        --primary-blue: #3B82F6;
        --success-green: #10B981;
        --danger-red: #EF4444;
        --warning-orange: #F59E0B;
        --gray-50: #F9FAFB;
        --gray-100: #F3F4F6;
        --gray-200: #E5E7EB;
        --gray-300: #D1D5DB;
        --gray-600: #4B5563;
        --gray-800: #1F2937;
        --gray-900: #111827;
        --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    /* Improved card styling */
    .card {
        border: none;
        box-shadow: var(--shadow-md);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: visible; /* Allow dropdowns to show */
    }
    
    .card:hover {
        box-shadow: var(--shadow-lg);
        transform: translateY(-2px);
    }
    
    .card-header {
        background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        border-bottom: none;
        padding: 1.25rem 1.5rem;
        font-weight: 600;
    }
    
    .card-header.bg-gradient-success {
        background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
    }
    
    .card-header.bg-gradient-info {
        background: linear-gradient(135deg, var(--primary-blue) 0%, #2563EB 100%);
    }
    
    /* Enhanced pantry item cards */
    .pantry-item-card {
        overflow: hidden;
        will-change: transform;
        border: 1px solid var(--gray-200);
        background: white;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
    }
    
    .pantry-item-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(90deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .pantry-item-card:hover {
        border-color: var(--primary-purple);
        box-shadow: 0 16px 32px rgba(139, 92, 246, 0.2);
    }
    
    .pantry-item-card:hover::before {
        opacity: 1;
    }
    
    /* Enhanced item icon container */
    .pantry-item-card .bi-box-seam {
        filter: drop-shadow(0 2px 4px rgba(139, 92, 246, 0.2));
    }
    
    /* Improved badge spacing and layout */
    .pantry-item-card .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.375rem;
        white-space: nowrap;
    }
    
    /* Fix text overflow in pantry item names - wrap only at word boundaries */
    .pantry-item-card .fw-bold {
        overflow: visible !important;
        text-overflow: clip !important;
        white-space: normal !important;
        max-width: 100% !important;
        display: block !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        word-break: break-word !important;
        hyphens: none !important;
        line-height: 1.4 !important;
        text-overflow: unset !important;
    }
    
    /* Ensure card layout doesn't break with long names */
    .pantry-item-card {
        min-height: 120px;
        display: flex;
        flex-direction: column;
    }
    
    .pantry-item-card .card-body {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: visible; /* Allow content to wrap and show fully */
    }
    
    /* Prevent delete button from overlapping text */
    .pantry-item-card .position-absolute {
        z-index: 10;
    }
    
    .pantry-item-card .fw-bold {
        padding-right: 40px; /* Space for delete button */
        word-wrap: normal;
        overflow-wrap: normal;
        word-break: normal;
    }
    
    /* Prevent card hover overflow */
    .pantry-item-wrapper {
        overflow: visible;
    }
    
    /* Enhanced badge styling */
    .badge {
        font-weight: 500;
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .editable-quantity,
    .editable-expiration {
        cursor: pointer;
        user-select: none;
    }
    
    .editable-expiration.editing {
        pointer-events: none;
        opacity: 0.7;
        cursor: wait;
    }
    
    .editable-quantity.editing {
        pointer-events: none;
        opacity: 0.7;
        cursor: wait;
    }
    
    .editable-quantity:hover,
    .editable-expiration:hover {
        transform: scale(1.05);
        box-shadow: 0 2px 8px rgba(139, 92, 246, 0.2);
    }
    
    /* Enhanced button styling with reliable hover states */
    .btn {
        font-weight: 600;
        border-radius: 0.75rem;
        padding: 0.625rem 1.25rem;
        transition: all 0.2s ease;
        border: none;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        -webkit-tap-highlight-color: transparent;
    }
    
    .btn:hover:not(:disabled) {
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }
    
    .btn:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: var(--shadow-sm);
    }
    
    .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
    }
    
    /* Loading state for buttons */
    .btn.loading {
        pointer-events: none;
        opacity: 0.7;
    }
    
    .btn .spinner-border-sm {
        width: 1rem;
        height: 1rem;
        border-width: 0.15em;
    }
    
    .btn-lg {
        padding: 0.875rem 1.75rem;
        font-size: 1.125rem;
        border-radius: 1rem;
    }
    
    .btn-primary {
        background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        color: white;
        border: none;
    }
    
    .btn-primary:hover {
        background: linear-gradient(135deg, #7C3AED 0%, #2563EB 100%);
        color: white;
        transform: translateY(-1px);
    }
    
    .btn-success {
        background: linear-gradient(135deg, var(--success-green) 0%, #059669 100%);
        color: white;
        border: none;
    }
    
    .btn-success:hover {
        background: linear-gradient(135deg, #059669 0%, #047857 100%);
        color: white;
        transform: translateY(-1px);
    }
    
    .btn-outline-success {
        border: 2px solid var(--success-green);
        color: var(--success-green);
        background: transparent;
    }
    
    .btn-outline-success:hover {
        background: var(--success-green);
        color: white;
        border-color: var(--success-green);
    }
    
    .btn-outline-secondary {
        border: 2px solid var(--gray-300);
        color: var(--gray-600);
        background: transparent;
    }
    
    .btn-outline-secondary:hover {
        background: var(--gray-200);
        color: var(--gray-800);
        border-color: var(--gray-300);
    }
    
    .btn-outline-danger {
        border: 2px solid var(--danger-red);
        color: var(--danger-red);
        background: transparent;
    }
    
    .btn-outline-danger:hover {
        background: var(--danger-red);
        color: white;
        transform: scale(1.05);
    }
    
    /* Enhanced form inputs */
    .form-control,
    .form-select {
        border: 2px solid var(--gray-200);
        border-radius: 0.75rem;
        padding: 0.75rem 1rem;
        transition: all 0.2s ease;
    }
    
    .form-control:focus,
    .form-select:focus {
        border-color: var(--primary-purple);
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        outline: none;
    }
    
    /* Enhanced expiration badges */
    .expiration-badge {
        font-weight: 500;
        padding: 0.375rem 0.75rem;
        border-radius: 0.5rem;
        display: inline-flex;
        align-items: center;
        gap: 0.375rem;
    }
    
    .expiration-expired {
        background: rgba(239, 68, 68, 0.15);
        color: #DC2626;
    }
    
    .expiration-soon {
        background: rgba(245, 158, 11, 0.15);
        color: #D97706;
    }
    
    .expiration-fresh {
        background: rgba(16, 185, 129, 0.15);
        color: #059669;
    }
    
    /* Pantry item card background highlighting based on expiration */
    .pantry-item-card.expiration-expired-card {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.08) 0%, rgba(220, 38, 38, 0.05) 100%) !important;
        border-color: rgba(239, 68, 68, 0.3) !important;
    }
    
    .pantry-item-card.expiration-soon-card {
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.12) 0%, rgba(217, 119, 6, 0.08) 100%) !important;
        border-color: rgba(245, 158, 11, 0.4) !important;
    }
    
    .pantry-item-card.expiration-fresh-card {
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.08) 0%, rgba(5, 150, 105, 0.05) 100%) !important;
        border-color: rgba(16, 185, 129, 0.3) !important;
    }
    
    .expiration-none {
        background: rgba(156, 163, 175, 0.15);
        color: #6B7280;
    }
    
    /* Enhanced delete button */
    .delete-item-btn {
        transition: all 0.2s ease;
        pointer-events: auto !important;
        cursor: pointer !important;
        z-index: 1001 !important;
        position: relative !important;
    }
    
    .delete-item-btn:hover {
        transform: scale(1.15) rotate(90deg);
    }
    
    .delete-item-btn:active {
        pointer-events: auto !important;
    }
    
    .delete-item-btn i {
        pointer-events: none !important;
    }
    
    /* Improved empty state */
    .empty-state {
        padding: 3rem 1rem;
    }
    
    .empty-state i {
        opacity: 0.5;
    }
    
    /* Enhanced modal styling */
    .modal-content {
        border: none;
        border-radius: 1.5rem;
        box-shadow: var(--shadow-xl);
        overflow: hidden;
        background: white;
    }
    
    .modal-header {
        background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        color: white;
        border-bottom: none;
        padding: 1.5rem;
    }
    
    .modal-header .modal-title {
        color: white;
        font-weight: 700;
        font-size: 1.5rem;
        letter-spacing: -0.02em;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }
    
    /* Visual hierarchy: Make modal title more prominent */
    #photoModal .modal-header .modal-title {
        font-size: 1.75rem;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .modal-header .btn-close {
        filter: invert(1);
        opacity: 0.9;
    }
    
    .modal-header .btn-close:hover {
        opacity: 1;
    }
    
    .modal-body {
        padding: 2rem;
        background: var(--gray-50);
        overflow-y: auto;
        overflow-x: hidden;
        max-height: calc(90vh - 120px);
    }
    
    /* Consistent spacing for modal buttons */
    #photoModal .modal-body .d-flex.gap-2 {
        gap: 0.75rem !important;
    }
    
    /* Better alignment for button groups */
    #photoModal .modal-body .btn-group,
    #photoModal .modal-body .d-flex {
        align-items: center;
        justify-content: center;
    }
    
    .modal-footer {
        border-top: 1px solid var(--gray-200);
        padding: 1.5rem;
        background: white;
    }
    
    /* Photo upload zone styling - responsive */
    .photo-upload-zone {
        border: 2px dashed #cbd5e0;
        border-radius: 16px;
        padding: 2rem 1.5rem;
        text-align: center;
        background: #f8f9fa;
        transition: border-color 0.2s ease, background-color 0.2s ease, box-shadow 0.2s ease;
        cursor: pointer;
        min-height: 200px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
        position: relative;
        user-select: none;
    }
    
    /* Responsive styles for modal and photo upload */
    @media (max-width: 768px) {
        .photo-upload-zone {
            padding: 1.5rem 1rem;
            min-height: 150px;
        }
        
        .modal-dialog {
            margin: 0.5rem !important;
            max-width: calc(100% - 1rem) !important;
        }
        
        .modal-content {
            max-height: 95vh !important;
            border-radius: 16px !important;
        }
        
        .camera-preview {
            min-height: 250px;
        }
        
        .image-preview {
            max-height: 300px;
        }
    }
    
    @media (max-width: 576px) {
        .modal-dialog {
            margin: 0.25rem !important;
            max-width: calc(100% - 0.5rem) !important;
        }
        
        .modal-content {
            max-height: 98vh !important;
            border-radius: 12px !important;
        }
        
        .photo-upload-zone {
            padding: 1rem 0.75rem;
            min-height: 120px;
        }
        
        .photo-upload-zone h5 {
            font-size: 1rem;
        }
        
        .photo-upload-zone .display-1 {
            font-size: 2.5rem !important;
        }
    }
    
    .photo-upload-zone:hover {
        border-color: #8B5CF6;
        background: #f0f4ff;
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.15);
    }
    
    .photo-upload-zone:hover .bi-cloud-upload {
        color: #8B5CF6 !important;
        transform: scale(1.1);
        transition: color 0.2s ease, transform 0.2s ease;
    }
    
    .photo-upload-zone.dragover {
        border-color: #8B5CF6;
        background: #e6edff;
        border-width: 3px;
        box-shadow: 0 8px 24px rgba(139, 92, 246, 0.3);
    }
    
    .photo-upload-zone.dragover .bi-cloud-upload {
        color: #8B5CF6 !important;
        transform: scale(1.15);
        transition: color 0.2s ease, transform 0.2s ease;
    }
    
    .photo-upload-zone.dragover h5 {
        color: #8B5CF6;
        font-weight: 600;
    }
    
    .image-preview {
        max-width: 100%;
        max-height: 400px;
        border-radius: 16px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        margin: 1rem auto;
        display: block;
        object-fit: contain;
    }
    
    /* Fix button blur/shift issues - prevent layout shifts */
    .photo-modal-btn {
        will-change: auto !important;
        transform: none !important; /* Prevent blur/jump on click */
        transform: none !important;
        filter: none !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
        position: relative;
    }
    
    .photo-modal-btn:hover {
        opacity: 0.9 !important;
        transform: none !important;
        filter: none !important;
        backdrop-filter: none !important;
        -webkit-backdrop-filter: none !important;
    }
    
    .photo-modal-btn:active {
        opacity: 0.9 !important;
        transform: none !important; /* Remove scale on click to prevent jump */
    }
    
    .photo-modal-btn:focus {
        outline: 2px solid rgba(59, 130, 246, 0.5);
        outline-offset: 2px;
        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    
    /* Override global button transforms for photo modal - Remove blur/jump on click */
    .photo-modal-btn:active,
    .photo-modal-btn:focus,
    .photo-modal-btn:hover {
        transform: none !important;
        filter: none !important;
        will-change: auto !important;
    }
    
    .photo-modal-btn {
        transform: none !important;
        filter: none !important;
    }
    
    /* Override global button transforms for photo modal */
    #photoModal .btn-primary,
    #photoModal .btn-success,
    #photoModal .btn-outline-success,
    #photoModal .btn-outline-secondary {
        transform: none !important;
    }
    
    #photoModal .btn-primary:hover,
    #photoModal .btn-success:hover,
    #photoModal .btn-outline-success:hover,
    #photoModal .btn-outline-secondary:hover {
        transform: none !important;
    }
    
    /* Ensure consistent theme colors in photo modal */
    #photoModal .modal-content {
        background: #ffffff;
        color: #1e293b;
    }
    
    #photoModal .modal-header {
        background: #ffffff;
        border-bottom: 1px solid #e2e8f0;
    }
    
    #photoModal .modal-body {
        background: #ffffff;
        color: #1e293b;
    }
    
    #photoModal .text-muted {
        color: #64748b !important;
    }
    
    #photoModal .btn-close {
        filter: none;
        opacity: 0.5;
    }
    
    #photoModal .btn-close:hover {
        opacity: 1;
    }
    
    /* Camera preview styling */
    .camera-preview {
        position: relative;
        border-radius: 16px;
        overflow: hidden;
        background: #000;
        min-height: 300px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
    }
    
    .camera-preview video {
        width: 100%;
        height: auto;
        display: block;
        max-height: 500px;
        object-fit: contain;
        z-index: 5;
    }
    
    /* Camera status messages */
    .camera-status-message {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20;
        border-radius: 16px;
    }
    
    .camera-error-message {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.98);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20;
        border-radius: 16px;
        padding: 2rem;
    }
    
    .camera-ready-indicator {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(16, 185, 129, 0.9);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        z-index: 15;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        font-size: 0.875rem;
    }
    
    .camera-tips {
        position: absolute;
        bottom: 60px;
        left: 10px;
        right: 10px;
        z-index: 15;
        background: rgba(139, 92, 246, 0.1);
        backdrop-filter: blur(4px);
    }
    
    /* Preview section styling */
    #previewSection {
        transition: opacity 0.3s ease;
    }
    
    #previewSection[style*="display: block"] {
        animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    /* Upload zone and camera view transitions */
    #uploadZone,
    #cameraView,
    #previewSection {
        transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    .camera-controls {
        position: absolute;
        bottom: 1rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 1rem;
        align-items: center;
    }
    
    .capture-btn {
        width: 64px;
        height: 64px;
        border-radius: 50%;
        border: 4px solid white;
        background: white;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.2s ease;
    }
    
    .capture-btn:hover {
        transform: scale(1.1);
    }
    
    .capture-btn:active {
        transform: scale(0.95);
    }
    
    /* Enhanced dropdown */
    .dropdown-menu {
        border: none;
        box-shadow: var(--shadow-lg);
        border-radius: 0.75rem;
        padding: 0.5rem;
        margin-top: 0.5rem;
        z-index: 1050 !important;
        overflow: visible !important;
        max-height: none !important;
    }
    
    /* Ensure dropdown is not clipped by parent containers */
    .dropdown {
        position: relative;
        z-index: 1050;
    }
    
    /* Fix dropdown visibility in card headers */
    .card-header {
        overflow: visible !important;
        position: relative;
        z-index: 1;
    }
    
    .card-header .dropdown {
        position: static;
    }
    
    .card-header .dropdown-menu {
        position: absolute;
        will-change: transform;
        top: 100% !important;
        left: 0 !important;
        transform: translate3d(0px, 8px, 0px) !important;
    }
    
    .dropdown-item {
        border-radius: 0.5rem;
        padding: 0.625rem 1rem;
        transition: all 0.2s ease;
    }
    
    .dropdown-item:hover {
        background: rgba(139, 92, 246, 0.1);
        color: var(--primary-purple);
    }
    
    /* Improved stat cards */
    .stat-card {
        text-align: center;
        padding: 1.5rem;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.05) 0%, rgba(59, 130, 246, 0.05) 100%);
        border-radius: 1rem;
        transition: all 0.3s ease;
    }
    
    .stat-card:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
    }
    
    .stat-number {
        font-size: 2.5rem;
        font-weight: 700;
        background: linear-gradient(135deg, var(--primary-purple) 0%, var(--primary-blue) 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
    }
    
    /* Enhanced hero section */
    .hero-section {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
        border-radius: 2rem;
        padding: 3rem 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(139, 92, 246, 0.2);
    }
    
    /* Page background improvements */
    body {
        background: linear-gradient(135deg, #F9FAFB 0%, #F3F4F6 100%);
        min-height: 100vh;
    }
    
    /* Smooth transitions for all interactive elements */
    * {
        transition: color 0.2s ease, background-color 0.2s ease, border-color 0.2s ease;
    }
    
    /* Improved container spacing */
    .container {
        padding-left: 1rem;
        padding-right: 1rem;
    }
    
    @media (min-width: 1200px) {
        .container {
            max-width: 1140px;
        }
    }
    
    /* Enhanced card header badges */
    .card-header .badge {
        background: rgba(255, 255, 255, 0.2) !important;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.3);
    }
    
    /* Improved sort dropdown */
    .dropdown-toggle {
        border-radius: 0.5rem;
        padding: 0.5rem 1rem;
        font-weight: 500;
        transition: all 0.2s ease;
    }
    
    .dropdown-toggle:hover {
        background: rgba(139, 92, 246, 0.1);
        border-color: var(--primary-purple);
    }
    
    /* Better feedback messages */
    #addItemFeedback {
        border-radius: 0.75rem;
        padding: 1rem;
        margin-top: 1rem;
        font-weight: 500;
    }
    
    #addItemFeedback.alert-success {
        background: rgba(16, 185, 129, 0.1);
        color: #059669;
        border: 1px solid rgba(16, 185, 129, 0.2);
    }
    
    #addItemFeedback.alert-danger {
        background: rgba(239, 68, 68, 0.1);
        color: #DC2626;
        border: 1px solid rgba(239, 68, 68, 0.2);
    }
    
    #addItemFeedback.alert-warning {
        background: rgba(245, 158, 11, 0.1);
        color: #D97706;
        border: 1px solid rgba(245, 158, 11, 0.2);
    }
    
    /* Improved input fields in add items card */
    .form-control:not(.form-select) {
        border: 2px solid var(--gray-200);
    }
    
    .form-control:not(.form-select):focus {
        border-color: var(--primary-purple);
    }
    
    /* Better spacing */
    .card-body {
        padding: 1.5rem;
    }
    
    /* Enhanced quantity and expiration input styling */
    .quantity-input,
    .expiration-input {
        border: 2px solid var(--primary-purple) !important;
        border-radius: 0.5rem !important;
        padding: 0.5rem 0.75rem !important;
        font-weight: 500 !important;
        color: var(--primary-purple) !important;
    }
    
    .quantity-input:focus,
    .expiration-input:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.2) !important;
    }
    
    /* Fix mobile responsiveness */
    @media (max-width: 768px) {
        .pantry-item-card {
            margin-bottom: 12px;
        }
        
        .card-body {
            padding: 16px !important;
        }
        
        .card-header {
            padding: 16px !important;
        }
        
        .hero-section {
            padding: 40px 0 !important;
        }
        
        .hero-section h1 {
            font-size: 2rem !important;
        }
        
        .btn-lg {
            padding: 12px 24px !important;
            font-size: 0.9rem !important;
        }
        
        .badge {
            font-size: 0.75rem !important;
            padding: 6px 12px !important;
        }
        
        .dropdown-menu {
            max-width: 100%;
            white-space: normal;
        }
        
        .dropdown-item {
            white-space: normal;
            word-wrap: break-word;
        }
    }
    
    /* Fix button text overflow */
    .btn {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .btn-lg {
        white-space: normal;
    }
    
    /* Fix badge display on small screens */
    .badge {
        max-width: 100%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: inline-block;
    }
    
    /* Ensure cards don't overflow container - but allow dropdowns to show */
    .card {
        max-width: 100%;
        overflow: visible; /* Allow dropdowns to overflow */
    }
    
    /* Fix flex-grow text overflow - but allow proper word wrapping for item names */
    .flex-grow-1 {
        min-width: 0;
        overflow: hidden;
    }
    
    /* Override for pantry item name containers - allow proper word wrapping */
    .pantry-item-card .flex-grow-1 {
        min-width: 120px !important;
        overflow: visible !important;
        max-width: 100% !important;
    }
    
    /* Ensure item names wrap at word boundaries and show full names */
    .pantry-item-card .flex-grow-1 h6.fw-bold {
        word-break: break-word !important;
        word-wrap: break-word !important;
        overflow-wrap: break-word !important;
        white-space: normal !important;
        overflow: visible !important;
        text-overflow: unset !important;
        max-width: 100% !important;
        display: block !important;
        line-height: 1.5 !important;
    }
    
    /* Recipe card improvements */
    .recipe-card {
        overflow: hidden;
    }
    
    .recipe-card .card-title {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    
    /* Fix sort dropdown on mobile */
    @media (max-width: 576px) {
        .dropdown-toggle {
            font-size: 0.875rem;
            padding: 6px 12px;
        }
        
        .card-header .d-flex {
            flex-direction: column;
            align-items: flex-start !important;
            gap: 12px;
        }
        
        .card-header .d-flex > div:last-child {
            width: 100%;
        }
    }
    
    /* Sticky Action Bar */
    .sticky-action-bar {
        position: sticky;
        top: 20px;
        z-index: 100;
        margin-bottom: 20px;
    }
    
    @media (max-width: 991px) {
        .sticky-action-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            top: auto;
            background: white;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
            padding: 12px 16px;
            border-top: 1px solid #e2e8f0;
            margin: 0;
            z-index: 1000;
            max-width: 100vw;
            box-sizing: border-box;
        }
        
        .sticky-action-bar .row {
            margin: 0;
        }
        
        .sticky-action-bar .col-6 {
            padding: 0 6px;
        }
        
        /* Add padding to body when sticky bar is visible on mobile */
        body.has-sticky-bar {
            padding-bottom: 90px;
        }
        
        /* Ensure content doesn't get hidden behind sticky bar */
        body.has-sticky-bar .container {
            padding-bottom: 20px;
        }
    }
    
    @media (max-width: 576px) {
        .sticky-action-bar {
            padding: 10px 12px;
        }
        
        .sticky-action-bar .btn {
            font-size: 0.8rem !important;
            padding: 10px 8px !important;
        }
        
        .sticky-action-bar .btn i {
            font-size: 0.9rem;
        }
        
        body.has-sticky-bar {
            padding-bottom: 85px;
        }
    }
    
    /* Smart Suggestions Banner */
    .smart-suggestions-banner {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.08) 100%);
        border-left: 4px solid #8B5CF6;
        border-radius: 12px;
        padding: 16px 20px;
        margin-bottom: 20px;
        max-width: 100%;
        overflow: hidden;
    }
    
    @media (max-width: 576px) {
        .smart-suggestions-banner {
            padding: 12px 16px;
            margin-bottom: 16px;
        }
        
        .smart-suggestions-banner h6 {
            font-size: 0.9rem;
        }
        
        .smart-suggestions-banner p {
            font-size: 0.8rem;
        }
    }
    
    /* Progress Indicator */
    .progress-indicator {
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.08) 100%);
        border-radius: 12px;
        padding: 16px 20px;
        margin-bottom: 20px;
        max-width: 100%;
        overflow: hidden;
    }
    
    @media (max-width: 576px) {
        .progress-indicator {
            padding: 12px 16px;
            margin-bottom: 16px;
        }
        
        .progress-indicator h6 {
            font-size: 0.85rem;
        }
        
        .progress-indicator p {
            font-size: 0.75rem;
        }
        
        .progress-indicator span {
            font-size: 1rem !important;
        }
    }
    
    .progress-bar-custom {
        height: 8px;
        border-radius: 10px;
        background: linear-gradient(90deg, #10B981 0%, #059669 100%);
        transition: width 0.5s ease;
    }
    
    /* Category Badge on Cards */
    .category-badge-card {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 8px;
        font-size: 0.75rem;
        font-weight: 600;
        margin-bottom: 8px;
    }
    
    /* Enhanced Expiration Badge Colors */
    .expiration-badge.expiration-expired {
        background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%) !important;
        color: white !important;
        border-color: #EF4444 !important;
    }
    
    .expiration-badge.expiration-soon {
        background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%) !important;
        color: white !important;
        border-color: #F59E0B !important;
    }
    
    .expiration-badge.expiration-fresh {
        background: linear-gradient(135deg, #10B981 0%, #059669 100%) !important;
        color: white !important;
        border-color: #10B981 !important;
    }
    
    /* Typography Hierarchy */
    .section-title {
        font-size: 1.5rem;
        font-weight: 700;
        color: #1e293b;
        margin-bottom: 1rem;
    }
    
    .section-subtitle {
        font-size: 1.1rem;
        font-weight: 600;
        color: #334155;
        margin-bottom: 0.75rem;
    }
    
    .label-text {
        font-size: 0.875rem;
        font-weight: 500;
        color: #64748b;
    }
    
    /* Achievements/Badges */
    .achievement-badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 14px;
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(217, 119, 6, 0.08) 100%);
        border: 1px solid rgba(245, 158, 11, 0.2);
        border-radius: 12px;
        font-size: 0.875rem;
        font-weight: 600;
        color: #92400E;
    }
    
    /* ============================================
       MODERN PANTRY UI - Enhanced Grid Layout
       ============================================ */
    
    /* Import distinctive font */
    @import url('https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap');
    
    /* Pantry section with elegant glassmorphism */
    .pantry-section {
        font-family: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif;
    }
    
    .pantry-header {
        background: linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #4c1d95 100%);
        border-radius: 24px 24px 0 0;
        padding: 28px 32px;
        position: relative;
        overflow: hidden;
    }
    
    .pantry-header::before {
        content: '';
        position: absolute;
        top: -50%;
        right: -20%;
        width: 300px;
        height: 300px;
        background: radial-gradient(circle, rgba(139, 92, 246, 0.3) 0%, transparent 70%);
        pointer-events: none;
    }
    
    .pantry-header::after {
        content: '';
        position: absolute;
        bottom: -30%;
        left: -10%;
        width: 200px;
        height: 200px;
        background: radial-gradient(circle, rgba(59, 130, 246, 0.25) 0%, transparent 70%);
        pointer-events: none;
    }
    
    .pantry-header h5 {
        color: #fff;
        font-weight: 800;
        font-size: 1.5rem;
        letter-spacing: -0.02em;
        position: relative;
        z-index: 1;
    }
    
    .pantry-count-badge {
        background: rgba(255, 255, 255, 0.15);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 10px 18px;
        border-radius: 14px;
        font-weight: 700;
        font-size: 0.9rem;
        position: relative;
        z-index: 1;
    }
    
    /* Modern search bar */
    .pantry-search-container {
        background: #f8fafc;
        border-radius: 16px;
        padding: 16px;
        margin-bottom: 20px;
        border: 1px solid #e2e8f0;
    }
    
    .pantry-search-input {
        background: #fff;
        border: 2px solid #e2e8f0;
        border-radius: 14px;
        padding: 14px 18px 14px 48px;
        font-size: 0.95rem;
        font-weight: 500;
        width: 100%;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        font-family: 'Plus Jakarta Sans', sans-serif;
    }
    
    .pantry-search-input:focus {
        border-color: #8B5CF6;
        box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.1);
        outline: none;
    }
    
    .pantry-search-wrapper {
        position: relative;
    }
    
    .pantry-search-icon {
        position: absolute;
        left: 16px;
        top: 50%;
        transform: translateY(-50%);
        color: #94a3b8;
        font-size: 1.1rem;
    }
    
    /* Filter chips - pill style */
    .filter-chips-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 14px;
    }
    
    .filter-chip-modern {
        background: #fff;
        border: 2px solid #e2e8f0;
        border-radius: 100px;
        padding: 8px 16px;
        font-size: 0.8rem;
        font-weight: 600;
        color: #475569;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-family: 'Plus Jakarta Sans', sans-serif;
    }
    
    .filter-chip-modern:hover {
        border-color: #8B5CF6;
        color: #8B5CF6;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.15);
    }
    
    .filter-chip-modern.active {
        background: linear-gradient(135deg, #8B5CF6 0%, #6366f1 100%);
        border-color: transparent;
        color: #fff;
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
    }
    
    .filter-chip-modern i {
        font-size: 0.85rem;
    }
    
    /* Responsive pantry grid */
    .pantry-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        padding: 0;
    }
    
    /* Keep multi-column on tablets; only collapse to 1 column on very small screens */
    @media (max-width: 991px) {
        .pantry-grid { grid-template-columns: repeat(2, 1fr); gap: 16px; }
    }
    @media (max-width: 576px) {
        .pantry-grid { grid-template-columns: 1fr; }
    }
    
    /* Modern pantry item card */
    .pantry-card-modern {
        background: #fff;
        border-radius: 20px;
        border: 1px solid #e2e8f0;
        overflow: hidden;
        transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        display: flex;
        flex-direction: column;
    }
    
    .pantry-card-modern:hover {
        transform: translateY(-6px);
        box-shadow: 0 20px 40px -12px rgba(139, 92, 246, 0.25);
        border-color: #8B5CF6;
    }
    
    /* Category indicator bar */
    .category-indicator {
        height: 5px;
        width: 100%;
        background: linear-gradient(90deg, #8B5CF6 0%, #6366f1 100%);
    }
    
    .category-indicator.category-produce { background: linear-gradient(90deg, #22c55e 0%, #16a34a 100%); }
    .category-indicator.category-dairy { background: linear-gradient(90deg, #60a5fa 0%, #3b82f6 100%); }
    .category-indicator.category-meat { background: linear-gradient(90deg, #f87171 0%, #ef4444 100%); }
    .category-indicator.category-grains { background: linear-gradient(90deg, #fbbf24 0%, #f59e0b 100%); }
    .category-indicator.category-frozen { background: linear-gradient(90deg, #67e8f9 0%, #22d3ee 100%); }
    .category-indicator.category-beverages { background: linear-gradient(90deg, #a78bfa 0%, #8b5cf6 100%); }
    .category-indicator.category-snacks { background: linear-gradient(90deg, #fb923c 0%, #f97316 100%); }
    .category-indicator.category-condiments { background: linear-gradient(90deg, #facc15 0%, #eab308 100%); }
    .category-indicator.category-bakery { background: linear-gradient(90deg, #d4a574 0%, #b8956e 100%); }
    .category-indicator.category-canned { background: linear-gradient(90deg, #94a3b8 0%, #64748b 100%); }
    
    /* Card content */
    .pantry-card-content {
        padding: 20px;
        flex: 1;
        display: flex;
        flex-direction: column;
    }
    
    /* Item header with icon */
    .item-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 16px;
        margin-bottom: 16px;
    }
    
    .item-icon-wrapper {
        width: 52px;
        height: 52px;
        border-radius: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(99, 102, 241, 0.08) 100%);
    }
    
    .item-icon-wrapper i {
        font-size: 1.5rem;
        color: #8B5CF6;
    }
    
    .item-info {
        flex: 1;
        min-width: 0;
    }
    
    .item-category-tag {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        padding: 4px 10px;
        border-radius: 6px;
        font-size: 0.7rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 8px;
        background: rgba(139, 92, 246, 0.1);
        color: #7c3aed;
    }
    
    .item-name {
        font-size: 1.1rem;
        font-weight: 700;
        color: #1e293b;
        line-height: 1.3;
        margin: 0;
        word-break: break-word;
    }
    
    /* Delete button */
    .item-delete-btn {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        border: none;
        background: rgba(239, 68, 68, 0.08);
        color: #ef4444;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        flex-shrink: 0;
    }
    
    .item-delete-btn:hover {
        background: #ef4444;
        color: #fff;
        transform: rotate(90deg) scale(1.1);
    }
    
    .item-delete-btn i {
        font-size: 1rem;
    }
    
    /* Item metadata row */
    .item-metadata {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: auto;
        padding-top: 16px;
        border-top: 1px solid #f1f5f9;
    }
    
    .metadata-badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 8px 14px;
        border-radius: 10px;
        font-size: 0.8rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: 'Plus Jakarta Sans', sans-serif;
    }
    
    .metadata-badge:hover {
        transform: scale(1.05);
    }
    
    .quantity-badge {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(99, 102, 241, 0.08) 100%);
        color: #7c3aed;
        border: 1px solid rgba(139, 92, 246, 0.2);
    }
    
    .quantity-badge:hover {
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.2) 0%, rgba(99, 102, 241, 0.15) 100%);
        border-color: #8B5CF6;
    }
    
    /* Expiration states */
    .expiration-badge-modern {
        border: 1px solid transparent;
    }
    
    .expiration-badge-modern.fresh {
        background: linear-gradient(135deg, rgba(34, 197, 94, 0.12) 0%, rgba(22, 163, 74, 0.08) 100%);
        color: #16a34a;
        border-color: rgba(34, 197, 94, 0.25);
    }
    
    .expiration-badge-modern.warning {
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.15) 0%, rgba(217, 119, 6, 0.1) 100%);
        color: #d97706;
        border-color: rgba(245, 158, 11, 0.3);
    }
    
    .expiration-badge-modern.expired {
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.15) 0%, rgba(220, 38, 38, 0.1) 100%);
        color: #dc2626;
        border-color: rgba(239, 68, 68, 0.3);
    }
    
    .expiration-badge-modern.none {
        background: #f1f5f9;
        color: #64748b;
        border-color: #e2e8f0;
    }
    
    /* Modern empty state */
    .empty-state-modern {
        padding: 60px 32px;
        text-align: center;
    }
    
    .empty-state-icon {
        width: 120px;
        height: 120px;
        margin: 0 auto 24px;
        background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(99, 102, 241, 0.1) 100%);
        border-radius: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: float 3s ease-in-out infinite;
    }
    
    @keyframes float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
    }
    
    .empty-state-icon i {
        font-size: 3.5rem;
        color: #8B5CF6;
    }
    
    .empty-state-title {
        font-size: 1.75rem;
        font-weight: 800;
        color: #1e293b;
        margin-bottom: 12px;
        font-family: 'Plus Jakarta Sans', sans-serif;
    }
    
    .empty-state-subtitle {
        font-size: 1.05rem;
        color: #64748b;
        max-width: 400px;
        margin: 0 auto 32px;
        line-height: 1.6;
    }
    
    /* Getting started steps */
    .getting-started-steps {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 16px;
        max-width: 600px;
        margin: 0 auto;
    }
    
    .step-card {
        background: #fff;
        border: 1px solid #e2e8f0;
        border-radius: 16px;
        padding: 20px;
        text-align: left;
        transition: all 0.3s ease;
    }
    
    .step-card:hover {
        border-color: #8B5CF6;
        transform: translateY(-4px);
        box-shadow: 0 12px 24px -8px rgba(139, 92, 246, 0.2);
    }
    
    .step-number {
        width: 32px;
        height: 32px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 800;
        font-size: 0.9rem;
        color: #fff;
        margin-bottom: 12px;
    }
    
    .step-card:nth-child(1) .step-number { background: linear-gradient(135deg, #8B5CF6 0%, #6366f1 100%); }
    .step-card:nth-child(2) .step-number { background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%); }
    .step-card:nth-child(3) .step-number { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }
    
    .step-title {
        font-size: 0.95rem;
        font-weight: 700;
        color: #1e293b;
        margin-bottom: 6px;
    }
    
    .step-desc {
        font-size: 0.8rem;
        color: #64748b;
        line-height: 1.5;
        margin: 0;
    }
    
    /* Sort dropdown modern */
    .sort-dropdown-modern {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 0 4px;
        margin-bottom: 20px;
    }
    
    .sort-label {
        font-size: 0.85rem;
        font-weight: 600;
        color: #64748b;
    }
    
    .sort-btn-modern {
        background: #fff;
        border: 2px solid #e2e8f0;
        border-radius: 12px;
        padding: 10px 16px;
        font-size: 0.85rem;
        font-weight: 600;
        color: #475569;
        cursor: pointer;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-family: 'Plus Jakarta Sans', sans-serif;
    }
    
    .sort-btn-modern:hover {
        border-color: #8B5CF6;
        color: #8B5CF6;
    }
    
    .sort-btn-modern::after {
        content: '';
        border: solid currentColor;
        border-width: 0 2px 2px 0;
        padding: 3px;
        transform: rotate(45deg);
        margin-left: 4px;
    }
</style>
{% endblock %}

{% block content %}
<!-- Hero Section -->
<div class="hero-section text-white py-5 mb-4">
    <div class="container">
        <div class="row align-items-center">
            <div class="col-lg-8">
                <div class="d-flex align-items-center mb-4">
                    <img src="{{ url_for('static', filename='logo.png') }}" alt="Smart Pantry" height="80" class="me-3" style="max-width: 80px;">
                    <div>
                        <h1 class="display-4 fw-bold mb-1" style="text-shadow: 0 2px 8px rgba(0,0,0,0.2);">SmartPantry</h1>
                        <p class="mb-0 opacity-90" style="font-size: 1.1rem;">Your intelligent kitchen companion</p>
                    </div>
                </div>
                {% if username %}
                    <p class="lead mb-3 opacity-95" style="font-size: 1.2rem;">Welcome back, <strong>{{ username }}</strong>!</p>
                {% endif %}
                <div class="d-flex flex-wrap gap-3 mt-4">
                    <span class="badge px-4 py-2 border-0" style="background: rgba(255,255,255,0.25); backdrop-filter: blur(10px); color: white; border-radius: 12px;">
                        <i class="bi bi-camera-fill me-2"></i>Photo Recognition
                    </span>
                    <span class="badge px-4 py-2 border-0" style="background: rgba(255,255,255,0.25); backdrop-filter: blur(10px); color: white; border-radius: 12px;">
                        <i class="bi bi-book me-2"></i>Smart Recipes
                    </span>
                    <span class="badge px-4 py-2 border-0" style="background: rgba(255,255,255,0.25); backdrop-filter: blur(10px); color: white; border-radius: 12px;">
                        <i class="bi bi-graph-up me-2"></i>Nutrition Tracking
                    </span>
                </div>
            </div>
            <div class="col-lg-4 text-center mt-4 mt-lg-0">
                <div style="width: 140px; height: 140px; background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.1) 100%); border-radius: 35px; display: flex; align-items: center; justify-content: center; margin: 0 auto; box-shadow: 0 12px 32px rgba(0,0,0,0.2); backdrop-filter: blur(10px);">
                    <i class="bi bi-house-heart" style="font-size: 4rem; opacity: 0.9;"></i>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="container py-4">
    <div class="row">
        <!-- Main Content -->
        <div class="col-lg-8">
            <!-- Smart Suggestions Banner -->
            <div id="smartSuggestionsBanner" class="smart-suggestions-banner" style="display: none;">
                <div class="d-flex align-items-center gap-3">
                    <div style="width: 48px; height: 48px; background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                        <i class="bi bi-lightbulb-fill text-white" style="font-size: 1.5rem;"></i>
                    </div>
                    <div class="flex-grow-1">
                        <h6 class="mb-1 fw-bold" style="color: #1e293b; font-size: 1rem;">Smart Suggestion</h6>
                        <p class="mb-0 text-muted small" id="suggestionText" style="font-size: 0.875rem;">Loading suggestions...</p>
                    </div>
                </div>
            </div>
            
            <!-- Progress Indicator -->
            <div id="progressIndicator" class="progress-indicator" style="display: none;">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <div>
                        <h6 class="mb-1 fw-bold" style="color: #1e293b; font-size: 0.95rem;">
                            <i class="bi bi-graph-up me-2" style="color: #10B981;"></i>Pantry Progress
                        </h6>
                        <p class="mb-0 text-muted small" id="progressText" style="font-size: 0.8rem;">0 items tracked</p>
                    </div>
                    <div class="text-end">
                        <span class="fw-bold" style="color: #10B981; font-size: 1.25rem;" id="progressPercent">0%</span>
                    </div>
                </div>
                <div style="background: #e2e8f0; border-radius: 10px; height: 8px; overflow: hidden;">
                    <div class="progress-bar-custom" id="progressBar" style="width: 0%;"></div>
                </div>
            </div>
            
            <!-- Sticky Action Bar (Desktop) -->
            <div class="sticky-action-bar d-none d-lg-block mb-4">
                <div class="card shadow-sm border-0" style="border-radius: 20px; overflow: hidden;">
                    <div class="card-body p-3">
                        <div class="row g-3">
                            <div class="col-6">
                                <button type="button" class="btn btn-primary w-100" data-bs-toggle="modal" data-bs-target="#addItemModal" style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border: none; border-radius: 12px; padding: 12px; font-weight: 600;">
                                    <i class="bi bi-plus-circle-fill me-2"></i>Add Item
                                </button>
                            </div>
                            <div class="col-6">
                                <button type="button" class="btn btn-success w-100" data-bs-toggle="modal" data-bs-target="#photoModal" style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); border: none; border-radius: 12px; padding: 12px; font-weight: 600;">
                                    <i class="bi bi-camera-fill me-2"></i>Upload Photo
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Quick Actions Card - Cleaner Design -->
            <div class="card shadow-sm border-0 mb-4 d-lg-none" style="border-radius: 20px; overflow: hidden;">
                <div class="card-body p-4">
                    <div class="row g-4">
                        <!-- Manual Add Item -->
                        <div class="col-md-6">
                            <div class="h-100 p-4" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.08) 0%, rgba(59, 130, 246, 0.05) 100%); border-radius: 18px; border: 1px solid rgba(139, 92, 246, 0.15);">
                                <div class="d-flex align-items-center mb-4">
                                    <div class="me-3" style="width: 48px; height: 48px; background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border-radius: 14px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);">
                                        <i class="bi bi-plus-circle-fill text-white" style="font-size: 1.5rem;"></i>
                                    </div>
                                    <h5 class="mb-0 fw-bold" style="color: #1e293b;">Add Items</h5>
                                </div>
                                <form action="/add" method="post" id="addItemForm" onsubmit="return handleAddItem(event);">
                                    <div class="mb-3">
                                        <label class="form-label fw-semibold small text-muted mb-2">Item Name</label>
                                        <input type="text" name="item" id="itemInput" class="form-control form-control-lg" 
                                               placeholder="e.g., Milk, Bread, Eggs" required autocomplete="off"
                                               style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 14px 16px;">
                                        <div class="row g-2 mt-2">
                                            <div class="col-6">
                                                <label class="form-label fw-semibold small text-muted mb-1">Quantity</label>
                                                <input type="number" name="quantity" id="quantityInput" class="form-control" 
                                                       placeholder="1" value="1" min="1" step="1" autocomplete="off"
                                                       style="border-radius: 10px; border: 2px solid #e2e8f0;"
                                                       oninvalid="this.setCustomValidity('Please enter a valid number (1 or greater)')"
                                                       oninput="this.setCustomValidity('')">
                                            </div>
                                            <div class="col-6">
                                                <label class="form-label fw-semibold small text-muted mb-1">Expires <span class="text-muted" style="font-weight: normal;">(optional)</span></label>
                                                <input type="date" name="expiration_date" id="expirationInput" class="form-control"
                                                       style="border-radius: 10px; border: 2px solid #e2e8f0;"
                                                       value="">
                                            </div>
                                        </div>
                                    </div>
                                    <button type="submit" class="btn btn-primary btn-lg w-100" id="addItemBtn"
                                            style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border: none; border-radius: 12px; padding: 14px; font-weight: 600; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3); transition: all 0.3s ease;">
                                        <i class="bi bi-plus-circle-fill me-2"></i><span id="addItemBtnText">Add to Pantry</span>
                                    </button>
                                </form>
                                <div id="addItemFeedback" class="mt-3" style="display: none;"></div>
                            </div>
                        </div>
                        
                        <!-- Photo Upload -->
                        <div class="col-md-6">
                            <div class="h-100 p-4" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.08) 0%, rgba(5, 150, 105, 0.05) 100%); border-radius: 18px; border: 1px solid rgba(16, 185, 129, 0.15);">
                                <div class="d-flex align-items-center mb-4">
                                    <div class="me-3" style="width: 48px; height: 48px; background: linear-gradient(135deg, #10B981 0%, #059669 100%); border-radius: 14px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);">
                                        <i class="bi bi-camera-fill text-white" style="font-size: 1.5rem;"></i>
                                    </div>
                                    <h5 class="mb-0 fw-bold" style="color: #1e293b;">Photo Upload</h5>
                                </div>
                                <p class="text-muted small mb-3">Upload a photo and let AI detect food items automatically</p>
                                <button type="button" class="btn btn-success btn-lg w-100" data-bs-toggle="modal" data-bs-target="#photoModal"
                                        style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); border: none; border-radius: 12px; padding: 14px; font-weight: 600; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); transition: all 0.3s ease;">
                                    <i class="bi bi-camera-fill me-2"></i>Take/Upload Photo
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Expiring Soon Alert Banner -->
            <div id="expiringSoonBanner" class="alert alert-warning border-0 mb-4 shadow-sm" style="display: none; border-radius: 16px; background: linear-gradient(135deg, rgba(245, 158, 11, 0.1) 0%, rgba(217, 119, 6, 0.08) 100%); border-left: 4px solid #F59E0B;">
                <div class="d-flex align-items-center gap-3">
                    <div style="width: 48px; height: 48px; background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                        <i class="bi bi-exclamation-triangle-fill text-white" style="font-size: 1.5rem;"></i>
                    </div>
                    <div class="flex-grow-1">
                        <h6 class="mb-1 fw-bold" style="color: #92400E;">
                            <i class="bi bi-clock me-2"></i>Expiring Soon
                        </h6>
                        <p class="mb-0 small" id="expiringSoonText" style="color: #78350F;">
                            You have items expiring soon. Consider using them in recipes!
                        </p>
                    </div>
                    <button type="button" class="btn btn-sm btn-outline-warning" id="filterExpiringBtn" style="border-color: #F59E0B; color: #92400E; font-weight: 600;">
                        <i class="bi bi-filter me-1"></i>View
                    </button>
                </div>
            </div>

            <!-- Pantry Overview - Modern Design -->
            <div class="card shadow-sm border-0 pantry-section" style="border-radius: 24px; overflow: visible !important; position: relative; z-index: 1;">
                <!-- Modern Gradient Header -->
                <div class="pantry-header">
                    <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                        <h5 class="mb-0 d-flex align-items-center gap-3">
                            <div style="width: 48px; height: 48px; background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); border-radius: 14px; display: flex; align-items: center; justify-content: center;">
                                <i class="bi bi-basket-fill" style="font-size: 1.5rem;"></i>
                            </div>
                            <span>Your Pantry</span>
                        </h5>
                            {% if items %}
                        <span class="pantry-count-badge">
                            <i class="bi bi-box-seam me-2"></i>{{ items|length }} {{ 'item' if items|length == 1 else 'items' }}
                            </span>
                            {% endif %}
                        </div>
                    </div>
                
                <div class="card-body p-4" style="position: relative; z-index: 5; overflow: visible; background: #fafbfc;">
                    <!-- Modern Search & Filter Section -->
                    <div class="pantry-search-container">
                        <div class="pantry-search-wrapper">
                            <i class="bi bi-search pantry-search-icon"></i>
                            <input type="text" 
                                   class="pantry-search-input" 
                                   id="searchItemsInput" 
                                   placeholder="Search your pantry..." 
                                   autocomplete="off">
                        </div>
                    </div>
                    
                    <!-- Sort Controls -->
                            {% if items is defined and items is not none and items|length > 1 %}
                    <div class="sort-dropdown-modern">
                        <span class="sort-label"><i class="bi bi-arrow-down-up me-1"></i>Sort:</span>
                            <div class="dropdown">
                            <button class="sort-btn-modern" type="button" id="sortDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                                <i class="bi bi-grid-3x3-gap-fill"></i><span id="currentSortLabel">Category</span>
                                </button>
                            <ul class="dropdown-menu" aria-labelledby="sortDropdown" style="border-radius: 14px; box-shadow: 0 12px 32px rgba(0, 0, 0, 0.12); border: 1px solid #e2e8f0; padding: 8px; z-index: 10050 !important;">
                                <li><a class="dropdown-item" href="#" onclick="sortPantry('category'); updateSortLabel('Category'); return false;" style="padding: 10px 14px; border-radius: 8px; font-weight: 600;"><i class="bi bi-grid-3x3-gap-fill me-2" style="color: #8B5CF6;"></i>Category</a></li>
                                <li><hr class="dropdown-divider" style="margin: 6px 0;"></li>
                                <li><a class="dropdown-item" href="#" onclick="sortPantry('name'); updateSortLabel('Name (A-Z)'); return false;" style="padding: 10px 14px; border-radius: 8px;"><i class="bi bi-sort-alpha-down me-2"></i>Name (A-Z)</a></li>
                                <li><a class="dropdown-item" href="#" onclick="sortPantry('name-desc'); updateSortLabel('Name (Z-A)'); return false;" style="padding: 10px 14px; border-radius: 8px;"><i class="bi bi-sort-alpha-up me-2"></i>Name (Z-A)</a></li>
                                <li><hr class="dropdown-divider" style="margin: 6px 0;"></li>
                                <li><a class="dropdown-item" href="#" onclick="sortPantry('expiration'); updateSortLabel('Expiring Soonest'); return false;" style="padding: 10px 14px; border-radius: 8px;"><i class="bi bi-calendar-check me-2"></i>Expiring Soonest</a></li>
                                <li><a class="dropdown-item" href="#" onclick="sortPantry('expiration-desc'); updateSortLabel('Expiring Latest'); return false;" style="padding: 10px 14px; border-radius: 8px;"><i class="bi bi-calendar-x me-2"></i>Expiring Latest</a></li>
                                </ul>
                            </div>
                        <div id="categoryGroupInfo" class="text-muted small ms-auto" style="display: none; color: #64748b; font-size: 0.8rem;">
                            <i class="bi bi-info-circle me-1"></i>Grouped by category
                    </div>
                </div>
                    {% endif %}
                    {% if items is defined and items is not none and items|length > 0 %}
                    <!-- Modern Pantry Grid -->
                    <div class="pantry-grid" id="pantryItemsContainer">
                        {% for item in items %}
                        {% set item_name = (item.get('name', '') if item|is_dict else (item if item else ''))|string|trim %}
                        {% set item_name = item_name if item_name else 'Unnamed Item' %}
                        {% set exp_date = (item.get('expirationDate', '') if item|is_dict else '')|string|trim %}
                        {% set quantity = (item.get('quantity', '1') if item|is_dict else '1')|string|trim %}
                        {% set quantity = quantity if quantity else '1' %}
                        {% set item_id = (item.get('id', '') if item|is_dict else '')|string|trim %}
                        {% set added_date = (item.get('addedDate', '') if item|is_dict else '')|string|trim %}
                        {% set item_category_raw = (item.get('category', 'other') if item|is_dict else 'other')|lower|trim %}
                        {% set item_category = 'meat' if item_category_raw in ['protein', 'proteins'] else item_category_raw %}
                        
                        <div class="pantry-item-wrapper" 
                             data-item-name="{{ item_name|lower|default('unnamed') }}"
                             data-item-id="{{ item_id }}"
                             data-expiration-date="{% if exp_date and exp_date|length >= 10 %}{{ exp_date[:10] }}{% elif exp_date %}{{ exp_date|trim }}{% else %}9999-12-31{% endif %}"
                             data-added-date="{% if added_date %}{{ added_date }}{% else %}{{ 'now'|date('%Y-%m-%d') }}{% endif %}">
                            
                            <!-- Modern Card Design -->
                            <div class="pantry-card-modern pantry-item-card"
                                 data-item-id="{{ item_id|default('') }}"
                                 data-item-name="{{ item_name }}"
                                 data-quantity="{{ quantity|default('1') }}"
                                 data-expiration-date="{{ exp_date if exp_date and exp_date != 'None' and exp_date != '' else '' }}"
                                 data-added-date="{{ added_date if added_date else '' }}"
                                 data-category="{{ item_category }}">
                                
                                <!-- Category Color Bar -->
                                <div class="category-indicator category-{{ item_category }}" data-category="{{ item_category }}"></div>
                                
                                <div class="pantry-card-content">
                                    <!-- Item Header -->
                                    <div class="item-header">
                                        <div class="item-icon-wrapper">
                                            {% if item_category == 'dairy' %}
                                            <i class="bi bi-cup-hot" style="color: #3B82F6;"></i>
                                            {% elif item_category == 'vegetables' or item_category == 'produce' %}
                                            <i class="bi bi-pepper-hot" style="color: #10B981;"></i>
                                            {% elif item_category == 'fruits' %}
                                            <i class="bi bi-apple" style="color: #F59E0B;"></i>
                                            {% elif item_category == 'meat' or item_category == 'proteins' %}
                                            <i class="bi bi-fire" style="color: #EF4444;"></i>
                                            {% elif item_category == 'beverages' %}
                                            <i class="bi bi-cup-straw" style="color: #06B6D4;"></i>
                                            {% elif item_category == 'bakery' %}
                                            <i class="bi bi-bread-slice" style="color: #D97706;"></i>
                                            {% elif item_category == 'canned goods' or item_category == 'canned_goods' %}
                                            <i class="bi bi-box" style="color: #8B5CF6;"></i>
                                            {% elif item_category == 'snacks' %}
                                            <i class="bi bi-cookie" style="color: #EC4899;"></i>
                                            {% elif item_category == 'condiments' %}
                                            <i class="bi bi-droplet-half" style="color: #F97316;"></i>
                                            {% elif item_category == 'grains' %}
                                            <i class="bi bi-grid-3x3" style="color: #A855F7;"></i>
                                            {% elif item_category == 'frozen' %}
                                            <i class="bi bi-snow" style="color: #06B6D4;"></i>
                                            {% else %}
                                            <i class="bi bi-box-seam-fill" style="color: #64748B;"></i>
                                            {% endif %}
                                            </div>
                                        <div class="item-info">
                                            <h6 class="item-name" title="{{ item_name }}">{{ item_name }}</h6>
                                            </div>
                                        <!-- Delete Button -->
                                        <button type="button" class="item-delete-btn delete-item-btn" 
                                                title="Remove item" 
                                                data-item-name="{{ item_name }}"
                                                data-item-id="{{ item_id|default('') }}">
                                            <i class="bi bi-trash3-fill"></i>
                                        </button>
                                            </div>
                                            
                                    <!-- Metadata Row -->
                                    <div class="item-metadata">
                                        <!-- Editable Quantity -->
                                        <span class="metadata-badge quantity-badge editable-quantity" 
                                                          data-item-id="{{ item_id|default('') }}"
                                                          data-item-name="{{ item_name }}"
                                                          data-current-quantity="{{ quantity }}"
                                                          data-expiration-date="{{ exp_date }}"
                                                          data-added-date="{{ added_date if added_date else '' }}"
                                              title="Click to edit quantity">
                                            <i class="bi bi-hash"></i>
                                            <span class="quantity-value">{{ quantity }}</span>
                                                        </span>
                                        
                                        <!-- Editable Expiration -->
                                                {% if exp_date and exp_date != 'None' and exp_date != '' %}
                                        <span class="metadata-badge expiration-badge-modern fresh editable-expiration" 
                                                              data-item-id="{{ item_id|default('') }}"
                                                              data-item-name="{{ item_name }}"
                                                              data-current-quantity="{{ quantity }}"
                                                              data-current-expiration="{{ exp_date }}"
                                                              data-added-date="{{ added_date if added_date else '' }}"
                                                              data-exp-date="{{ exp_date }}" 
                                              title="Click to edit expiration">
                                            <i class="bi bi-calendar3"></i>
                                            <span class="expiration-value">
                                                                    {% set date_str = exp_date|trim %}
                                                {% if date_str|length >= 10 %}{{ date_str[:10] }}{% else %}{{ date_str }}{% endif %}
                                                        </span>
                                                        </span>
                                                        {% else %}
                                        <span class="metadata-badge expiration-badge-modern none editable-expiration" 
                                                              data-item-id="{{ item_id|default('') }}"
                                                              data-item-name="{{ item_name }}"
                                                              data-current-quantity="{{ quantity }}"
                                                              data-current-expiration=""
                                                              data-added-date="{{ added_date if added_date else '' }}"
                                              title="Click to add expiration">
                                            <i class="bi bi-calendar-plus"></i>
                                                            <span class="expiration-value">Add Date</span>
                                                        </span>
                                            {% endif %}
                                    </div>
                                </div>
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                    {% else %}
                    <!-- Modern Empty State -->
                    <div class="empty-state-modern">
                        <div class="empty-state-icon">
                            <i class="bi bi-basket"></i>
                            </div>
                        <h3 class="empty-state-title">Your pantry is empty</h3>
                        <p class="empty-state-subtitle">Start adding items to unlock smart recipe suggestions and track expiration dates!</p>
                        
                        <!-- Getting Started Steps -->
                        <div class="getting-started-steps">
                            <div class="step-card">
                                <div class="step-number">1</div>
                                <div class="step-title">Upload or Add</div>
                                <p class="step-desc">Take a photo or add items manually to your pantry</p>
                                        </div>
                            <div class="step-card">
                                <div class="step-number">2</div>
                                <div class="step-title">Set Dates</div>
                                <p class="step-desc">Track expiration dates to reduce food waste</p>
                                    </div>
                            <div class="step-card">
                                <div class="step-number">3</div>
                                <div class="step-title">Get Recipes</div>
                                <p class="step-desc">AI-powered recipe suggestions based on your items</p>
                                </div>
                        </div>
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="col-lg-4">
            <!-- Recipe Suggestions Card -->
            <div class="card shadow-sm border-0 mb-4">
                <div class="card-header bg-gradient-success text-white border-0">
                    <h5 class="mb-0 fw-bold">
                        <i class="bi bi-book me-2"></i>Smart Recipes
                    </h5>
                </div>
                <div class="card-body text-center">
                    <div class="mb-4">
                        <div style="width: 80px; height: 80px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2) 0%, rgba(5, 150, 105, 0.2) 100%); border-radius: 20px; display: flex; align-items: center; justify-content: center; margin: 0 auto;">
                            <i class="bi bi-book" style="font-size: 2.5rem; color: #10B981;"></i>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label for="expiringDays" class="form-label text-muted small fw-semibold mb-2 d-block">
                            <i class="bi bi-clock me-1"></i>Use items expiring within:
                        </label>
                        <select class="form-select form-select-lg" id="expiringDays" style="border-radius: 12px;">
                            <option value="">All items</option>
                            <option value="3">3 days</option>
                            <option value="7">7 days</option>
                            <option value="14">14 days</option>
                            <option value="30">30 days</option>
                        </select>
                    </div>
                    <a href="{{ url_for('suggest_recipe') }}" class="btn btn-success btn-lg w-100 mb-3" id="recipeBtn" style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); border: none; border-radius: 16px; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); transition: all 0.3s ease;">
                        <i class="bi bi-stars me-2"></i>Get Recipe Ideas
                    </a>
                    <p class="text-muted small mb-0">
                        <i class="bi bi-stars me-1"></i>AI-powered recipe suggestions
                    </p>
                </div>
            </div>

            <!-- Quick Stats -->
            <div class="card shadow-sm border-0 mb-4">
                <div class="card-header bg-gradient-info text-white border-0">
                    <h5 class="mb-0 fw-bold">
                        <i class="bi bi-graph-up me-2"></i>Pantry Stats
                    </h5>
                </div>
                <div class="card-body">
                    <div class="stat-card" id="pantryStatsCard">
                        <div class="stat-number mb-2" id="pantryStatsCount">{{ items|length if items else 0 }}</div>
                        <div class="text-muted fw-semibold">Total Items</div>
                    </div>
                </div>
            </div>
            
            <!-- Achievements -->
            <div class="card shadow-sm border-0 mb-4">
                <div class="card-header bg-gradient-warning text-white border-0">
                    <h5 class="mb-0 fw-bold">
                        <i class="bi bi-trophy-fill me-2"></i>Achievements
                    </h5>
                </div>
                <div class="card-body">
                    <div id="achievementsList">
                        {% if items and items|length > 0 %}
                        <div class="achievement-badge mb-2 w-100">
                            <i class="bi bi-trophy-fill" style="color: #F59E0B;"></i>
                            <span> First Item Added</span>
                        </div>
                        {% endif %}
                        {% if items and items|length >= 5 %}
                        <div class="achievement-badge mb-2 w-100">
                            <i class="bi bi-star-fill" style="color: #F59E0B;"></i>
                            <span> Growing Pantry (5+ items)</span>
                        </div>
                        {% endif %}
                        {% if items and items|length >= 10 %}
                        <div class="achievement-badge mb-2 w-100">
                            <i class="bi bi-award-fill" style="color: #F59E0B;"></i>
                            <span> Pantry Master (10+ items)</span>
                        </div>
                        {% endif %}
                        {% if not items or items|length == 0 %}
                        <p class="text-muted small mb-0 text-center">Start adding items to unlock achievements!</p>
                        {% endif %}
                    </div>
                </div>
            </div>

            <!-- Quick Tips -->
            <div class="card shadow-sm border-0">
                <div class="card-header bg-gradient-warning text-dark border-0">
                    <h5 class="mb-0 fw-bold">
                        <i class="bi bi-info-circle-fill me-2"></i>Pro Tips
                    </h5>
                </div>
                <div class="card-body">
                    <div class="d-flex mb-3 pb-3" style="border-bottom: 1px solid rgba(0,0,0,0.05);">
                        <div class="me-3" style="width: 32px; height: 32px; background: rgba(16, 185, 129, 0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <i class="bi bi-check-circle-fill text-success"></i>
                        </div>
                        <div>
                            <strong class="d-block mb-1">Smart Upload</strong>
                            <small class="text-muted">Use clear, well-lit photos for better AI recognition</small>
                        </div>
                    </div>
                    <div class="d-flex mb-3 pb-3" style="border-bottom: 1px solid rgba(0,0,0,0.05);">
                        <div class="me-3" style="width: 32px; height: 32px; background: rgba(139, 92, 246, 0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <i class="bi bi-stars text-primary"></i>
                        </div>
                        <div>
                            <strong class="d-block mb-1">Recipe Magic</strong>
                            <small class="text-muted">More items = better recipe suggestions</small>
                        </div>
                    </div>
                    <div class="d-flex">
                        <div class="me-3" style="width: 32px; height: 32px; background: rgba(59, 130, 246, 0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                            <i class="bi bi-graph-up-arrow text-info"></i>
                        </div>
                        <div>
                            <strong class="d-block mb-1">Nutrition Tracking</strong>
                            <small class="text-muted">Get detailed nutrition info for your recipes</small>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add Item Modal -->
<div class="modal" id="addItemModal" tabindex="-1" aria-labelledby="addItemModalLabel" aria-hidden="true" data-bs-backdrop="false" data-bs-keyboard="true" role="dialog" aria-modal="true">
    <div class="modal-dialog modal-dialog-centered" style="max-height: 90vh;">
        <div class="modal-content" style="border-radius: 16px; border: none; position: relative; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.25);">
            <div class="modal-header border-0">
                <h5 class="modal-title fw-bold" id="addItemModalLabel">
                    <i class="bi bi-plus-circle-fill me-2"></i>Add Item to Pantry
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body p-4" style="background: #f8f9fa;">
                <form action="/add" method="post" id="addItemModalForm" onsubmit="return handleAddItem(event);">
                    <div class="mb-4">
                        <label class="form-label fw-semibold mb-2" style="color: #1e293b; font-size: 0.95rem;">
                            <i class="bi bi-box-seam me-2" style="color: #8B5CF6;"></i>Item Name <span class="text-danger">*</span>
                        </label>
                        <input type="text" name="item" id="addItemModalInput" class="form-control form-control-lg" 
                               placeholder="e.g., Milk, Bread, Eggs" required autocomplete="off"
                               style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 14px 16px; font-size: 1rem; transition: all 0.2s ease;"
                               onfocus="this.style.borderColor='#8B5CF6'; this.style.boxShadow='0 0 0 3px rgba(139, 92, 246, 0.1)';"
                               onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none';">
                    </div>
                    <div class="row g-3 mb-4">
                        <div class="col-6">
                            <label class="form-label fw-semibold mb-2" style="color: #1e293b; font-size: 0.95rem;">
                                <i class="bi bi-123 me-2" style="color: #8B5CF6;"></i>Quantity
                            </label>
                            <input type="number" name="quantity" id="addItemModalQuantity" class="form-control" 
                                   placeholder="1" value="1" min="1" autocomplete="off"
                                   style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 12px 14px; transition: all 0.2s ease;"
                                   onfocus="this.style.borderColor='#8B5CF6'; this.style.boxShadow='0 0 0 3px rgba(139, 92, 246, 0.1)';"
                                   onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none';">
                        </div>
                        <div class="col-6">
                            <label class="form-label fw-semibold mb-2" style="color: #1e293b; font-size: 0.95rem;">
                                <i class="bi bi-calendar-event me-2" style="color: #8B5CF6;"></i>Expires
                                <span class="text-muted" style="font-weight: normal; font-size: 0.85rem;">(optional)</span>
                            </label>
                            <input type="date" name="expiration_date" id="addItemModalExpiration" class="form-control"
                                   style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 12px 14px; transition: all 0.2s ease;"
                                   onfocus="this.style.borderColor='#8B5CF6'; this.style.boxShadow='0 0 0 3px rgba(139, 92, 246, 0.1)';"
                                   onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none';"
                                   value="">
                        </div>
                    </div>
                    <div id="addItemModalFeedback" class="mt-3" style="display: none;"></div>
                    <div class="d-flex gap-2 mt-4 pt-3" style="border-top: 1px solid #e2e8f0;">
                        <button type="button" class="btn btn-outline-secondary flex-fill" data-bs-dismiss="modal"
                                style="border-radius: 12px; padding: 12px; font-weight: 600; border: 2px solid #e2e8f0; transition: all 0.2s ease;"
                                onmouseover="this.style.borderColor='#cbd5e1'; this.style.backgroundColor='#f1f5f9';"
                                onmouseout="this.style.borderColor='#e2e8f0'; this.style.backgroundColor='transparent';">
                            <i class="bi bi-x-circle me-2"></i>Cancel
                        </button>
                        <button type="submit" class="btn btn-primary flex-fill" id="addItemModalBtn"
                                style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border: none; border-radius: 12px; padding: 12px; font-weight: 600; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3); transition: all 0.2s ease;"
                                onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 6px 16px rgba(139, 92, 246, 0.4)';"
                                onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(139, 92, 246, 0.3)';">
                            <i class="bi bi-plus-circle-fill me-2"></i><span id="addItemModalBtnText">Add to Pantry</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Edit Item Modal -->
<div class="modal" id="editItemModal" tabindex="-1" aria-labelledby="editItemModalLabel" aria-hidden="true" data-bs-backdrop="false" data-bs-keyboard="true" role="dialog" aria-modal="true">
    <div class="modal-dialog modal-dialog-centered" style="max-height: 90vh;">
        <div class="modal-content" style="border-radius: 16px; border: none; position: relative; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.25);">
            <div class="modal-header border-0">
                <h5 class="modal-title fw-bold" id="editItemModalLabel">
                    <i class="bi bi-pencil-square me-2"></i>Edit Item
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body p-4" style="background: #f8f9fa;">
                <form id="editItemModalForm" onsubmit="return handleEditItemSubmit(event);">
                    <input type="hidden" id="editItemId" name="item_id">
                    <input type="hidden" id="editItemAddedDate" name="added_date">
                    
                    <div class="mb-4">
                        <label class="form-label fw-semibold mb-2" style="color: #1e293b; font-size: 0.95rem;">
                            <i class="bi bi-box-seam me-2" style="color: #8B5CF6;"></i>Item Name <span class="text-danger">*</span>
                        </label>
                        <input type="text" name="item_name" id="editItemName" class="form-control form-control-lg" 
                               placeholder="e.g., Milk, Bread, Eggs" required autocomplete="off"
                               style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 14px 16px; font-size: 1rem; transition: all 0.2s ease;"
                               onfocus="this.style.borderColor='#8B5CF6'; this.style.boxShadow='0 0 0 3px rgba(139, 92, 246, 0.1)';"
                               onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none';">
                    </div>
                    <div class="row g-3 mb-4">
                        <div class="col-6">
                            <label class="form-label fw-semibold mb-2" style="color: #1e293b; font-size: 0.95rem;">
                                <i class="bi bi-123 me-2" style="color: #8B5CF6;"></i>Quantity
                            </label>
                            <input type="number" name="quantity" id="editItemQuantity" class="form-control" 
                                   placeholder="1" value="1" min="1" autocomplete="off"
                                   style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 12px 14px; transition: all 0.2s ease;"
                                   onfocus="this.style.borderColor='#8B5CF6'; this.style.boxShadow='0 0 0 3px rgba(139, 92, 246, 0.1)';"
                                   onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none';">
                        </div>
                        <div class="col-6">
                            <label class="form-label fw-semibold mb-2" style="color: #1e293b; font-size: 0.95rem;">
                                <i class="bi bi-calendar-event me-2" style="color: #8B5CF6;"></i>Expires
                                <span class="text-muted" style="font-weight: normal; font-size: 0.85rem;">(optional)</span>
                            </label>
                            <input type="date" name="expiration_date" id="editItemExpiration" class="form-control"
                                   style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 12px 14px; transition: all 0.2s ease;"
                                   onfocus="this.style.borderColor='#8B5CF6'; this.style.boxShadow='0 0 0 3px rgba(139, 92, 246, 0.1)';"
                                   onblur="this.style.borderColor='#e2e8f0'; this.style.boxShadow='none';">
                        </div>
                    </div>
                    
                    <div class="d-flex gap-2 mt-4">
                        <button type="button" class="btn btn-secondary flex-fill" data-bs-dismiss="modal" style="border-radius: 12px; padding: 12px; font-weight: 600;">
                            <i class="bi bi-x-circle me-2"></i>Cancel
                        </button>
                        <button type="submit" class="btn btn-primary flex-fill" id="editItemSaveBtn" style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border: none; border-radius: 12px; padding: 12px; font-weight: 600; box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);">
                            <i class="bi bi-check-circle me-2"></i>Save Changes
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Photo Upload Modal -->
<div class="modal" id="photoModal" tabindex="-1" aria-labelledby="photoModalLabel" aria-hidden="true" data-bs-backdrop="true" data-bs-keyboard="true" role="dialog" aria-modal="true">
    <div class="modal-dialog modal-dialog-centered" style="max-height: 90vh;">
        <div class="modal-content" style="border-radius: 16px; border: none; position: relative; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 50px rgba(0, 0, 0, 0.25);">
            <div class="modal-header border-0" style="pointer-events: auto;">
                <h5 class="modal-title fw-bold" id="photoModalLabel">
                    <i class="bi bi-camera-fill me-2"></i>Add Items with Photo
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body p-4" style="background: #f8f9fa;">
                <!-- Guided Scan Mode Banner -->
                <div id="guidedScanBanner" class="alert alert-info mb-3" style="display: none; border-radius: 12px; background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); color: white; border: none;">
                    <div class="d-flex align-items-start gap-2">
                        <i class="bi bi-lightbulb-fill" style="font-size: 1.5rem; margin-top: 2px;"></i>
                        <div style="flex: 1;">
                            <h6 class="fw-bold mb-2" style="color: white;"> Guided Fridge Scan Mode</h6>
                            <ul class="mb-0 small" style="padding-left: 20px;">
                                <li>Scan <strong>one shelf at a time</strong> for best accuracy</li>
                                <li>Use the <strong>grid overlay</strong> to align your photo</li>
                                <li>Ensure <strong>good lighting</strong> - avoid shadows</li>
                                <li>Wait for <strong>quality check</strong> before analyzing</li>
                            </ul>
                        </div>
                        <button type="button" class="btn-close btn-close-white" onclick="document.getElementById('guidedScanBanner').style.display='none';" aria-label="Close"></button>
                    </div>
                </div>
                
                <!-- Scan Quality Indicator -->
                <div id="scanQualityIndicator" class="mb-3" style="display: none;">
                    <div class="d-flex align-items-center gap-2 p-3 rounded" style="background: #f8f9fa; border: 2px solid #e2e8f0;">
                        <i id="qualityIcon" class="bi" style="font-size: 1.5rem;"></i>
                        <div style="flex: 1;">
                            <h6 class="mb-1 fw-bold">Scan Quality: <span id="qualityScoreText">Checking...</span></h6>
                            <p id="qualityMessage" class="mb-0 small text-muted"></p>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-primary" id="retakePhotoBtn" style="display: none;">
                            <i class="bi bi-arrow-clockwise me-1"></i>Retake
                        </button>
                    </div>
                </div>
                
                <!-- Camera View (Hidden by default) -->
                <div id="cameraView" class="camera-preview mb-3" style="display: none; position: relative;">
                    <!-- Grid Overlay for Alignment -->
                    <div id="gridOverlay" class="grid-overlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;">
                        <svg width="100%" height="100%" style="position: absolute; top: 0; left: 0;">
                            <!-- Vertical lines -->
                            <line x1="33.33%" y1="0" x2="33.33%" y2="100%" stroke="rgba(139, 92, 246, 0.5)" stroke-width="2"/>
                            <line x1="66.66%" y1="0" x2="66.66%" y2="100%" stroke="rgba(139, 92, 246, 0.5)" stroke-width="2"/>
                            <!-- Horizontal lines -->
                            <line x1="0" y1="33.33%" x2="100%" y2="33.33%" stroke="rgba(139, 92, 246, 0.5)" stroke-width="2"/>
                            <line x1="0" y1="66.66%" x2="100%" y2="66.66%" stroke="rgba(139, 92, 246, 0.5)" stroke-width="2"/>
                        </svg>
                        <div class="text-center p-2" style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(139, 92, 246, 0.9); color: white; border-radius: 8px; font-size: 0.75rem; font-weight: 600;">
                             Use grid to align shelf
                        </div>
                    </div>
                    
                    <!-- Camera Status Messages -->
                    <div id="cameraStatus" class="camera-status-message" style="display: none;">
                        <div class="d-flex align-items-center justify-content-center gap-2 p-3">
                            <div class="spinner-border spinner-border-sm text-primary" role="status" id="cameraStatusSpinner">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <span id="cameraStatusText" class="fw-semibold"> Camera initializing...</span>
                        </div>
                    </div>
                    
                    <!-- Camera Error Message -->
                    <div id="cameraError" class="camera-error-message" style="display: none;">
                        <div class="p-3 text-center">
                            <i class="bi bi-exclamation-triangle-fill text-warning" style="font-size: 2rem;"></i>
                            <h6 class="mt-2 mb-2 fw-bold" id="cameraErrorTitle">Camera Error</h6>
                            <p class="mb-2 small text-muted" id="cameraErrorMessage">Could not access camera.</p>
                            <button type="button" class="btn btn-sm btn-primary" id="retryCameraBtn">
                                <i class="bi bi-arrow-clockwise me-1"></i>Retry
                            </button>
                        </div>
                    </div>
                    
                    <!-- Camera Video Stream -->
                    <video id="cameraStream" autoplay playsinline style="display: none;"></video>
                    
                    <!-- Camera Ready Indicator -->
                    <div id="cameraReadyIndicator" class="camera-ready-indicator" style="display: none;">
                        <div class="d-flex align-items-center justify-content-center gap-2 p-2">
                            <i class="bi bi-check-circle-fill text-success"></i>
                            <span class="fw-semibold small"> Ready to take photo</span>
                        </div>
                    </div>
                    
                    <div class="camera-controls">
                        <button type="button" class="btn btn-light btn-sm me-2" id="closeCameraBtn">
                            <i class="bi bi-x-lg"></i> Close
                        </button>
                        <button type="button" class="capture-btn" id="captureBtn" title="Capture Photo" style="display: none;"></button>
                        <button type="button" class="btn btn-sm btn-outline-primary" id="testCameraBtn" style="display: none;">
                            <i class="bi bi-camera-video me-1"></i>Test Camera
                        </button>
                    </div>
                    
                    <!-- Camera Tips -->
                    <div class="camera-tips mt-2 p-2" style="background: rgba(139, 92, 246, 0.05); border-radius: 8px; font-size: 0.75rem; color: #64748b;">
                        <i class="bi bi-lightbulb me-1"></i>
                        <strong>Tips:</strong> Ensure good lighting  Close other apps using the camera (Zoom, Meet, Discord)
                    </div>
                </div>

                <!-- Upload Zone -->
                <div id="uploadZone">
                    <!-- Toggle: Take Photo vs Upload Image -->
                    <div class="btn-group w-100 mb-4" role="group" style="border-radius: 12px; overflow: hidden; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);">
                        <button type="button" class="btn photo-toggle-btn active" id="takePhotoToggle" style="flex: 1; border: none; padding: 12px; font-weight: 600; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; transition: all 0.2s ease;">
                            <i class="bi bi-camera-fill me-2"></i> Take Photo
                        </button>
                        <button type="button" class="btn photo-toggle-btn" id="uploadImageToggle" style="flex: 1; border: none; padding: 12px; font-weight: 600; background: #f8f9fa; color: #64748b; transition: all 0.2s ease;">
                            <i class="bi bi-image me-2"></i> Upload Image
                        </button>
                    </div>
                    
                    <!-- Take Photo Section -->
                    <div id="takePhotoSection" class="photo-section">
                        <div class="text-center mb-4">
                            <div class="mb-3">
                                <i class="bi bi-camera-fill" style="font-size: 3rem; color: #10b981; opacity: 0.7;"></i>
                            </div>
                            <h6 class="mb-3" style="color: #1e293b; font-weight: 600;">Choose how to capture your photo</h6>
                        </div>
                        <div class="d-grid gap-2">
                            <button type="button" class="btn btn-success btn-lg photo-modal-btn" id="mobileCameraBtn" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; color: white; padding: 14px; font-weight: 600; border-radius: 12px; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);">
                                <i class="bi bi-camera-fill me-2"></i>Take Photo with Camera
                            </button>
                            <button type="button" class="btn btn-outline-success photo-modal-btn" id="openCameraBtn" style="border: 2px solid #10b981; color: #10b981; background: white; padding: 12px; font-weight: 600; border-radius: 12px; transition: all 0.2s ease;">
                                <i class="bi bi-camera-video me-2"></i>Use Live Camera Preview
                            </button>
                        </div>
                        <label for="mobileCameraInput" class="visually-hidden">Take photo with camera</label>
                        <input type="file" id="mobileCameraInput" accept="image/*" capture="environment" style="position: absolute; width: 1px; height: 1px; opacity: 0; overflow: hidden; pointer-events: none;">
                        
                        <!-- Detection Method Selection -->
                        <div class="mt-4 p-3" style="background: rgba(59, 130, 246, 0.05); border-radius: 12px; border: 1px solid rgba(59, 130, 246, 0.15);">
                            <label class="form-label fw-semibold mb-2" style="color: #1e293b;">
                                <i class="bi bi-cpu me-2"></i>Detection Method
                            </label>
                            <div class="form-check mb-2">
                                <input class="form-check-input" type="radio" name="detection_method_modal" id="method_ml_modal_take" value="ml" checked>
                                <label class="form-check-label" for="method_ml_modal_take">
                                    <strong>My ML Model</strong> (Fast, Free, Local)
                                    <small class="text-muted d-block ms-4">Uses YOLO + CLIP + OCR for detection</small>
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="detection_method_modal" id="method_openai_modal_take" value="openai">
                                <label class="form-check-label" for="method_openai_modal_take">
                                    <strong>ChatGPT/OpenAI</strong> (More Accurate, Uses API Credits)
                                    <small class="text-muted d-block ms-4">Uses GPT-4 Vision for advanced recognition</small>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Upload Image Section -->
                    <div id="uploadImageSection" class="photo-section" style="display: none;">
                    <div class="photo-upload-zone" id="dropZone">
                        <i class="bi bi-cloud-upload display-1 text-muted mb-3"></i>
                        <h5 class="mb-2">Drag & Drop Photo Here</h5>
                        <p class="text-muted mb-3">or click to browse</p>
                            <button type="button" class="btn btn-primary photo-modal-btn" id="browseBtn" style="background: #3b82f6; border: 2px solid #3b82f6; color: white; transition: all 0.2s ease; will-change: auto;">
                            <i class="bi bi-folder2-open me-2"></i>Browse Files
                        </button>
                            <label for="photoInput" class="visually-hidden">Select photo file</label>
                            <input type="file" id="photoInput" accept="image/*" style="position: absolute; width: 1px; height: 1px; opacity: 0; overflow: hidden; pointer-events: none;">
                        </div>
                        
                        <!-- Detection Method Selection -->
                        <div class="mt-4 p-3" style="background: rgba(59, 130, 246, 0.05); border-radius: 12px; border: 1px solid rgba(59, 130, 246, 0.15);">
                            <label class="form-label fw-semibold mb-2" style="color: #1e293b;">
                                <i class="bi bi-cpu me-2"></i>Detection Method
                            </label>
                            <div class="form-check mb-2">
                                <input class="form-check-input" type="radio" name="detection_method_modal" id="method_ml_modal_upload" value="ml" checked>
                                <label class="form-check-label" for="method_ml_modal_upload">
                                    <strong>My ML Model</strong> (Fast, Free, Local)
                                    <small class="text-muted d-block ms-4">Uses YOLO + CLIP + OCR for detection</small>
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="detection_method_modal" id="method_openai_modal_upload" value="openai">
                                <label class="form-check-label" for="method_openai_modal_upload">
                                    <strong>ChatGPT/OpenAI</strong> (More Accurate, Uses API Credits)
                                    <small class="text-muted d-block ms-4">Uses GPT-4 Vision for advanced recognition</small>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Preview & Upload Section (Hidden by default) -->
                <div id="previewSection" style="display: none; position: relative; z-index: 1000; pointer-events: auto;">
                    <div class="text-center" style="position: relative; z-index: 1001; pointer-events: auto;">
                        <!-- Upload Progress Feedback -->
                        <div id="uploadProgressFeedback" class="mb-3" style="display: none;">
                            <div class="d-flex align-items-center justify-content-center gap-2 p-3" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.08) 100%); border-radius: 12px; border-left: 4px solid #10B981;">
                                <i class="bi bi-check-circle-fill" style="color: #10B981; font-size: 1.25rem;"></i>
                                <span class="fw-semibold" style="color: #1e293b;" id="progressFeedbackText">Ready to analyze</span>
                            </div>
                        </div>
                        
                        <!-- Loading/Feedback Message -->
                        <div id="uploadFeedback" class="feedback-message" style="display: none;"></div>
                        
                        <!-- Preview with Remove Button - Fixed height to prevent layout shift -->
                        <div class="position-relative d-inline-block mb-4" style="min-height: 300px; width: 100%; display: flex; align-items: center; justify-content: center;">
                            <div style="position: relative; max-width: 100%; width: 100%;">
                                <img id="imagePreview" class="image-preview" alt="Preview" style="max-width: 100%; max-height: 400px; width: auto; height: auto; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); display: none; margin: 0 auto;">
                                <!-- Placeholder to prevent layout shift -->
                                <div id="imagePreviewPlaceholder" style="width: 100%; height: 300px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.05) 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; border: 2px dashed rgba(16, 185, 129, 0.3);">
                                    <div class="text-center">
                                        <i class="bi bi-image text-muted" style="font-size: 3rem; opacity: 0.3;"></i>
                                        <p class="text-muted small mt-2 mb-0">Photo preview will appear here</p>
                                    </div>
                                </div>
                            </div>
                            <button type="button" class="btn btn-danger btn-sm" id="removePreviewBtn" style="position: absolute; top: 8px; right: 8px; width: 36px; height: 36px; border-radius: 50%; padding: 0; display: none; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); z-index: 10;" title="Retake photo">
                                <i class="bi bi-arrow-counterclockwise"></i>
                            </button>
                        </div>
                        
                        <div class="alert alert-info border-0 mb-3" style="background: rgba(59, 130, 246, 0.08); border-left: 3px solid #3B82F6; border-radius: 10px;">
                            <i class="bi bi-info-circle me-2"></i>
                            <small style="color: #1e40af;">Review your photo. Click "Analyze & Add Items" to continue, or "Retake" to capture another photo.</small>
                        </div>
                        
                        <div class="mt-3 d-flex flex-wrap justify-content-center gap-2" style="position: relative; z-index: 1000; pointer-events: auto;">
                            <button type="button" class="btn btn-outline-secondary photo-modal-btn" id="retakePhotoBtn" style="border: 2px solid #6b7280; color: #6b7280; background: transparent; transition: all 0.2s ease; position: relative; z-index: 1001; pointer-events: auto; cursor: pointer;">
                                <i class="bi bi-arrow-counterclockwise me-2"></i>Retake
                            </button>
                            <button type="button" class="btn btn-outline-danger photo-modal-btn" id="cancelUploadBtn" style="border: 2px solid #ef4444; color: #ef4444; background: transparent; transition: all 0.2s ease; position: relative; z-index: 1001; pointer-events: auto; cursor: pointer;">
                                <i class="bi bi-x-circle me-2"></i>Cancel
                            </button>
                            <button type="button" class="btn btn-success btn-lg photo-modal-btn" id="uploadBtn" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; color: white; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3); position: relative; z-index: 1001; pointer-events: auto; cursor: pointer;">
                                <i class="bi bi-stars me-2"></i><span id="uploadBtnText">Confirm & Analyze</span>
                            </button>
                        </div>
                        <small class="text-muted d-block mt-2">AI will detect food items in your photo</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // Global error handler to catch and log JavaScript errors
    window.addEventListener('error', function(e) {
        console.error('JavaScript Error:', e.message, 'at', e.filename, ':', e.lineno);
        console.error('Stack:', e.error?.stack);
    });
    
    // Handle unhandled promise rejections
    window.addEventListener('unhandledrejection', function(e) {
        console.error('Unhandled Promise Rejection:', e.reason);
        e.preventDefault(); // Prevent default browser behavior
    });
    
    // Ensure all critical functions are available
    console.log('Initializing SmartPantry JavaScript...');
    
    let selectedFile = null;
    let cameraStream = null;
    
    // Request timeout helper with AbortController
    const REQUEST_TIMEOUT_MS = 30000; // 30 seconds default timeout
    const UPLOAD_TIMEOUT_MS = 60000; // 60 seconds for uploads
    
    function fetchWithTimeout(url, options = {}, timeoutMs = REQUEST_TIMEOUT_MS) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
        
        return fetch(url, {
            ...options,
            signal: controller.signal
        }).finally(() => clearTimeout(timeoutId));
    }
    
    // Retry helper for failed requests
    async function fetchWithRetry(url, options = {}, maxRetries = 3, retryDelay = 1000) {
        let lastError = null;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const response = await fetchWithTimeout(url, options);
                return response;
            } catch (error) {
                lastError = error;
                if (error.name === 'AbortError') {
                    console.warn(`Request to ${url} timed out (attempt ${attempt}/${maxRetries})`);
                } else {
                    console.warn(`Request to ${url} failed (attempt ${attempt}/${maxRetries}):`, error.message);
                }
                if (attempt < maxRetries) {
                    await new Promise(resolve => setTimeout(resolve, retryDelay * attempt));
                }
            }
        }
        throw lastError || new Error('All retry attempts failed');
    }
    
    // Safe DOM query helper
    function safeQuerySelector(selector, parent = document) {
        try {
            return parent.querySelector(selector);
        } catch (e) {
            console.warn(`Failed to query selector: ${selector}`, e);
            return null;
        }
    }
    
    // Safe element property setter
    function safeSetProperty(element, property, value) {
        if (element && element[property] !== undefined) {
            element[property] = value;
            return true;
        }
        return false;
    }

    // DOM Elements
    const photoModal = document.getElementById('photoModal');
    const photoInput = document.getElementById('photoInput');
    const mobileCameraInput = document.getElementById('mobileCameraInput');
    const dropZone = document.getElementById('dropZone');
    const browseBtn = document.getElementById('browseBtn');
    const mobileCameraBtn = document.getElementById('mobileCameraBtn');
    const uploadZone = document.getElementById('uploadZone');
    const previewSection = document.getElementById('previewSection');
    const imagePreview = document.getElementById('imagePreview');
    const uploadBtn = document.getElementById('uploadBtn');
    const cancelUploadBtn = document.getElementById('cancelUploadBtn');
    const uploadBtnText = document.getElementById('uploadBtnText');
    
    // Camera Elements
    const cameraView = document.getElementById('cameraView');
    const cameraStreamVideo = document.getElementById('cameraStream');
    const openCameraBtn = document.getElementById('openCameraBtn');
    const closeCameraBtn = document.getElementById('closeCameraBtn');
    const captureBtn = document.getElementById('captureBtn');
    const cameraStatus = document.getElementById('cameraStatus');
    const cameraStatusText = document.getElementById('cameraStatusText');
    const cameraError = document.getElementById('cameraError');
    const cameraErrorTitle = document.getElementById('cameraErrorTitle');
    const cameraErrorMessage = document.getElementById('cameraErrorMessage');
    const cameraReadyIndicator = document.getElementById('cameraReadyIndicator');
    const retryCameraBtn = document.getElementById('retryCameraBtn');
    const testCameraBtn = document.getElementById('testCameraBtn');

    // Photo Toggle Functionality
    const takePhotoToggle = document.getElementById('takePhotoToggle');
    const uploadImageToggle = document.getElementById('uploadImageToggle');
    const takePhotoSection = document.getElementById('takePhotoSection');
    const uploadImageSection = document.getElementById('uploadImageSection');
    
    if (takePhotoToggle && uploadImageToggle && takePhotoSection && uploadImageSection) {
        takePhotoToggle.addEventListener('click', () => {
            takePhotoToggle.classList.add('active');
            takePhotoToggle.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            takePhotoToggle.style.color = 'white';
            uploadImageToggle.classList.remove('active');
            uploadImageToggle.style.background = '#f8f9fa';
            uploadImageToggle.style.color = '#64748b';
            takePhotoSection.style.display = 'block';
            uploadImageSection.style.display = 'none';
        });
        
        uploadImageToggle.addEventListener('click', () => {
            uploadImageToggle.classList.add('active');
            uploadImageToggle.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            uploadImageToggle.style.color = 'white';
            takePhotoToggle.classList.remove('active');
            takePhotoToggle.style.background = '#f8f9fa';
            takePhotoToggle.style.color = '#64748b';
            takePhotoSection.style.display = 'none';
            uploadImageSection.style.display = 'block';
        });
    }
    
    // Browse button click - ensure it works properly
    if (browseBtn && photoInput) {
        browseBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Add visual feedback
            const originalText = browseBtn.innerHTML;
            browseBtn.disabled = true;
            browseBtn.style.opacity = '0.7';
            browseBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Opening...';
            
            // Trigger file input
            try {
                photoInput.click();
            } catch (error) {
                console.error('Error triggering file input:', error);
                // Reset button on error
                browseBtn.disabled = false;
                browseBtn.style.opacity = '1';
                browseBtn.innerHTML = originalText;
            }
            
            // Reset button after a short delay
            setTimeout(() => {
                if (browseBtn) {
                    browseBtn.disabled = false;
                    browseBtn.style.opacity = '1';
                    browseBtn.innerHTML = originalText;
                }
            }, 500);
        });
    }

    // Mobile camera button (works without HTTPS)
    if (mobileCameraBtn && mobileCameraInput) {
        mobileCameraBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (mobileCameraInput) {
                mobileCameraInput.click();
            }
        });
    }

    // File input change handlers with error handling
    if (photoInput) {
        photoInput.addEventListener('change', function(e) {
            try {
                handleFileSelect(e);
            } catch (error) {
                console.error('Error handling file select:', error);
                alert('Error selecting file. Please try again.');
            }
        });
    }
    if (mobileCameraInput) {
        mobileCameraInput.addEventListener('change', function(e) {
            try {
                handleFileSelect(e);
            } catch (error) {
                console.error('Error handling mobile camera file select:', error);
                alert('Error selecting file. Please try again.');
            }
        });
    }

    // Drag and drop handlers with better feedback
    if (dropZone) {
        let dragCounter = 0;
        
        dropZone.addEventListener('dragenter', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragCounter++;
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragCounter--;
            if (dragCounter === 0) {
            dropZone.classList.remove('dragover');
            }
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragCounter = 0;
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        // Click anywhere in drop zone to open file picker
        dropZone.addEventListener('click', (e) => {
            // Don't trigger if clicking the browse button (it has its own handler)
            if (e.target.closest('#browseBtn')) {
                return;
            }
            // Don't trigger if clicking file inputs
            if (e.target === photoInput || e.target === mobileCameraInput) {
                return;
            }
            e.preventDefault();
            e.stopPropagation();
                if (photoInput) {
                    photoInput.click();
            }
        });
    }

    // Handle file selection
    function handleFileSelect(e) {
        const files = e.target.files;
        if (files.length > 0) {
            // Show feedback that file is being processed
            const progressFeedback = document.getElementById('uploadProgressFeedback');
            const progressFeedbackText = document.getElementById('progressFeedbackText');
            if (progressFeedback && progressFeedbackText) {
                progressFeedback.style.display = 'block';
                progressFeedbackText.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Processing image...';
            }
            handleFile(files[0]);
        } else {
            // Reset feedback if no file selected
            const progressFeedback = document.getElementById('uploadProgressFeedback');
            if (progressFeedback) {
                progressFeedback.style.display = 'none';
            }
        }
    }

    // Compress image function
    async function compressImage(file, maxWidth = 1280, maxHeight = 1280, quality = 0.6) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    // Calculate new dimensions
                    if (width > maxWidth || height > maxHeight) {
                        const ratio = Math.min(maxWidth / width, maxHeight / height);
                        width = Math.round(width * ratio);
                        height = Math.round(height * ratio);
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to blob with compression
                    canvas.toBlob((blob) => {
                        if (blob) {
                            const compressedFile = new File([blob], file.name, { type: 'image/jpeg' });
                            resolve(compressedFile);
                        } else {
                            reject(new Error('Compression failed'));
                        }
                    }, 'image/jpeg', quality);
                };
                img.onerror = reject;
                img.src = e.target.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    // Handle file with validation
    async function handleFile(file) {
        // Validate file exists
        if (!file) {
            showFeedback('No file selected. Please try again.', 'warning');
            return;
        }
        
        // Validate file type
        if (!file.type.startsWith('image/')) {
            showFeedback(' Please select an image file (JPG, PNG, etc.)', 'danger');
            return;
        }
        
        // Validate file size (max 10MB)
        const maxSize = 10 * 1024 * 1024; // 10MB
        if (file.size > maxSize) {
            showFeedback(` File too large (${(file.size / 1024 / 1024).toFixed(1)}MB). Maximum size is 10MB.`, 'danger');
            return;
        }
        
        // Validate file format
        const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'image/gif'];
        if (!allowedTypes.includes(file.type.toLowerCase())) {
            showFeedback(` Unsupported file format. Please use JPG, PNG, or WebP.`, 'danger');
            return;
        }

        // Compress image if it's large
        try {
            if (file.size > 500 * 1024) { // Compress if > 500KB
                const progressFeedback = document.getElementById('uploadProgressFeedback');
                const progressFeedbackText = document.getElementById('progressFeedbackText');
                if (progressFeedback && progressFeedbackText) {
                    progressFeedback.style.display = 'block';
                    progressFeedbackText.textContent = 'Compressing image...';
                }
                selectedFile = await compressImage(file);
            } else {
        selectedFile = file;
            }
        } catch (error) {
            console.error('Error compressing image:', error);
            showFeedback(' Error compressing image. Using original file.', 'warning');
            selectedFile = file; // Fallback to original
        }
        
        const reader = new FileReader();
        reader.onload = (e) => {
            // Hide placeholder and show image preview
            const placeholder = document.getElementById('imagePreviewPlaceholder');
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            
            if (imagePreview) {
                imagePreview.src = e.target.result;
                // Store photo data for use in verification modal
                window.uploadedPhotoData = e.target.result;
                imagePreview.style.display = 'block';
                imagePreview.style.opacity = '0';
                imagePreview.style.transition = 'opacity 0.3s ease';
                
                // Wait for image to load before showing
                imagePreview.onload = () => {
                    setTimeout(() => {
                        imagePreview.style.opacity = '1';
                    }, 50);
                };
                
                // Fallback if onload doesn't fire
                setTimeout(() => {
                    if (imagePreview.style.opacity === '0') {
                        imagePreview.style.opacity = '1';
                    }
                }, 100);
            }
            
            // Show remove button
            const removeBtn = document.getElementById('removePreviewBtn');
            if (removeBtn) {
                removeBtn.style.display = 'flex';
            }
            
            // Show progress feedback - Update dynamically based on file state
            const progressFeedback = document.getElementById('uploadProgressFeedback');
            const progressFeedbackText = document.getElementById('progressFeedbackText');
            if (progressFeedback && progressFeedbackText) {
                if (selectedFile && file) {
                    const fileSize = (selectedFile.size / 1024 / 1024).toFixed(2);
                    progressFeedback.style.display = 'block';
                    progressFeedbackText.innerHTML = `<i class="bi bi-check-circle-fill me-2" style="color: #10B981;"></i>Photo selected (${fileSize} MB) - Ready to analyze`;
                } else {
                    progressFeedback.style.display = 'none';
                    progressFeedbackText.textContent = '';
                }
            }
            
            // Smooth transition between upload zone and preview
            if (uploadZone) {
                uploadZone.style.transition = 'opacity 0.2s ease';
                uploadZone.style.opacity = '0';
                setTimeout(() => {
                    uploadZone.style.display = 'none';
                    uploadZone.style.opacity = '1';
                }, 200);
            }
            if (previewSection) {
                previewSection.style.display = 'block';
                previewSection.style.opacity = '0';
                previewSection.style.transition = 'opacity 0.3s ease';
                previewSection.style.pointerEvents = 'auto';
                previewSection.style.zIndex = '1000';
                previewSection.style.position = 'relative';
                // Ensure all buttons in preview section are clickable
                const previewButtons = previewSection.querySelectorAll('button');
                previewButtons.forEach(btn => {
                    btn.style.pointerEvents = 'auto';
                    btn.style.zIndex = '1001';
                    btn.style.position = 'relative';
                    btn.style.cursor = 'pointer';
                    btn.disabled = false; // Ensure buttons are not disabled
                });
                setTimeout(() => {
                    previewSection.style.opacity = '1';
                }, 200);
            }
            
            // Reset upload feedback
            const uploadFeedback = document.getElementById('uploadFeedback');
            if (uploadFeedback) {
                uploadFeedback.style.display = 'none';
                uploadFeedback.className = 'feedback-message';
            }
        };
        reader.onerror = () => {
            alert('Error reading file. Please try again.');
        };
        reader.readAsDataURL(file);
    }

    // Remove/Retake Preview Button
    const removePreviewBtn = document.getElementById('removePreviewBtn');
    const retakePhotoBtn = document.getElementById('retakePhotoBtn');
    
    function resetPhotoPreview() {
        selectedFile = null;
        if (imagePreview) {
            imagePreview.src = '';
            imagePreview.style.display = 'none';
            imagePreview.style.opacity = '0';
        }
        // Show placeholder again
        const placeholder = document.getElementById('imagePreviewPlaceholder');
        if (placeholder) {
            placeholder.style.display = 'flex';
        }
        // Hide remove button
        const removeBtn = document.getElementById('removePreviewBtn');
        if (removeBtn) {
            removeBtn.style.display = 'none';
        }
        if (previewSection) {
            previewSection.style.display = 'none';
        }
        if (uploadZone) {
            uploadZone.style.display = 'block';
            uploadZone.style.opacity = '1';
        }
        const progressFeedback = document.getElementById('uploadProgressFeedback');
        if (progressFeedback) {
            progressFeedback.style.display = 'none';
        }
        // Reset file inputs
        if (photoInput) photoInput.value = '';
        if (mobileCameraInput) mobileCameraInput.value = '';
        // Stop camera if active
        stopCamera();
    }
    
    if (removePreviewBtn) {
        removePreviewBtn.addEventListener('click', resetPhotoPreview);
    }
    
    if (retakePhotoBtn) {
        retakePhotoBtn.addEventListener('click', resetPhotoPreview);
    }

    // Helper function to show camera status
    function showCameraStatus(message) {
        if (cameraStatus && cameraStatusText) {
            cameraStatus.style.display = 'flex';
            cameraStatusText.textContent = message;
        }
        if (cameraError) cameraError.style.display = 'none';
        if (cameraReadyIndicator) cameraReadyIndicator.style.display = 'none';
        if (cameraStreamVideo) cameraStreamVideo.style.display = 'none';
        if (captureBtn) captureBtn.style.display = 'none';
        if (testCameraBtn) testCameraBtn.style.display = 'none';
    }
    
    // Helper function to show camera error
    function showCameraError(title, message) {
        if (cameraError && cameraErrorTitle && cameraErrorMessage) {
            cameraError.style.display = 'flex';
            cameraErrorTitle.textContent = title;
            cameraErrorMessage.textContent = message;
        }
        if (cameraStatus) cameraStatus.style.display = 'none';
        if (cameraReadyIndicator) cameraReadyIndicator.style.display = 'none';
        if (cameraStreamVideo) cameraStreamVideo.style.display = 'none';
        if (captureBtn) captureBtn.style.display = 'none';
        if (testCameraBtn) testCameraBtn.style.display = 'inline-block';
    }
    
    // Helper function to show camera ready
    function showCameraReady() {
        if (cameraReadyIndicator) cameraReadyIndicator.style.display = 'block';
        if (cameraStatus) cameraStatus.style.display = 'none';
        if (cameraError) cameraError.style.display = 'none';
        if (cameraStreamVideo) {
            cameraStreamVideo.style.display = 'block';
        }
        if (captureBtn) captureBtn.style.display = 'block';
        if (testCameraBtn) testCameraBtn.style.display = 'none';
        
        // Show grid overlay if guided scan mode is enabled
        const guidedScanEnabled = document.getElementById('guidedScanMode')?.checked || false;
        const gridOverlay = document.getElementById('gridOverlay');
        if (guidedScanEnabled && gridOverlay && cameraStreamVideo) {
            gridOverlay.style.display = 'block';
        }
    }
    
    // Function to initialize camera - Single-frame capture (no live video)
    async function initializeCamera() {
        // Prevent multiple clicks
        if (openCameraBtn && openCameraBtn.disabled) {
            return false;
        }
        
        // Check if getUserMedia is supported
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            showCameraError(
                'Camera Not Supported',
                'Camera access requires HTTPS or localhost.\n\nTo use camera:\n1. Access via https:// (requires SSL certificate)\n2. Access via http://localhost:5050 or http://127.0.0.1:5050\n\nFor now, please use "Browse Files" to upload a photo instead.'
            );
            // Re-enable button
            if (openCameraBtn) {
                openCameraBtn.disabled = false;
            }
            return false;
        }
        
        // Stop any existing stream first
        stopCamera();
        
        // Show camera view immediately with loading state
        if (uploadZone) {
            uploadZone.style.opacity = '0';
            setTimeout(() => {
                uploadZone.style.display = 'none';
                uploadZone.style.opacity = '1';
            }, 150);
        }
        if (cameraView) {
            cameraView.style.display = 'block';
            cameraView.style.opacity = '0';
            setTimeout(() => {
                cameraView.style.opacity = '1';
            }, 150);
        }
        
        // Show guided scan banner if enabled
        const guidedScanEnabled = document.getElementById('guidedScanMode')?.checked || false;
        const guidedScanBanner = document.getElementById('guidedScanBanner');
        if (guidedScanEnabled && guidedScanBanner) {
            guidedScanBanner.style.display = 'block';
        }
        
        // Show status immediately
        showCameraStatus(' Requesting camera permission...');
        
        // Disable button while requesting camera
        if (openCameraBtn) {
            openCameraBtn.disabled = true;
            const originalText = openCameraBtn.innerHTML;
            openCameraBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Opening...';
            
            // Re-enable button after timeout (safety)
            setTimeout(() => {
                if (openCameraBtn && openCameraBtn.disabled) {
                    openCameraBtn.disabled = false;
                    openCameraBtn.innerHTML = originalText;
                }
            }, 10000);
        }

        try {
            showCameraStatus(' Capturing photo...');
            
            // Request camera with constraints - Single frame capture (no live stream)
            cameraStream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: { ideal: 'environment' },  // Back camera by default
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                } 
            }).catch(error => {
                // Handle permission errors
                console.error('Camera permission error:', error);
                let errorMessage = 'Camera access denied. ';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMessage += 'Please allow camera access in your browser settings and try again.';
                    showCameraError(
                        'Camera Permission Required',
                        'Camera access was denied.\n\nTo enable:\n1. Click the camera icon in your browser\'s address bar\n2. Select "Allow" for camera access\n3. Refresh the page and try again\n\nAlternatively, use "Browse Files" to upload a photo instead.'
                    );
                } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {
                    errorMessage += 'No camera found on this device.';
                    showCameraError(
                        'No Camera Found',
                        'No camera was detected on this device.\n\nPlease use "Browse Files" to upload a photo instead.'
                    );
                } else if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {
                    errorMessage += 'Camera is already in use by another application.';
                    showCameraError(
                        'Camera In Use',
                        'Camera is being used by another application.\n\nPlease close other apps using the camera and try again.'
                    );
                } else {
                    errorMessage += error.message || 'Unknown error occurred.';
                    showCameraError(
                        'Camera Error',
                        `Failed to access camera: ${error.message || 'Unknown error'}\n\nPlease try using "Browse Files" to upload a photo instead.`
                    );
                }
                // Re-enable button
                if (openCameraBtn) {
                    openCameraBtn.disabled = false;
                    const originalText = openCameraBtn.innerHTML;
                    openCameraBtn.innerHTML = originalText.replace(/<span[^>]*>.*?<\/span>/, '').replace('Opening...', 'Use Live Camera Preview');
                }
                throw error;
            });
            
            if (cameraStreamVideo && cameraStream) {
                cameraStreamVideo.srcObject = cameraStream;
                
                // Wait for video to be ready
                await new Promise((resolve, reject) => {
                    if (cameraStreamVideo.readyState >= 2) {
                        resolve();
                    } else {
                        cameraStreamVideo.onloadedmetadata = () => resolve();
                        cameraStreamVideo.onerror = () => reject(new Error('Video failed to load'));
                        // Timeout after 5 seconds
                        setTimeout(() => reject(new Error('Camera initialization timeout')), 5000);
                    }
                });
                
                // Capture immediately (single-frame capture, no live preview)
                await new Promise(resolve => setTimeout(resolve, 300)); // Small delay for stabilization
                
                // Capture single frame
                const canvas = document.createElement('canvas');
                canvas.width = cameraStreamVideo.videoWidth;
                canvas.height = cameraStreamVideo.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(cameraStreamVideo, 0, 0);
                
                // Stop camera immediately after capture
                stopCamera();
                
                // Compress and convert to blob
                // Resize if too large (max 1280px width/height)
                const MAX_SIZE = 1280;
                let finalWidth = canvas.width;
                let finalHeight = canvas.height;
                
                if (finalWidth > MAX_SIZE || finalHeight > MAX_SIZE) {
                    const ratio = Math.min(MAX_SIZE / finalWidth, MAX_SIZE / finalHeight);
                    finalWidth = Math.round(finalWidth * ratio);
                    finalHeight = Math.round(finalHeight * ratio);
                    
                    const resizedCanvas = document.createElement('canvas');
                    resizedCanvas.width = finalWidth;
                    resizedCanvas.height = finalHeight;
                    const resizedCtx = resizedCanvas.getContext('2d');
                    resizedCtx.drawImage(canvas, 0, 0, finalWidth, finalHeight);
                    canvas = resizedCanvas;
                }
                
                // Convert to blob with compression (quality: 0.6 for smaller file size)
                canvas.toBlob((blob) => {
                    if (!blob) {
                        showCameraError('Capture Failed', 'Could not capture photo. Please try again.');
                        return;
                    }
                    
                    selectedFile = new File([blob], 'camera-capture.jpg', { type: 'image/jpeg' });
                    
                    // Show preview immediately
                    if (imagePreview) {
                        const placeholder = document.getElementById('imagePreviewPlaceholder');
                        imagePreview.src = canvas.toDataURL('image/jpeg');
                        imagePreview.style.display = 'block';
                        imagePreview.style.opacity = '0';
                        imagePreview.style.transition = 'opacity 0.3s ease';
                        
                        // Hide placeholder and show image
                        if (placeholder) {
                            placeholder.style.display = 'none';
                        }
                        
                        // Show remove button
                        const removeBtn = document.getElementById('removePreviewBtn');
                        if (removeBtn) {
                            removeBtn.style.display = 'flex';
                        }
                        
                        setTimeout(() => {
                            imagePreview.style.opacity = '1';
                        }, 50);
                    }
                    
                    // Hide camera view and show preview section
                    if (cameraView) {
                        cameraView.style.display = 'none';
                    }
                    if (uploadZone) {
                        uploadZone.style.display = 'none';
                    }
                    if (previewSection) {
                        previewSection.style.display = 'block';
                        previewSection.style.opacity = '0';
                        setTimeout(() => {
                            previewSection.style.opacity = '1';
                        }, 150);
                    }
                    
                    // Update progress feedback
                    const progressFeedback = document.getElementById('uploadProgressFeedback');
                    const progressFeedbackText = document.getElementById('progressFeedbackText');
                    if (progressFeedback && progressFeedbackText) {
                        progressFeedback.style.display = 'block';
                        progressFeedbackText.textContent = 'Photo captured  Ready to analyze';
                    }
                }, 'image/jpeg', 0.92);
                
                return true;
            }
            
            return true;
        } catch (err) {
            // Stop any partial stream
            stopCamera();
            
            let errorTitle = 'Camera Error';
            let errorMessage = 'Could not access camera.';
            
            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                errorTitle = 'Camera Permission Denied';
                errorMessage = 'Camera permission is required to take photos.\n\nTo enable:\n1. Click the camera icon () in your browser\'s address bar\n2. Select "Allow" for camera access\n3. Refresh the page and try again\n\nAlternatively, use "Browse Files" to upload a photo instead.';
                
                // Show error in UI
                if (cameraError && cameraErrorTitle && cameraErrorMessage) {
                    cameraError.style.display = 'block';
                    cameraErrorTitle.textContent = errorTitle;
                    cameraErrorMessage.innerHTML = `
                        <p class="mb-2">Camera permission is required to take photos.</p>
                        <p class="mb-2 small"><strong>To enable:</strong></p>
                        <ol class="small mb-2 ps-3">
                            <li>Click the camera icon () in your browser's address bar</li>
                            <li>Select "Allow" for camera access</li>
                            <li>Refresh the page and try again</li>
                        </ol>
                        <p class="mb-0 small text-muted">Alternatively, use "Browse Files" to upload a photo instead.</p>
                    `;
                }
            } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                errorTitle = 'No Camera Found';
                errorMessage = 'No camera detected on this device.\n\nPlease connect a camera or use "Browse Files" to upload a photo instead.';
            } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                errorTitle = 'Camera In Use';
                errorMessage = 'Camera is being used by another application (Zoom, Meet, Discord, etc.).\n\nPlease close other apps using the camera and try again.';
            } else if (err.name === 'SecurityError' || err.name === 'NotAllowedError') {
                errorTitle = 'Camera Permission Denied';
                errorMessage = 'Camera permission is required to take a photo.\n\nPlease:\n1. Click the camera icon in your browser\'s address bar\n2. Allow camera access\n3. Refresh the page and try again\n\nOr use "Browse Files" to upload a photo instead.';
            } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                errorTitle = 'Camera In Use';
                errorMessage = 'Camera is being used by another application (Zoom, Meet, Discord, etc.).\n\nPlease close other apps using the camera and try again.';
            } else if (err.name === 'OverconstrainedError' || err.name === 'ConstraintNotSatisfiedError') {
                errorTitle = 'Camera Configuration Error';
                errorMessage = 'Camera settings are not supported.\n\nTrying with default settings...';
                // Retry with simpler constraints
                try {
                    showCameraStatus(' Retrying with default settings...');
                    cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    if (cameraStreamVideo && cameraStream) {
                        cameraStreamVideo.srcObject = cameraStream;
                        await new Promise((resolve) => {
                            if (cameraStreamVideo.readyState >= 2) {
                                resolve();
            } else {
                                cameraStreamVideo.onloadedmetadata = () => resolve();
                                setTimeout(() => resolve(), 3000);
                            }
                        });
                        showCameraStatus(' Ready to take photo');
                        setTimeout(() => {
                            showCameraReady();
                        }, 500);
                        // Re-enable button on success
                        if (openCameraBtn) {
                            openCameraBtn.disabled = false;
                            openCameraBtn.innerHTML = '<i class="bi bi-camera-video me-2"></i>Live Camera';
                        }
                        return true;
                    }
                } catch (retryErr) {
                    errorMessage = 'Could not access camera. Please use "Browse Files" to upload a photo instead.';
                }
            } else {
                errorMessage = `Could not access camera: ${err.message}\n\nPlease use "Browse Files" to upload a photo instead.`;
            }
            
            showCameraError(errorTitle, errorMessage);
            
            // Re-enable button on error
            if (openCameraBtn) {
                openCameraBtn.disabled = false;
                openCameraBtn.innerHTML = '<i class="bi bi-camera-video me-2"></i>Live Camera';
            }
            
            return false;
        } finally {
            // Re-enable button if still disabled (safety net)
            if (openCameraBtn && openCameraBtn.disabled) {
                setTimeout(() => {
                    if (openCameraBtn) {
                        openCameraBtn.disabled = false;
                        openCameraBtn.innerHTML = '<i class="bi bi-camera-video me-2"></i>Live Camera';
                    }
                }, 100);
            }
        }
    }
    
    // Camera Functions
    if (openCameraBtn) {
        openCameraBtn.addEventListener('click', async () => {
            await initializeCamera();
        });
    }
    
    // Retry camera button
    if (retryCameraBtn) {
        retryCameraBtn.addEventListener('click', async () => {
            await initializeCamera();
        });
    }
    
    // Test camera button
    if (testCameraBtn) {
        testCameraBtn.addEventListener('click', async () => {
            await initializeCamera();
        });
    }

    if (closeCameraBtn) {
        closeCameraBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            stopCamera();
            
            // Smooth transition back to upload zone
            if (cameraView) {
                cameraView.style.opacity = '0';
                setTimeout(() => {
                    cameraView.style.display = 'none';
                    cameraView.style.opacity = '1';
                }, 150);
            }
            if (uploadZone) {
                uploadZone.style.display = 'block';
                uploadZone.style.opacity = '0';
                setTimeout(() => {
                    uploadZone.style.opacity = '1';
                }, 150);
            }
        });
        // Ensure button is clickable
        closeCameraBtn.style.pointerEvents = 'auto';
        closeCameraBtn.style.cursor = 'pointer';
        closeCameraBtn.style.zIndex = '10';
    }

    if (captureBtn && cameraStreamVideo) {
        captureBtn.addEventListener('click', () => {
            // Check if video is ready
            if (!cameraStreamVideo.videoWidth || !cameraStreamVideo.videoHeight) {
                alert('Camera is not ready yet. Please wait a moment and try again.');
                return;
            }
            
            // Show capture feedback
            showCameraStatus(' Capturing photo...');
            
            try {
        const canvas = document.createElement('canvas');
        canvas.width = cameraStreamVideo.videoWidth;
        canvas.height = cameraStreamVideo.videoHeight;
                const ctx = canvas.getContext('2d');
        
                // Draw video frame to canvas
                ctx.drawImage(cameraStreamVideo, 0, 0);
                
                // Compress image before converting to blob
                const MAX_SIZE = 1280;
                let finalWidth = canvas.width;
                let finalHeight = canvas.height;
                
                if (finalWidth > MAX_SIZE || finalHeight > MAX_SIZE) {
                    const ratio = Math.min(MAX_SIZE / finalWidth, MAX_SIZE / finalHeight);
                    finalWidth = Math.round(finalWidth * ratio);
                    finalHeight = Math.round(finalHeight * ratio);
                    
                    const resizedCanvas = document.createElement('canvas');
                    resizedCanvas.width = finalWidth;
                    resizedCanvas.height = finalHeight;
                    const resizedCtx = resizedCanvas.getContext('2d');
                    resizedCtx.drawImage(canvas, 0, 0, finalWidth, finalHeight);
                    canvas = resizedCanvas;
                }
                
                // Convert to blob with compression (quality: 0.6)
        canvas.toBlob((blob) => {
                    if (!blob) {
                        showCameraError('Capture Failed', 'Could not capture photo. Please try again.');
                        return;
                    }
                    
            selectedFile = new File([blob], 'camera-capture.jpg', { type: 'image/jpeg' });
                    
                    // Show preview
                    if (imagePreview) {
                        imagePreview.src = canvas.toDataURL('image/jpeg');
                        imagePreview.style.display = 'block';
                        imagePreview.style.opacity = '0';
                        imagePreview.style.transition = 'opacity 0.3s ease';
                        setTimeout(() => {
                            imagePreview.style.opacity = '1';
                        }, 50);
                    }
                    
                    // Update progress feedback
                    const progressFeedback = document.getElementById('uploadProgressFeedback');
                    const progressFeedbackText = document.getElementById('progressFeedbackText');
                    if (progressFeedback && progressFeedbackText) {
                        progressFeedback.style.display = 'block';
                        progressFeedbackText.textContent = 'Photo captured  Ready to analyze';
                    }
                    
                    // Stop camera
            stopCamera();
                    
                    // Smooth transition between camera view and preview
                    if (cameraView) {
                        cameraView.style.opacity = '0';
                        setTimeout(() => {
                            cameraView.style.display = 'none';
                            cameraView.style.opacity = '1';
                        }, 150);
                    }
                    if (previewSection) {
                        previewSection.style.display = 'block';
                        previewSection.style.opacity = '0';
                        setTimeout(() => {
                            previewSection.style.opacity = '1';
                        }, 150);
                    }
                }, 'image/jpeg', 0.92); // Quality: 0.92 (high quality)
            } catch (err) {
                console.error('Capture error:', err);
                showCameraError('Capture Failed', 'Could not capture photo. Please try again.');
            }
        });
    }

    function stopCamera() {
        try {
        if (cameraStream) {
                cameraStream.getTracks().forEach(track => {
                    try {
                        track.stop();
                    } catch (e) {
                        console.warn('Error stopping camera track:', e);
                    }
                });
            cameraStream = null;
        }
            if (cameraStreamVideo) {
                try {
                    cameraStreamVideo.srcObject = null;
                } catch (e) {
                    console.warn('Error clearing camera video source:', e);
                }
            }
            // Hide camera status messages
            if (cameraStatus) cameraStatus.style.display = 'none';
            if (cameraError) cameraError.style.display = 'none';
            if (cameraReadyIndicator) cameraReadyIndicator.style.display = 'none';
            if (captureBtn) captureBtn.style.display = 'none';
            if (testCameraBtn) testCameraBtn.style.display = 'none';
        } catch (error) {
            console.error('Error in stopCamera:', error);
        }
    }
    
    // Clean up camera when modal is closed
    if (photoModal) {
        photoModal.addEventListener('hidden.bs.modal', () => {
            stopCamera();
        });
    }

    // Cancel upload
    if (cancelUploadBtn) {
        cancelUploadBtn.addEventListener('click', () => {
            resetPhotoUploadState();
        });
    }

    // Scan Quality Checking Function
    function checkImageQuality(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    // Create canvas to analyze image
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    // Get image data
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Calculate brightness (mean)
                    let brightnessSum = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = (data[i] + data[i+1] + data[i+2]) / 3;
                        brightnessSum += gray;
                    }
                    const brightness = (brightnessSum / (data.length / 4)) / 255;
                    
                    // Calculate blur (Laplacian variance)
                    let variance = 0;
                    let mean = 0;
                    const laplacianKernel = [0, -1, 0, -1, 4, -1, 0, -1, 0];
                    
                    // Convert to grayscale and calculate Laplacian
                    const grayData = [];
                    for (let i = 0; i < data.length; i += 4) {
                        grayData.push((data[i] + data[i+1] + data[i+2]) / 3);
                    }
                    
                    // Calculate Laplacian variance (blur detection)
                    for (let y = 1; y < img.height - 1; y++) {
                        for (let x = 1; x < img.width - 1; x++) {
                            let laplacian = 0;
                            let kernelIdx = 0;
                            for (let ky = -1; ky <= 1; ky++) {
                                for (let kx = -1; kx <= 1; kx++) {
                                    const idx = ((y + ky) * img.width + (x + kx)) * 4;
                                    laplacian += grayData[(y + ky) * img.width + (x + kx)] * laplacianKernel[kernelIdx];
                                    kernelIdx++;
                                }
                            }
                            mean += laplacian;
                        }
                    }
                    mean /= ((img.width - 2) * (img.height - 2));
                    
                    for (let y = 1; y < img.height - 1; y++) {
                        for (let x = 1; x < img.width - 1; x++) {
                            let laplacian = 0;
                            let kernelIdx = 0;
                            for (let ky = -1; ky <= 1; ky++) {
                                for (let kx = -1; kx <= 1; kx++) {
                                    laplacian += grayData[(y + ky) * img.width + (x + kx)] * laplacianKernel[kernelIdx];
                                    kernelIdx++;
                                }
                            }
                            variance += Math.pow(laplacian - mean, 2);
                        }
                    }
                    variance /= ((img.width - 2) * (img.height - 2));
                    
                    // Determine quality
                    let quality = 'Good';
                    let qualityIcon = 'bi-check-circle-fill';
                    let qualityColor = '#10B981';
                    let messages = [];
                    
                    if (brightness < 0.3) {
                        quality = 'Poor';
                        qualityIcon = 'bi-exclamation-triangle-fill';
                        qualityColor = '#EF4444';
                        messages.push('Image is too dark - improve lighting');
                    } else if (brightness < 0.4) {
                        quality = 'Fair';
                        qualityIcon = 'bi-info-circle-fill';
                        qualityColor = '#F59E0B';
                        messages.push('Image is somewhat dark - consider better lighting');
                    }
                    
                    if (variance < 100) {
                        if (quality === 'Good') {
                            quality = 'Poor';
                            qualityIcon = 'bi-exclamation-triangle-fill';
                            qualityColor = '#EF4444';
                        } else if (quality === 'Fair') {
                            quality = 'Poor';
                        }
                        messages.push('Image is blurry - hold camera steady');
                    } else if (variance < 200) {
                        if (quality === 'Good') {
                            quality = 'Fair';
                            qualityIcon = 'bi-info-circle-fill';
                            qualityColor = '#F59E0B';
                        }
                        messages.push('Image is slightly blurry');
                    }
                    
                    resolve({
                        quality,
                        icon: qualityIcon,
                        color: qualityColor,
                        messages: messages.length > 0 ? messages : ['Image quality is good'],
                        brightness: Math.round(brightness * 100),
                        blurScore: Math.round(variance)
                    });
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }
    
    // Show scan quality indicator
    function showScanQuality(qualityData) {
        const indicator = document.getElementById('scanQualityIndicator');
        const qualityScoreText = document.getElementById('qualityScoreText');
        const qualityMessage = document.getElementById('qualityMessage');
        const qualityIcon = document.getElementById('qualityIcon');
        const retakeBtn = document.getElementById('retakePhotoBtn');
        
        if (!indicator) return;
        
        indicator.style.display = 'block';
        if (qualityScoreText) {
            qualityScoreText.textContent = qualityData.quality;
            qualityScoreText.style.color = qualityData.color;
        }
        if (qualityMessage) {
            qualityMessage.textContent = qualityData.messages.join('  ');
        }
        if (qualityIcon) {
            qualityIcon.className = `bi ${qualityData.icon}`;
            qualityIcon.style.color = qualityData.color;
        }
        if (retakeBtn) {
            retakeBtn.style.display = qualityData.quality === 'Poor' ? 'block' : 'none';
        }
    }

    // Upload photo - Redone with better error handling and state management
    if (uploadBtn && uploadBtnText) {
        uploadBtn.addEventListener('click', async function handlePhotoUpload() {
            // Prevent multiple clicks
            if (uploadBtn.disabled) {
                return;
            }
            
            if (!selectedFile) {
                const feedback = document.getElementById('addItemFeedback');
                if (feedback) {
                    showFeedback('Please select a photo first', 'warning');
                } else {
                    alert('Please select a photo first');
                }
                return;
            }

            // Check image quality first
            const qualityData = await checkImageQuality(selectedFile);
            showScanQuality(qualityData);
            
            // Warn user if quality is poor
            if (qualityData.quality === 'Poor') {
                const proceed = confirm(` Scan Quality: ${qualityData.quality}\n\n${qualityData.messages.join('\n')}\n\nContinue anyway?`);
                if (!proceed) {
                    return;
                }
            }

            // Check if multi-photo mode is enabled
            const multiPhotoMode = document.getElementById('multiPhotoMode')?.checked || false;
            const photoFiles = multiPhotoMode ? Array.from(document.getElementById('mobileCameraInput')?.files || []) : [selectedFile];
            
            const formData = new FormData();
            let uploadEndpoint;
            
            // Get selected detection method from modal
            const detectionMethod = document.querySelector('input[name="detection_method_modal"]:checked')?.value || 'ml';
            formData.append('detection_method', detectionMethod);
            
            if (multiPhotoMode && photoFiles.length > 1) {
                // Multi-photo mode: use batch endpoint
                uploadEndpoint = '/api/upload_photos_batch';
                photoFiles.forEach((file, idx) => {
                    formData.append('photos[]', file);
                });
            } else {
                // Single photo mode
                uploadEndpoint = '/upload_photo';
                formData.append('photo', selectedFile);
            }

            // Set loading state - Clear visual feedback
            uploadBtn.disabled = true;
            uploadBtn.classList.add('loading');
            uploadBtn.style.opacity = '0.7';
            uploadBtn.style.cursor = 'not-allowed';
            const originalText = uploadBtnText.textContent;
            uploadBtnText.innerHTML = '<span class="spinner-border spinner-border-sm me-2" style="width: 1rem; height: 1rem; border-width: 0.15em;"></span>Analyzing...';
            
            // Show prominent loading feedback
            const uploadFeedback = document.getElementById('uploadFeedback');
            if (uploadFeedback) {
                uploadFeedback.className = 'feedback-message loading-feedback';
                uploadFeedback.innerHTML = '<div class="d-flex align-items-center gap-2"><span class="spinner-border spinner-border-sm text-primary" style="width: 1.25rem; height: 1.25rem;"></span><span class="fw-semibold">Analyzing photo with AI...</span></div>';
                uploadFeedback.style.display = 'flex';
                uploadFeedback.style.background = 'linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(37, 99, 235, 0.08) 100%)';
                uploadFeedback.style.borderLeft = '4px solid #3B82F6';
                uploadFeedback.style.padding = '1rem';
                uploadFeedback.style.borderRadius = '12px';
            }
            
            // Also update progress feedback
            const progressFeedback = document.getElementById('uploadProgressFeedback');
            const progressFeedbackText = document.getElementById('progressFeedbackText');
            if (progressFeedback && progressFeedbackText) {
                progressFeedback.style.display = 'block';
                progressFeedbackText.innerHTML = '<span class="spinner-border spinner-border-sm me-2" style="width: 0.875rem; height: 0.875rem;"></span>Analyzing with AI...';
            }

            try {
                // Use longer timeout for uploads (60 seconds)
                const response = await fetchWithTimeout(uploadEndpoint, {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'  // Request JSON response
                    }
                }, UPLOAD_TIMEOUT_MS);

                console.log('Upload response status:', response.status);
                console.log('Upload response content-type:', response.headers.get('content-type'));

                if (response.ok) {
                    const contentType = response.headers.get('content-type') || '';
                    let data;
                    
                    // Try to parse as JSON first
                    try {
                        data = await response.json();
                        console.log('Parsed JSON response:', data);
                        
                        if (data.success) {
                            // Show results with confidence
                            console.log('Photo analysis successful, showing results modal...');
                            console.log('Response data:', {
                                items: data.items?.length || 0,
                                high_confidence: data.high_confidence?.length || 0,
                                low_confidence: data.low_confidence?.length || 0,
                                auto_added: data.auto_added || 0
                            });
                            showPhotoAnalysisResults(data);
                        } else {
                            const errorMsg = data.error || 'Photo analysis failed';
                            console.error('Photo analysis failed:', errorMsg);
                            showFeedback(errorMsg, 'danger');
                            resetPhotoUploadState();
                        }
                    } catch (jsonError) {
                        // If JSON parsing fails, try to get text response
                        console.error('Failed to parse JSON response:', jsonError);
                        const textResponse = await response.text();
                        console.log('Text response:', textResponse.substring(0, 200));
                        
                        // HTML redirect response (fallback) - shouldn't happen with AJAX
                        const uploadFeedback = document.getElementById('uploadFeedback');
                        if (uploadFeedback) {
                            uploadFeedback.className = 'feedback-message error';
                            uploadFeedback.innerHTML = '<i class="bi bi-exclamation-triangle-fill me-2"></i>Unexpected response format. Please try again.';
                            uploadFeedback.style.display = 'flex';
                        }
                        console.warn('Received non-JSON response instead of JSON - this should not happen with AJAX upload');
                            resetPhotoUploadState();
                    }
                } else {
                    // Handle error response
                    let errorMessage = 'Upload failed. Please try again.';
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorMessage;
                    } catch (e) {
                        const errorText = await response.text();
                        if (errorText) {
                            errorMessage = errorText.substring(0, 100);
                        }
                    }
                    
                    // Show error in modal
                    const uploadFeedback = document.getElementById('uploadFeedback');
                    if (uploadFeedback) {
                        uploadFeedback.className = 'feedback-message error';
                        uploadFeedback.innerHTML = '<i class="bi bi-exclamation-triangle-fill me-2"></i>' + errorMessage;
                        uploadFeedback.style.display = 'flex';
                    }
                    
                    // Show error on main page
                    const feedback = document.getElementById('addItemFeedback');
                    if (feedback) {
                        showFeedback(errorMessage, 'danger');
                    } else {
                        alert(errorMessage);
                    }
                    
                    // Reset button state on error
                    resetPhotoUploadButton();
                }
            } catch (err) {
                console.error('Photo upload error:', err);
                let errorMessage = 'Network error. Please check your connection and try again.';
                
                // Handle specific error types
                if (err.name === 'AbortError') {
                    errorMessage = 'Request timed out. The image may be too large or the server is busy. Please try again.';
                } else if (err.message) {
                    errorMessage = err.message;
                }
                
                // Show error in modal
                const uploadFeedback = document.getElementById('uploadFeedback');
                if (uploadFeedback) {
                    uploadFeedback.className = 'feedback-message error';
                    uploadFeedback.innerHTML = '<i class="bi bi-exclamation-triangle-fill me-2"></i>' + errorMessage;
                    uploadFeedback.style.display = 'flex';
                }
                
                // Show error on main page
                const feedback = document.getElementById('addItemFeedback');
                if (feedback) {
                    showFeedback(errorMessage, 'danger');
                } else {
                    alert('Upload error: ' + errorMessage);
                }
            } finally {
                // Always reset button state, even on error
                uploadBtn.classList.remove('loading');
                resetPhotoUploadButton();
            }
        });
    }
    
    // Helper function to close photo modal (uses consistent helper)
    function closePhotoModal() {
        closeModalSafely('photoModal');
        // Also ensure photo upload state is reset
        resetPhotoUploadState();
    }
    
    // Show photo analysis results with confidence scores
    function showPhotoAnalysisResults(data) {
        console.log('showPhotoAnalysisResults called with:', data);
        const uploadFeedback = document.getElementById('uploadFeedback');
        
        if (!data || !data.success) {
            console.error('Photo analysis failed or invalid data:', data);
            if (uploadFeedback) {
                uploadFeedback.className = 'feedback-message error';
                uploadFeedback.innerHTML = '<i class="bi bi-exclamation-triangle-fill me-2"></i>' + (data?.error || 'Analysis failed');
                uploadFeedback.style.display = 'flex';
            }
            resetPhotoUploadState();
            return;
        }
        
        const autoAdded = data.auto_added || 0;
        const needsConfirmation = data.needs_confirmation || 0;
        let allItems = data.items || [];
        const highConfItems = data.high_confidence || [];
        const lowConfItems = data.low_confidence || [];
        
        // Debug: Log items to console
        console.log('Photo analysis results:', {
            allItems: allItems.length,
            highConfItems: highConfItems.length,
            lowConfItems: lowConfItems.length,
            autoAdded,
            needsConfirmation,
            items: allItems
        });
        
        // If items array is empty, check if we have items in high/low confidence arrays
        if (allItems.length === 0 && (highConfItems.length > 0 || lowConfItems.length > 0)) {
            console.log('Items array is empty, but found items in high/low confidence arrays. Combining...');
            allItems = [...highConfItems, ...lowConfItems];
        }
        
        // Ensure each item has a confidence value
        allItems = allItems.map(item => {
            if (typeof item === 'string') {
                // Convert string items to objects
                return {
                    id: `item_${Date.now()}_${Math.random()}`,
                    name: item,
                    quantity: '1',
                    category: 'other',
                    confidence: 0.5, // Default medium confidence
                    is_partial: false
                };
            }
            // Ensure confidence exists
            if (item.confidence === undefined || item.confidence === null) {
                // Check if item is in high confidence list
                const isHighConf = highConfItems.some(hi => hi.name === item.name || (hi.id && hi.id === item.id));
                item.confidence = isHighConf ? 0.85 : 0.5;
            }
            // Ensure id exists
            if (!item.id) {
                item.id = `item_${Date.now()}_${Math.random()}`;
            }
            return item;
        });
        
        // Show success message
        if (uploadFeedback) {
            uploadFeedback.className = 'feedback-message success';
            uploadFeedback.innerHTML = `<i class="bi bi-check-circle-fill me-2"></i>${data.message || 'Photo analyzed successfully!'}`;
            uploadFeedback.style.display = 'flex';
        }
        
        // Always show modal with all detected items and their confidence levels
        if (allItems.length > 0) {
            console.log(' Photo analysis complete! Items detected:', allItems.length);
            console.log('Items breakdown:', {
                total: allItems.length,
                high: highConfItems.length,
                low: lowConfItems.length,
                autoAdded: autoAdded
            });
            
            // Close photo modal immediately to avoid conflicts
            const photoModal = document.getElementById('photoModal');
            if (photoModal) {
                if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                    const photoModalInstance = bootstrap.Modal.getInstance(photoModal);
                    if (photoModalInstance) {
                        photoModalInstance.hide();
                        console.log(' Photo modal closed');
                    }
                } else {
                    // Fallback: hide manually
                    photoModal.style.display = 'none';
                    photoModal.classList.remove('show');
                    document.body.classList.remove('modal-open');
                }
            }
            
            // Small delay to ensure photo modal closes, then show verification modal
            setTimeout(() => {
                try {
                    console.log(' Showing verification modal...');
                    // Ensure modal is shown even if it already exists
            showAIConfidenceModal(allItems, autoAdded, highConfItems, lowConfItems);
                    console.log(' showAIConfidenceModal called successfully');
                    
                    // Multiple attempts to ensure modal shows
                    let attempts = 0;
                    const maxAttempts = 5;
                    const checkAndShowModal = () => {
                        attempts++;
                        const confidenceModal = document.getElementById('aiConfidenceModal');
                        
                        if (!confidenceModal) {
                            console.error(' Confidence modal element not found in DOM!');
                            if (attempts < maxAttempts) {
                                setTimeout(checkAndShowModal, 200);
                            } else {
                                alert('Error: Verification window could not be created. Please refresh and try again.');
                            }
                            return;
                        }
                        
                        const isVisible = confidenceModal.classList.contains('show') || 
                                         confidenceModal.style.display === 'block' || 
                                         confidenceModal.style.display === 'flex' ||
                                         window.getComputedStyle(confidenceModal).display !== 'none';
                        
                        if (!isVisible) {
                            console.warn(` Modal not visible (attempt ${attempts}/${maxAttempts}), forcing display...`);
                            
                            // Force display with multiple methods
                            confidenceModal.style.display = 'block';
                            confidenceModal.style.visibility = 'visible';
                            confidenceModal.style.opacity = '1';
                            confidenceModal.classList.add('show');
                            confidenceModal.style.zIndex = '1060';
                            confidenceModal.setAttribute('aria-hidden', 'false');
                            document.body.classList.add('modal-open');
                            
                            // Remove any backdrops from photo modal
                            const backdrops = document.querySelectorAll('.modal-backdrop');
                            backdrops.forEach(b => {
                                if (parseInt(b.style.zIndex) < 1055) {
                                    b.remove();
                                }
                            });
                            
                            // Create new backdrop for confidence modal
                            let backdrop = document.querySelector('.modal-backdrop');
                            if (!backdrop) {
                                backdrop = document.createElement('div');
                                backdrop.className = 'modal-backdrop fade show';
                                backdrop.style.zIndex = '1055';
                                document.body.appendChild(backdrop);
                            }
                            
                            // Try Bootstrap show if available
                            if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                                try {
                                    let modalInstance = bootstrap.Modal.getInstance(confidenceModal);
                                    if (!modalInstance) {
                                        modalInstance = new bootstrap.Modal(confidenceModal, {
                                            backdrop: 'static',
                                            keyboard: false
                                        });
                                    }
                                    modalInstance.show();
                                } catch (bootstrapError) {
                                    console.warn('Bootstrap modal show failed, using manual display:', bootstrapError);
                                }
                            }
                            
                            if (attempts < maxAttempts) {
                                setTimeout(checkAndShowModal, 200);
                            }
                        } else {
                            console.log(' Verification modal is now visible!');
                        }
                    };
                    
                    // Start checking immediately, then again after delays
                    checkAndShowModal();
                    setTimeout(checkAndShowModal, 100);
                    setTimeout(checkAndShowModal, 300);
                    setTimeout(checkAndShowModal, 500);
                    
                } catch (modalError) {
                    console.error(' Error showing AI confidence modal:', modalError);
                    console.error('Modal error details:', modalError.stack);
                    // Try to recreate modal once before giving up
                    try {
                        console.log(' Attempting to recreate modal after error...');
                        showAIConfidenceModal(allItems, autoAdded, highConfItems, lowConfItems, true);
                    } catch (retryError) {
                        console.error(' Modal recreation also failed:', retryError);
                    alert('Unable to display items. We detected ' + allItems.length + ' items in your photo. Please refresh the page and try again.');
                    showFeedback('Unable to display detected items. Please refresh the page and try again.', 'warning');
                    resetPhotoUploadState();
                    }
                }
            }, 300);
        } else {
            // Show message if no items detected
            console.warn(' No items detected in photo');
            showFeedback('No items were detected in the photo. Please try again with a clearer image.', 'warning');
            resetPhotoUploadState();
        }
    }
    
    // Show confirmation modal for low-confidence items
    function showConfirmationModal(lowConfItems, autoAdded) {
        // Create or get confirmation modal
        let confirmModal = document.getElementById('confirmItemsModal');
        if (!confirmModal) {
            confirmModal = document.createElement('div');
            confirmModal.id = 'confirmItemsModal';
            confirmModal.className = 'modal fade';
            confirmModal.setAttribute('tabindex', '-1');
            confirmModal.innerHTML = `
                <div class="modal-dialog modal-dialog-centered modal-lg">
                    <div class="modal-content" style="border-radius: 16px;">
                        <div class="modal-header" style="background: linear-gradient(135deg, #F59E0B 0%, #EF4444 100%); color: white; border-radius: 16px 16px 0 0;">
                            <h5 class="modal-title">
                                <i class="bi bi-question-circle-fill me-2"></i>Confirm Items
                            </h5>
                            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body p-4" style="background: #f8f9fa;">
                            <p class="mb-3">${autoAdded > 0 ? `<strong> ${autoAdded} high-confidence items were automatically added.</strong><br>` : ''}Please review and confirm the items below:</p>
                            <div id="confirmItemsList" class="mb-3"></div>
                            <div class="d-flex gap-2 justify-content-end">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Skip All</button>
                                <button type="button" class="btn btn-primary" id="confirmItemsBtn">
                                    <i class="bi bi-check-circle-fill me-2"></i>Confirm Selected
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(confirmModal);
            
            // Handle confirm button
            document.getElementById('confirmItemsBtn').addEventListener('click', async () => {
                const checkboxes = confirmModal.querySelectorAll('input[type="checkbox"]:checked');
                const selectedItems = [];
                checkboxes.forEach(cb => {
                    const itemData = JSON.parse(cb.dataset.item);
                    if (cb.checked) {
                        selectedItems.push(itemData);
                    }
                });
                
                if (selectedItems.length > 0) {
                    try {
                        const response = await fetchWithTimeout('/api/confirm_items', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Requested-With': 'XMLHttpRequest'
                            },
                            credentials: 'same-origin',
                            body: JSON.stringify({ items: selectedItems })
                        });
                        
                        const data = await response.json();
                        if (data.success) {
                            showFeedback(` Added ${data.items_added} confirmed items`, 'success');
                            if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                                const modalInstance = bootstrap.Modal.getInstance(confirmModal);
                                if (modalInstance) modalInstance.hide();
                            }
                            setTimeout(async () => {
                                try {
                                    // Use API endpoint for more reliable reload
                                    if (typeof reloadPantryItemsFromAPI === 'function') {
                                        await reloadPantryItemsFromAPI();
                                    } else {
                                    await reloadPantryItems();
                                    }
                                } catch (reloadError) {
                                    console.error('Error reloading pantry after photo upload:', reloadError);
                                    // Fallback to HTML parsing method
                                    try {
                                        await reloadPantryItems();
                                    } catch (fallbackError) {
                                        console.error('Fallback reload also failed:', fallbackError);
                                }
                                }
                            }, 800);
                        } else {
                            showFeedback(data.error || 'Failed to add items', 'danger');
                        }
                    } catch (error) {
                        console.error('Error confirming items:', error);
                        const errorMsg = error.name === 'AbortError' 
                            ? 'Request timed out. Please try again.' 
                            : 'Error confirming items. Please try again.';
                        showFeedback(errorMsg, 'danger');
                    }
                }
                
                // Close photo modal and reset
                closePhotoModal();
                resetPhotoUploadState();
            });
        }
        
        // Populate items list
        const itemsList = confirmModal.querySelector('#confirmItemsList');
        itemsList.innerHTML = '';
        
        lowConfItems.forEach(item => {
            const confPercent = Math.round((item.confidence || 0) * 100);
            const confColor = confPercent >= 50 ? '#F59E0B' : '#EF4444';
            const confLabel = confPercent >= 50 ? 'Medium' : 'Low';
            const isPartial = item.is_partial || false;
            const expirationRisk = item.expiration_risk || null;
            
            // Expiration risk badge
            let expRiskBadge = '';
            if (expirationRisk) {
                const riskColors = {
                    'expired': '#EF4444',
                    'critical': '#DC2626',
                    'high': '#F59E0B',
                    'medium': '#3B82F6',
                    'low': '#10B981'
                };
                const riskLabels = {
                    'expired': ' Expired',
                    'critical': ' Critical',
                    'high': ' High Risk',
                    'medium': ' Medium',
                    'low': ' Low Risk'
                };
                const riskColor = riskColors[expirationRisk] || '#64748b';
                const riskLabel = riskLabels[expirationRisk] || expirationRisk;
                expRiskBadge = `<span class="badge ms-2" style="background: ${riskColor}; color: white; font-size: 0.75rem;">
                    ${riskLabel}
                </span>`;
            }
            
            // Partial recognition indicator
            let partialBadge = '';
            if (isPartial) {
                partialBadge = `<span class="badge ms-2" style="background: #8B5CF6; color: white; font-size: 0.75rem;">
                    <i class="bi bi-question-circle me-1"></i>Partial Recognition
                </span>`;
            }
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'card mb-2';
            itemDiv.style.border = '1px solid #e2e8f0';
            if (expirationRisk === 'expired' || expirationRisk === 'critical') {
                itemDiv.style.borderLeft = '4px solid #EF4444';
                itemDiv.style.background = 'rgba(239, 68, 68, 0.05)';
            }
            itemDiv.innerHTML = `
                <div class="card-body p-3">
                    <div class="form-check d-flex align-items-center">
                        <input class="form-check-input me-3" type="checkbox" checked 
                               data-item='${JSON.stringify(item).replace(/'/g, "&#39;")}' 
                               id="item_${item.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}">
                        <label class="form-check-label flex-grow-1" for="item_${item.name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}">
                            <div class="d-flex justify-content-between align-items-center flex-wrap gap-2">
                                <div>
                                    <strong>${item.name}${partialBadge}</strong>
                                    <small class="text-muted d-block">${item.quantity || '1'}  ${item.category || 'other'}${expRiskBadge}</small>
                                </div>
                                <span class="badge" style="background: ${confColor}; color: white;">
                                    ${confLabel} (${confPercent}%)
                                </span>
                            </div>
                        </label>
                    </div>
                </div>
            `;
            itemsList.appendChild(itemDiv);
        });
        
        // Show modal
        if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
            const modalInstance = new bootstrap.Modal(confirmModal);
            modalInstance.show();
        } else {
            confirmModal.style.display = 'block';
            confirmModal.classList.add('show');
        }
    }
    
    // Show AI confidence modal with all detected items
    function showAIConfidenceModal(allItems, autoAdded, highConfItems, lowConfItems, forceRecreate = false) {
        // Debug: Log what we received
        console.log('showAIConfidenceModal called with:', {
            allItemsCount: allItems ? allItems.length : 0,
            autoAdded,
            highConfItemsCount: highConfItems ? highConfItems.length : 0,
            lowConfItemsCount: lowConfItems ? lowConfItems.length : 0,
            allItems: allItems
        });
        
        // Ensure allItems is an array and not empty
        if (!Array.isArray(allItems) || allItems.length === 0) {
            console.error('No items to display in modal. allItems:', allItems);
            showFeedback('No items detected in the photo. Please try again with a clearer image.', 'warning');
            return;
        }
        
        // Categorize items by confidence level
        // Match backend threshold (0.7) for consistency
        const HIGH_THRESHOLD = 0.7;  // Green: High confidence (matches backend HIGH_CONFIDENCE_THRESHOLD)
        const MEDIUM_THRESHOLD = 0.5;  // Yellow: Medium confidence
        
        const highConf = allItems.filter(item => {
            const conf = item.confidence || 0;
            return conf >= HIGH_THRESHOLD;
        });
        const mediumConf = allItems.filter(item => {
            const conf = item.confidence || 0;
            return conf >= MEDIUM_THRESHOLD && conf < HIGH_THRESHOLD;
        });
        const lowConf = allItems.filter(item => {
            const conf = item.confidence || 0;
            return conf < MEDIUM_THRESHOLD;
        });
        
        // Debug: Log categorization
        console.log('Items categorized:', {
            high: highConf.length,
            medium: mediumConf.length,
            low: lowConf.length,
            total: allItems.length
        });
        
        // Create or get AI confidence modal
        let confidenceModal = forceRecreate ? null : document.getElementById('aiConfidenceModal');
        let modalNeedsSetup = false;
        if (!confidenceModal || forceRecreate) {
            // Remove existing modal if recreating
            if (confidenceModal && forceRecreate) {
                try {
                    confidenceModal.remove();
                } catch (e) {
                    console.warn('Could not remove existing modal:', e);
                }
                confidenceModal = null;
            }
            modalNeedsSetup = true;
            confidenceModal = document.createElement('div');
            confidenceModal.id = 'aiConfidenceModal';
            confidenceModal.className = 'modal fade';
            confidenceModal.setAttribute('tabindex', '-1');
            confidenceModal.setAttribute('aria-labelledby', 'aiConfidenceModalLabel');
            // Get photo data for display
            const photoData = window.uploadedPhotoData || '';
            const photoHtml = photoData ? 
                `<img src="${photoData}" alt="Uploaded Photo" style="width: 60px; height: 60px; object-fit: cover; border-radius: 12px; border: 2px solid rgba(255,255,255,0.3); box-shadow: 0 2px 8px rgba(0,0,0,0.2);">` :
                `<div style="width: 60px; height: 60px; background: rgba(255,255,255,0.2); border-radius: 12px; display: flex; align-items: center; justify-content: center;"><i class="bi bi-image" style="font-size: 1.5rem;"></i></div>`;
            
            confidenceModal.innerHTML = `
                <div class="modal-dialog modal-dialog-centered modal-xl">
                    <div class="modal-content" style="border-radius: 16px; max-height: 90vh; display: flex; flex-direction: column;">
                        <div class="modal-header" style="background: linear-gradient(135deg, #10B981 0%, #3B82F6 50%, #F59E0B 100%); color: white; border-radius: 16px 16px 0 0; border-bottom: none; padding: 20px 24px;">
                            <div class="d-flex align-items-center gap-3" style="flex: 1;">
                                ${photoHtml}
                                <div style="flex: 1;">
                                    <h5 class="modal-title mb-0" id="aiConfidenceModalLabel" style="font-weight: 700; font-size: 1.25rem;">
                                <i class="bi bi-robot me-2"></i>Review Detected Items
                            </h5>
                                    <small style="opacity: 0.9;">Review and select items to add to your pantry</small>
                                </div>
                            </div>
                            <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close" style="font-size: 1.2rem;"></button>
                        </div>
                        <div class="modal-body p-4" style="background: #f8f9fa; overflow-y: auto; flex: 1;">
                            <!-- Info Banner -->
                            <div class="alert alert-info mb-4" style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%); border-left: 4px solid #3B82F6; border-radius: 8px;">
                                <div class="d-flex align-items-start">
                                    <i class="bi bi-info-circle-fill me-2" style="font-size: 1.2rem; color: #3B82F6;"></i>
                                    <div>
                                        <strong>Help Improve AI Accuracy!</strong>
                                        <p class="mb-0 small mt-1">By confirming items detected in your photo, you're helping our AI learn and become more accurate. Your feedback trains the model to better recognize food items in future photos.</p>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Summary Cards -->
                            <div class="row mb-4">
                                <div class="col-md-4 mb-3">
                                    <div class="card border-0 shadow-sm" style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); color: white;">
                                        <div class="card-body text-center">
                                            <i class="bi bi-check-circle-fill" style="font-size: 2rem;"></i>
                                            <h3 class="mt-2 mb-0">${highConf.length}</h3>
                                            <small>High Confidence</small>
                                            <div class="mt-2">
                                                <span class="badge" style="background: rgba(255,255,255,0.3); color: white;"> Auto-Added</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4 mb-3">
                                    <div class="card border-0 shadow-sm" style="background: linear-gradient(135deg, #F59E0B 0%, #D97706 100%); color: white;">
                                        <div class="card-body text-center">
                                            <i class="bi bi-exclamation-triangle-fill" style="font-size: 2rem;"></i>
                                            <h3 class="mt-2 mb-0">${mediumConf.length}</h3>
                                            <small>Needs Confirmation</small>
                                            <div class="mt-2">
                                                <span class="badge" style="background: rgba(255,255,255,0.3); color: white;">Review</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4 mb-3">
                                    <div class="card border-0 shadow-sm" style="background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%); color: white;">
                                        <div class="card-body text-center">
                                            <i class="bi bi-question-circle-fill" style="font-size: 2rem;"></i>
                                            <h3 class="mt-2 mb-0">${lowConf.length}</h3>
                                            <small>Uncertain</small>
                                            <div class="mt-2">
                                                <span class="badge" style="background: rgba(255,255,255,0.3); color: white;">Verify</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Items Lists -->
                            <div id="aiConfidenceItemsList" style="max-height: 60vh; overflow-y: auto; padding-right: 8px;"></div>
                        </div>
                        <div class="modal-footer" style="background: #f8f9fa; border-top: 1px solid #e2e8f0; border-radius: 0 0 16px 16px; padding: 16px 24px;">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" style="border-radius: 10px; padding: 10px 20px;">
                                <i class="bi bi-x-circle me-2"></i>Close
                            </button>
                            <button type="button" class="btn btn-primary" id="addSelectedItemsBtn" style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); border: none; border-radius: 10px; padding: 10px 24px; font-weight: 600; box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);">
                                <i class="bi bi-plus-circle-fill me-2"></i>Add Selected Items (<span id="selectedCount">0</span>)
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(confidenceModal);
            
            // Show the modal using Bootstrap
            if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                const modalInstance = new bootstrap.Modal(confidenceModal, {
                    backdrop: 'static', // Prevent closing by clicking outside
                    keyboard: false    // Prevent closing with ESC
                });
                modalInstance.show();
                
                // Ensure modal stays on top - remove any z-index issues
                confidenceModal.style.zIndex = '1060'; // Higher than default Bootstrap modal (1055)
                
                // Make sure photo modal doesn't interfere
                const photoModal = document.getElementById('photoModal');
                if (photoModal) {
                    photoModal.style.zIndex = '1055'; // Lower than confidence modal
                }
            } else {
                // Fallback if Bootstrap not available
                confidenceModal.style.display = 'block';
                confidenceModal.classList.add('show');
                document.body.classList.add('modal-open');
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop fade show';
                backdrop.style.zIndex = '1055';
                document.body.appendChild(backdrop);
            }
            
        //  FIX #4: Handle item confirmation - "Is this X?" button
        function handleItemConfirmation(button) {
            const itemDataStr = button.getAttribute('data-item');
            const itemName = button.getAttribute('data-item-name');
            const itemConfidence = button.getAttribute('data-item-confidence');
            
            if (!itemDataStr) {
                console.error('No item data found for confirmation');
                return;
            }
            
            try {
                // Decode HTML entities and parse JSON
                const decodedStr = itemDataStr.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
                const item = JSON.parse(decodedStr);
                
                // Find the checkbox for this item and check it
                const card = button.closest('.card');
                const checkbox = card.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    checkbox.checked = true;
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                    
                    // Update selected count
                    const countEl = document.getElementById('selectedCount');
                    if (countEl) {
                        const checked = document.querySelectorAll('#aiConfidenceModal input[type="checkbox"]:checked:not([disabled])').length;
                        countEl.textContent = checked;
                    }
                }
                
                // Update button to show confirmation
                button.disabled = true;
                button.innerHTML = '<i class="bi bi-check-circle-fill me-2"></i>Confirmed!';
                button.style.background = 'linear-gradient(135deg, #10B981 0%, #059669 100%)';
                button.style.opacity = '0.8';
                button.style.cursor = 'default';
                
                // Update card styling to show it's confirmed
                card.style.borderLeft = '4px solid #10B981';
                card.style.background = 'rgba(16, 185, 129, 0.05)';
                
                // Show feedback
                showFeedback(` Confirmed: ${itemName}`, 'success');
                
                // Optionally send confirmation to backend for training data
                const photoData = window.uploadedPhotoData || null;
                fetch('/api/confirmation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        item_name: itemName,
                        confirmed: true,
                        confidence: parseFloat(itemConfidence) || 0,
                        item_data: item,
                        photo_data: photoData,
                        timestamp: new Date().toISOString()
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log(' Confirmation logged successfully');
                    }
                })
                .catch(error => {
                    console.error('Error logging confirmation:', error);
                    // Don't show error to user - confirmation still worked
                });
                
            } catch (error) {
                console.error('Error processing confirmation:', error);
                showFeedback(' Error processing confirmation. Please try again.', 'danger');
            }
        }
        
        //  User Correction Feedback Loop: Handle "This is wrong" button
        function handleItemCorrection(button) {
            const itemDataStr = button.getAttribute('data-item');
            const itemName = button.getAttribute('data-item-name');
            const itemConfidence = button.getAttribute('data-item-confidence');
            
            if (!itemDataStr) {
                console.error('No item data found for correction');
                return;
            }
            
            try {
                // Decode HTML entities and parse JSON
                const decodedStr = itemDataStr.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
                const item = JSON.parse(decodedStr);
                
                // Show prompt for correct label
                const correctLabel = prompt(
                    `The AI detected "${itemName}" but this is incorrect.\n\n` +
                    `What is the correct item name?\n\n` +
                    `(This feedback will be used to improve the AI model)`,
                    itemName
                );
                
                if (!correctLabel || correctLabel.trim() === '') {
                    return; // User cancelled
                }
                
                // Get the uploaded photo data
                const photoData = window.uploadedPhotoData || null;
                
                // Send correction to backend
                fetch('/api/correction', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        detected_name: itemName,
                        correct_name: correctLabel.trim(),
                        confidence: parseFloat(itemConfidence) || 0,
                        item_data: item,
                        photo_data: photoData, // Base64 encoded image
                        timestamp: new Date().toISOString()
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showFeedback(' Thank you! Your correction has been logged and will help improve the AI.', 'success');
                        // Uncheck the item since it's wrong
                        const checkbox = button.closest('.card').querySelector('input[type="checkbox"]');
                        if (checkbox) {
                            checkbox.checked = false;
                            const countEl = document.getElementById('selectedCount');
                            if (countEl) {
                                const checked = document.querySelectorAll('#aiConfidenceModal input[type="checkbox"]:checked:not([disabled])').length;
                                countEl.textContent = checked;
                            }
                        }
                        // Optionally hide or mark the item
                        button.closest('.card').style.opacity = '0.5';
                        button.disabled = true;
                        button.innerHTML = '<i class="bi bi-check-circle me-1"></i>Correction logged';
                        button.style.background = 'rgba(16, 185, 129, 0.1)';
                        button.style.borderColor = '#10B981';
                        button.style.color = '#10B981';
                    } else {
                        showFeedback(' Failed to log correction. Please try again.', 'warning');
                    }
                })
                .catch(error => {
                    console.error('Error logging correction:', error);
                    showFeedback(' Error logging correction. Please try again.', 'danger');
                });
            } catch (error) {
                console.error('Error parsing item data:', error);
                showFeedback(' Error processing correction. Please try again.', 'danger');
            }
        }
        
        // Handle add selected items button - ALWAYS attach handler (even if modal already exists)
        // This ensures the button works even when modal is reused
        function attachAddButtonHandler() {
            const addSelectedBtn = document.getElementById('addSelectedItemsBtn');
            if (!addSelectedBtn) {
                console.error(' addSelectedItemsBtn not found in modal!');
                return;
            }
            
                // Remove any existing listeners by cloning the button
                const newBtn = addSelectedBtn.cloneNode(true);
            if (addSelectedBtn.parentNode) {
                addSelectedBtn.parentNode.replaceChild(newBtn, addSelectedBtn);
            } else {
                console.warn(' Button has no parent, cannot replace');
                return;
            }
                
                newBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                e.stopImmediatePropagation(); // Prevent other handlers from interfering
                
                console.log(' Add Selected Items button clicked!');
                    
                    // Disable button to prevent multiple clicks
                    if (newBtn.disabled) {
                        console.log('Button already clicked, ignoring duplicate request');
                        return;
                    }
                    newBtn.disabled = true;
                    const originalText = newBtn.innerHTML;
                    newBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Adding...';
                    
                    try {
                        // Get all checked checkboxes (excluding disabled ones for auto-added items)
                        const checkboxes = confidenceModal.querySelectorAll('input[type="checkbox"]:checked:not([disabled])');
                const selectedItems = [];
                        
                    console.log(` Found ${checkboxes.length} checked items`);
                    console.log(` Total checkboxes in modal: ${confidenceModal.querySelectorAll('input[type="checkbox"]').length}`);
                        
                        checkboxes.forEach((cb, index) => {
                            try {
                                // Get item data from dataset
                                const itemDataStr = cb.getAttribute('data-item');
                                if (!itemDataStr) {
                                console.warn(` Checkbox ${index} has no data-item attribute`);
                                    return;
                                }
                                
                                // Decode HTML entities and parse JSON
                                const decodedStr = itemDataStr.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
                                const itemData = JSON.parse(decodedStr);
                                
                                // Validate item data
                                if (!itemData || !itemData.name) {
                                console.warn(` Item ${index} missing name:`, itemData);
                                    return;
                                }
                                
                                // Ensure required fields
                                const cleanItem = {
                                    id: itemData.id || `item_${Date.now()}_${index}`,
                                    name: String(itemData.name).trim(),
                                    quantity: itemData.quantity || '1',
                                    expirationDate: itemData.expirationDate || null,
                                    category: itemData.category || 'other',
                                    addedDate: itemData.addedDate || new Date().toISOString(),
                                    confidence: itemData.confidence || 0.5,
                                    is_partial: itemData.is_partial || false,
                                    expiration_risk: itemData.expiration_risk || null
                                };
                                
                                if (cleanItem.name) {
                                    selectedItems.push(cleanItem);
                                console.log(` Added item to selection: ${cleanItem.name}`);
                                }
                            } catch (parseError) {
                            console.error(` Error parsing item ${index}:`, parseError);
                                console.error('Item data string:', cb.getAttribute('data-item'));
                            }
                        });
                        
                    console.log(` Prepared ${selectedItems.length} items to add:`, selectedItems);
                        
                        if (selectedItems.length === 0) {
                            newBtn.disabled = false;
                            newBtn.innerHTML = originalText;
                            showFeedback(' Please select at least one item to add', 'warning');
                            return;
                        }
                        
                        // Send to API
                    console.log(` Sending ${selectedItems.length} items to /api/confirm_items...`);
                        const response = await fetchWithTimeout('/api/confirm_items', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Requested-With': 'XMLHttpRequest'
                            },
                            credentials: 'same-origin',
                            body: JSON.stringify({ items: selectedItems })
                        });
                    
                    console.log(` Response status: ${response.status}`);
                        
                        if (!response.ok) {
                        const errorText = await response.text();
                        console.error(' API error response:', errorText);
                        throw new Error(`HTTP error! status: ${response.status}, body: ${errorText.substring(0, 200)}`);
                        }
                        
                        const data = await response.json();
                    console.log(' API response:', data);
                    console.log(' Response data:', {
                        success: data.success,
                        items_added: data.items_added,
                        skipped_duplicates: data.skipped_duplicates,
                        total_items: data.total_items
                    });
                        
                        if (data.success) {
                            // Show success message even if items_added is 0 (might be duplicates)
                            const itemsAdded = data.items_added || 0;
                            const skipped = data.skipped_duplicates || 0;
                            
                            if (itemsAdded > 0) {
                                showFeedback(` Added ${itemsAdded} item${itemsAdded !== 1 ? 's' : ''} to your pantry${skipped > 0 ? ` (${skipped} duplicate${skipped !== 1 ? 's' : ''} skipped)` : ''}`, 'success');
                            } else if (skipped > 0) {
                                showFeedback(` All items were duplicates and were skipped`, 'warning');
                            } else {
                                showFeedback(` No items were added. Please try again.`, 'warning');
                            }
                            showFeedback(` Added ${data.items_added} item${data.items_added !== 1 ? 's' : ''} to your pantry${data.skipped_duplicates > 0 ? ` (${data.skipped_duplicates} duplicate${data.skipped_duplicates !== 1 ? 's' : ''} skipped)` : ''}`, 'success');
                            
                            // Close confidence modal first
                            if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                                const modalInstance = bootstrap.Modal.getInstance(confidenceModal);
                                if (modalInstance) {
                                    modalInstance.hide();
                                    // Wait for modal to fully close before proceeding
                                    confidenceModal.addEventListener('hidden.bs.modal', function onHidden() {
                                        confidenceModal.removeEventListener('hidden.bs.modal', onHidden);
                                        // Now close photo modal and reset
                                        closePhotoModal();
                                        resetPhotoUploadState();
                                        
                                        // Force reload pantry items with longer delay to ensure backend saved (especially for Firebase)
                                        setTimeout(async () => {
                                            console.log('Reloading pantry items after adding items...');
                                            try {
                                                // Use API-based reload for more reliability
                                                if (typeof reloadPantryItemsFromAPI === 'function') {
                                                    await reloadPantryItemsFromAPI();
                                                } else if (typeof reloadPantryItems === 'function') {
                                                await reloadPantryItems();
                                                } else {
                                                    console.warn('No reload function available, doing page reload');
                                                    window.location.reload();
                                                    return;
                                                }
                                                
                                                // Update empty state and stats
                                                if (typeof updateEmptyState === 'function') {
                                                    updateEmptyState();
                                                }
                                                if (typeof updateSmartSuggestions === 'function') {
                                                    updateSmartSuggestions();
                                                }
                                                
                                                // Double-check: reload again after a delay to ensure items appear
                                                setTimeout(async () => {
                                                    try {
                                                        if (typeof reloadPantryItemsFromAPI === 'function') {
                                                            await reloadPantryItemsFromAPI();
                                                        } else if (typeof reloadPantryItems === 'function') {
                                                        await reloadPantryItems();
                                                        }
                                                        // Final check: if items still not visible, try one more time
                                                        setTimeout(async () => {
                                                            try {
                                                                const container = document.getElementById('pantryItemsContainer');
                                                                if (container && container.children.length === 0 && data.items_added > 0) {
                                                                    console.warn('Items not appearing, trying one more reload...');
                                                                    await reloadPantryItems();
                                                                    // Final check after last retry
                                                                    setTimeout(() => {
                                                                        const finalContainer = document.getElementById('pantryItemsContainer');
                                                                        if (finalContainer && finalContainer.children.length === 0 && data.items_added > 0) {
                                                                            console.warn('Items still not appearing after all retries, doing full page reload');
                                                                    window.location.reload();
                                                                        }
                                                                    }, 500);
                                                                }
                                                            } catch (checkError) {
                                                                console.error('Error checking items:', checkError);
                                                            }
                                                        }, 1500);
                                                    } catch (reloadError) {
                                                        console.error('Error in second reload:', reloadError);
                                                        // Don't reload page immediately, let the final check handle it
                                                    }
                                                }, 1200); // Increased delay for Firebase
                                            } catch (error) {
                                                console.error('Error reloading pantry:', error);
                                                // Try one more time before giving up
                                                setTimeout(async () => {
                                                    try {
                                                        if (typeof reloadPantryItemsFromAPI === 'function') {
                                                            await reloadPantryItemsFromAPI();
                                                        } else if (typeof reloadPantryItems === 'function') {
                                                            await reloadPantryItems();
                                                        }
                                                    } catch (retryError) {
                                                        console.error('Final retry also failed:', retryError);
                                                        // Only reload page if all retries fail
                                                window.location.reload();
                                            }
                                                }, 2000);
                                            }
                                        }, 1500); // Increased initial delay for Firebase sync
                                    }, { once: true });
                                } else {
                                    // Bootstrap not available, close manually
                                    confidenceModal.style.display = 'none';
                                    confidenceModal.classList.remove('show');
                                    document.body.classList.remove('modal-open');
                                    const backdrops = document.querySelectorAll('.modal-backdrop');
                                    backdrops.forEach(b => b.remove());
                                    
                                    closePhotoModal();
                                    resetPhotoUploadState();
                                    
                                    // Reload pantry items
                                    setTimeout(async () => {
                                        try {
                                            if (typeof reloadPantryItemsFromAPI === 'function') {
                                                await reloadPantryItemsFromAPI();
                                            } else if (typeof reloadPantryItems === 'function') {
                                            await reloadPantryItems();
                                            }
                                            if (typeof updateEmptyState === 'function') {
                                                updateEmptyState();
                                            }
                                        } catch (error) {
                                            console.error('Error reloading pantry:', error);
                                        }
                                    }, 1000);
                                    
                                    // Progressive retry with increasing delays for Firebase sync
                                    setTimeout(async () => {
                                        let retryCount = 0;
                                        const maxRetries = 3;
                                        const retryDelays = [1200, 2000, 3000];
                                        
                                        const retryReload = async () => {
                                            if (retryCount >= maxRetries) return;
                                            
                                            setTimeout(async () => {
                                                try {
                                                    console.log(`Reloading pantry (attempt ${retryCount + 1}/${maxRetries})...`);
                                                    await reloadPantryItems();
                                                    
                                                    // Check if successful
                                                    const container = document.getElementById('pantryItemsContainer');
                                                    if (container && container.children.length > 0) {
                                                        console.log(' Reload successful');
                                                        if (typeof updateEmptyState === 'function') updateEmptyState();
                                                        return;
                                                    }
                                                    
                                                    retryCount++;
                                                    retryReload();
                                                } catch (error) {
                                                    console.error(`Reload attempt ${retryCount + 1} failed:`, error);
                                                    retryCount++;
                                                    retryReload();
                                                }
                                            }, retryDelays[retryCount] || 3000);
                                        };
                                        
                                        retryReload();
                                    }, 1500); // Initial delay for Firebase
                                }
                            } else {
                                // No Bootstrap, close manually and reload
                                confidenceModal.style.display = 'none';
                                confidenceModal.classList.remove('show');
                                document.body.classList.remove('modal-open');
                                const backdrops = document.querySelectorAll('.modal-backdrop');
                                backdrops.forEach(b => b.remove());
                                
                                closePhotoModal();
                                resetPhotoUploadState();
                                
                                setTimeout(async () => {
                                    try {
                                        await reloadPantryItems();
                                        setTimeout(async () => {
                                            try {
                                                await reloadPantryItems();
                                            } catch (retryError) {
                                                console.error('Error in reload retry:', retryError);
                                            }
                                        }, 800);
                                    } catch (reloadError) {
                                        console.error('Error reloading pantry:', reloadError);
                                    }
                                }, 1000);
                            }
                        } else {
                            newBtn.disabled = false;
                            newBtn.innerHTML = originalText;
                            const errorMsg = data.error || 'Failed to add items. They may already exist in your pantry.';
                        console.error(' API returned error:', errorMsg);
                            showFeedback(' ' + errorMsg, 'danger');
                            // Still try to reload pantry in case some items were added
                            setTimeout(async () => {
                                try {
                                    if (typeof reloadPantryItemsFromAPI === 'function') {
                                        await reloadPantryItemsFromAPI();
                                    } else if (typeof reloadPantryItems === 'function') {
                                        await reloadPantryItems();
                                    }
                                } catch (reloadError) {
                                    console.error('Error reloading pantry after error:', reloadError);
                                }
                            }, 500);
                        }
                    } catch (error) {
                        console.error(' Error adding items:', error);
                        newBtn.disabled = false;
                        newBtn.innerHTML = originalText;
                        const errorMsg = error.name === 'AbortError' 
                            ? 'Request timed out. Please try again.' 
                            : 'Error: ' + (error.message || 'Failed to add items. Please try again.');
                        showFeedback(errorMsg, 'danger');
                    }
            });
        }
        
        // Attach button handler - do this regardless of whether modal was just created
        attachAddButtonHandler();
            
        // Always attach event listeners (even if modal already exists)
            // Update selected count on checkbox change
        confidenceModal.addEventListener('change', function(e) {
            if (e.target && e.target.type === 'checkbox') {
                const checked = confidenceModal.querySelectorAll('input[type="checkbox"]:checked:not([disabled])').length;
                    const selectedCountEl = document.getElementById('selectedCount');
                    if (selectedCountEl) {
                        selectedCountEl.textContent = checked;
                    }
                }
        });
        
        // Show the modal if it wasn't just created
        if (!modalNeedsSetup) {
            if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                let modalInstance = bootstrap.Modal.getInstance(confidenceModal);
                if (!modalInstance) {
                    modalInstance = new bootstrap.Modal(confidenceModal, {
                        backdrop: 'static',
                        keyboard: false
                    });
                }
                modalInstance.show();
                
                // Ensure modal stays on top
                confidenceModal.style.zIndex = '1060';
                
                // Make sure photo modal doesn't interfere
                const photoModal = document.getElementById('photoModal');
                if (photoModal) {
                    photoModal.style.zIndex = '1050';
                }
            }
        }
        
        // Populate items list - ensure modal is in DOM first
        if (!confidenceModal.parentNode) {
            console.log(' Modal not in DOM yet, appending...');
            document.body.appendChild(confidenceModal);
        }
        
        // If modal already exists, ensure it has the correct structure
        let itemsList = confidenceModal.querySelector('#aiConfidenceItemsList');
        if (!itemsList) {
            console.warn(' aiConfidenceItemsList not found, checking if modal needs recreation...');
            // Check if modal body exists
            const modalBody = confidenceModal.querySelector('.modal-body');
            if (modalBody) {
                // Try to find or create the items list container
                itemsList = document.createElement('div');
                itemsList.id = 'aiConfidenceItemsList';
                itemsList.style.cssText = 'max-height: 60vh; overflow-y: auto; padding-right: 8px;';
                modalBody.appendChild(itemsList);
                console.log(' Created aiConfidenceItemsList element');
            } else {
                console.error(' Modal body not found! Modal structure may be corrupted.');
                console.error('Modal HTML:', confidenceModal.innerHTML.substring(0, 1000));
                // Hard fallback: recreate modal once instead of throwing (prevents "Could not show verification window")
                if (!forceRecreate) {
                    try {
                        confidenceModal.remove();
                    } catch (e) {
                        // ignore
                    }
                    return showAIConfidenceModal(allItems, autoAdded, highConfItems, lowConfItems, true);
                }
                showFeedback('Error displaying detected items. Please refresh and try again.', 'danger');
                return;
            }
        }
        
        if (!itemsList) {
            console.error(' Failed to find or create items list element');
            // Try one more time to create it
            const modalBody = confidenceModal.querySelector('.modal-body');
            if (modalBody) {
                itemsList = document.createElement('div');
                itemsList.id = 'aiConfidenceItemsList';
                itemsList.style.cssText = 'max-height: 60vh; overflow-y: auto; padding-right: 8px;';
                modalBody.appendChild(itemsList);
                console.log(' Created itemsList as fallback');
            } else {
                console.error(' Modal body not found, cannot create items list');
                showFeedback('Unable to create verification window. Please refresh the page and try again.', 'warning');
                return;
            }
        }
        
        itemsList.innerHTML = '';
        
        // Helper function to create item card - Improved UI matching mobile design
        function createItemCard(item, confidenceLevel) {
            const conf = item.confidence || 0;
            const confPercent = Math.round(conf * 100);
            
            //  FIX #4: Auto-detect items that need confirmation
            // Items with "unknown_food (likely X)" or "Possibly: X?" format should always show confirmation
            const itemName = String(item.name || '');
            const needsConfirmation = item.needs_confirmation || 
                                     itemName.includes('unknown_food') || 
                                     itemName.includes('likely') ||
                                     itemName.startsWith('Possibly:') ||
                                     itemName.endsWith('?');
            
            // Determine colors based on confidence level
            let confColor, confLabel, borderColor, bgColor, buttonBgColor;
            if (confidenceLevel === 'high') {
                confColor = '#10B981'; // Green
                confLabel = 'High Confidence';
                borderColor = '#10B981';
                bgColor = 'rgba(16, 185, 129, 0.05)';
                buttonBgColor = 'linear-gradient(135deg, #10B981 0%, #059669 100%)';
            } else if (confidenceLevel === 'medium') {
                confColor = '#F59E0B'; // Orange/Yellow
                confLabel = 'Needs Confirmation';
                borderColor = '#F59E0B';
                bgColor = 'rgba(245, 158, 11, 0.05)';
                buttonBgColor = 'linear-gradient(135deg, #F59E0B 0%, #D97706 100%)';
            } else {
                confColor = '#EF4444'; // Red
                confLabel = 'Uncertain';
                borderColor = '#EF4444';
                bgColor = 'rgba(239, 68, 68, 0.05)';
                buttonBgColor = 'linear-gradient(135deg, #EF4444 0%, #DC2626 100%)';
            }
            
            const isPartial = item.is_partial || false;
            const expirationRisk = item.expiration_risk || null;
            // Allow all items to be selectable, even high confidence ones
            // High confidence items are checked by default but can be unchecked
            const wasAutoAdded = false; // Changed: Don't disable checkboxes for high confidence items
            
            // Expiration risk badge
            let expRiskBadge = '';
            if (expirationRisk) {
                const riskColors = {
                    'expired': '#EF4444',
                    'critical': '#DC2626',
                    'high': '#F59E0B',
                    'medium': '#3B82F6',
                    'low': '#10B981'
                };
                const riskLabels = {
                    'expired': ' Expired',
                    'critical': ' Critical',
                    'high': ' High Risk',
                    'medium': ' Medium',
                    'low': ' Low Risk'
                };
                const riskColor = riskColors[expirationRisk] || '#64748b';
                const riskLabel = riskLabels[expirationRisk] || expirationRisk;
                expRiskBadge = `<span class="badge ms-2" style="background: ${riskColor}; color: white; font-size: 0.75rem;">${riskLabel}</span>`;
            }
            
            // Partial recognition indicator
            let partialBadge = '';
            if (isPartial) {
                partialBadge = `<span class="badge ms-2" style="background: #8B5CF6; color: white; font-size: 0.75rem;"><i class="bi bi-question-circle me-1"></i>Partial</span>`;
            }
            
            // Auto-added indicator
            let autoAddedBadge = '';
            if (wasAutoAdded) {
                autoAddedBadge = `<span class="badge ms-2" style="background: #10B981; color: white; font-size: 0.75rem;"><i class="bi bi-check-circle me-1"></i>Auto-Added</span>`;
            }
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'card mb-3';
            itemDiv.style.border = '1px solid #E2E8F0';
            itemDiv.style.background = '#FFFFFF';
            itemDiv.style.borderRadius = '16px';
            itemDiv.style.transition = 'all 0.2s ease';
            itemDiv.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.04)';
            itemDiv.style.position = 'relative';
            
            // Add hover effect
            itemDiv.onmouseenter = () => {
                itemDiv.style.transform = 'translateY(-2px)';
                itemDiv.style.boxShadow = '0 4px 16px rgba(0, 0, 0, 0.08)';
            };
            itemDiv.onmouseleave = () => {
                itemDiv.style.transform = 'translateY(0)';
                itemDiv.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.04)';
            };
            
            // Add click handler to toggle checkbox when card is clicked
            itemDiv.style.cursor = wasAutoAdded ? 'default' : 'pointer';
            if (!wasAutoAdded) {
                itemDiv.addEventListener('click', (e) => {
                    // Don't toggle if clicking the button, checkbox, or label
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button') ||
                        e.target.type === 'checkbox' || e.target.closest('input[type="checkbox"]') ||
                        e.target.tagName === 'LABEL' || e.target.closest('label')) {
                        return;
                    }
                    const checkbox = itemDiv.querySelector('input[type="checkbox"]');
                    if (checkbox && !checkbox.disabled) {
                        checkbox.checked = !checkbox.checked;
                        // Update count
                        const countEl = document.getElementById('selectedCount');
                        if (countEl) {
                            const checked = document.querySelectorAll('#aiConfidenceModal input[type="checkbox"]:checked:not([disabled])').length;
                            countEl.textContent = checked;
                        }
                        checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });
            }
            
            // Format quantity display
            const quantity = item.quantity || '1';
            const quantityDisplay = quantity.includes(' ') ? quantity : `# ${quantity} ${quantity === '1' ? 'item' : 'items'}`;
            
            // Category display
            const categoryName = (item.category || 'other').charAt(0).toUpperCase() + (item.category || 'other').slice(1);
            
            // Safely stringify item data for checkbox
            let itemDataStr = '{}';
            try {
                const safeItem = {
                    id: item.id || '',
                    name: String(item.name || '').trim(),
                    quantity: String(item.quantity || '1').trim(),
                    expirationDate: item.expirationDate || null,
                    category: String(item.category || 'other').trim(),
                    addedDate: item.addedDate || new Date().toISOString(),
                    confidence: item.confidence || 0,
                    is_partial: item.is_partial || false,
                    expiration_risk: item.expiration_risk || null
                };
                itemDataStr = JSON.stringify(safeItem).replace(/'/g, "&#39;").replace(/"/g, '&quot;');
            } catch (e) {
                console.error('Error stringifying item data:', e, item);
                itemDataStr = JSON.stringify({ name: String(item.name || '').trim() }).replace(/'/g, "&#39;").replace(/"/g, '&quot;');
            }
            
            // Build item image HTML
            const itemPhotoData = window.uploadedPhotoData || '';
            const itemNameEscaped = String(item.name || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            const itemImageHtml = itemPhotoData ? 
                `<img src="${itemPhotoData}" alt="${itemNameEscaped}" style="width: 60px; height: 60px; object-fit: cover; border-radius: 12px; border: 1px solid #E2E8F0; flex-shrink: 0; cursor: pointer;" onclick="const img = this; if (img.style.transform === 'scale(2)') { img.style.transform = 'scale(1)'; img.style.zIndex = 'auto'; img.style.position = 'relative'; } else { img.style.transform = 'scale(2)'; img.style.zIndex = '1000'; img.style.position = 'fixed'; img.style.top = '50%'; img.style.left = '50%'; img.style.marginTop = '-150px'; img.style.marginLeft = '-150px'; img.style.width = '300px'; img.style.height = '300px'; } img.style.transition = 'all 0.3s ease';">` :
                `<div style="width: 60px; height: 60px; background: linear-gradient(135deg, #E2E8F0 0%, #CBD5E1 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; flex-shrink: 0;"><i class="bi bi-image" style="font-size: 1.5rem; color: #94A3B8;"></i></div>`;
            
            itemDiv.innerHTML = `
                <div class="card-body p-3">
                    <div class="d-flex align-items-center gap-3">
                        <!-- Item Image -->
                        ${itemImageHtml}
                        
                        <!-- Item Info -->
                        <div class="flex-grow-1" style="min-width: 0; max-width: 100%; overflow: visible;">
                            <div class="d-flex align-items-start justify-content-between gap-2 mb-2">
                                <div style="flex: 1; min-width: 0; max-width: 100%; overflow: visible;">
                                    <h6 class="mb-1 fw-bold" style="font-size: 1rem; color: #1e293b; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; white-space: normal; overflow: visible; text-overflow: unset; max-width: 100%; line-height: 1.5;">
                                        ${String(item.name || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}
                                    </h6>
                                    <div class="d-flex align-items-center gap-2 flex-wrap">
                                        <small class="text-muted" style="font-size: 0.85rem;">
                                            ${quantityDisplay}
                                        </small>
                                        <span class="badge" style="background: rgba(139, 92, 246, 0.1); color: #6D28D9; border: 1px solid rgba(139, 92, 246, 0.2); font-size: 0.75rem; padding: 4px 8px; border-radius: 6px; font-weight: 500;">
                                            ${categoryName}
                                        </span>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Progress Bar and Checkbox -->
                            <div class="d-flex align-items-center justify-content-between gap-2 mt-2">
                                <div class="flex-grow-1">
                                    <div style="background: #E2E8F0; border-radius: 8px; height: 6px; overflow: hidden; position: relative;">
                                        <div style="background: ${buttonBgColor}; height: 100%; width: ${confPercent}%; border-radius: 8px; transition: width 0.3s ease;"></div>
                                    </div>
                                    <small class="text-muted" style="font-size: 0.75rem; margin-top: 2px; display: block;">${confPercent}%</small>
                                </div>
                                <!-- Checkbox (visible and clickable) -->
                                <div class="form-check" style="flex-shrink: 0; pointer-events: auto; z-index: 10; position: relative;">
                        <input class="form-check-input ai-item-checkbox" type="checkbox" 
                                           checked
                                           data-item='${itemDataStr}'
                               id="ai_item_${(item.id || item.name || 'item').toString().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}"
                                           style="width: 24px; height: 24px; cursor: pointer; margin-top: 0; border: 2px solid #10B981; pointer-events: auto; z-index: 10; position: relative;"
                               onclick="event.stopPropagation(); const countEl = document.getElementById('selectedCount'); if (countEl) { const checked = document.querySelectorAll('#aiConfidenceModal input[type=\\'checkbox\\']:checked:not([disabled])').length; countEl.textContent = checked; }">
                                    <label class="form-check-label ms-2" for="ai_item_${(item.id || item.name || 'item').toString().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}" style="cursor: pointer; font-size: 0.85rem; color: #64748b; pointer-events: auto; z-index: 10; position: relative; user-select: none;"
                                           onclick="event.stopPropagation(); const cb = document.getElementById('ai_item_${(item.id || item.name || 'item').toString().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}'); if (cb) { cb.checked = !cb.checked; const countEl = document.getElementById('selectedCount'); if (countEl) { const checked = document.querySelectorAll('#aiConfidenceModal input[type=\\'checkbox\\']:checked:not([disabled])').length; countEl.textContent = checked; } }">
                                        Select
                                    </label>
                                </div>
                            </div>
                            <!--  FIX #4: Confirmation button for items that need confirmation -->
                            ${needsConfirmation ? `
                            <div class="mt-2 mb-2">
                                <button type="button" class="btn btn-sm btn-success confirmation-btn" 
                                        data-item='${itemDataStr}'
                                        data-item-name="${String(item.name || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}"
                                        data-item-confidence="${conf}"
                                        onclick="event.stopPropagation(); handleItemConfirmation(this);"
                                        style="width: 100%; border-radius: 8px; font-size: 0.85rem; padding: 8px 16px; border: none; color: white; background: linear-gradient(135deg, #10B981 0%, #059669 100%); font-weight: 600; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3); transition: all 0.2s ease;"
                                        onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.4)';"
                                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(16, 185, 129, 0.3)';">
                                    <i class="bi bi-check-circle-fill me-2"></i>Is this ${String(item.name || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}?
                                </button>
                            </div>
                            ` : ''}
                            <!--  User Correction Feedback Loop: "This is wrong" button -->
                            <div class="mt-2">
                                <button type="button" class="btn btn-sm btn-outline-danger correction-btn" 
                                        data-item='${itemDataStr}'
                                        data-item-name="${String(item.name || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;')}"
                                        data-item-confidence="${conf}"
                                        onclick="event.stopPropagation(); handleItemCorrection(this);"
                                        style="width: 100%; border-radius: 8px; font-size: 0.75rem; padding: 6px 12px; border: 1.5px solid #EF4444; color: #EF4444; background: rgba(239, 68, 68, 0.05); transition: all 0.2s ease;"
                                        onmouseover="this.style.background='rgba(239, 68, 68, 0.1)'; this.style.borderColor='#DC2626';"
                                        onmouseout="this.style.background='rgba(239, 68, 68, 0.05)'; this.style.borderColor='#EF4444';">
                                    <i class="bi bi-x-circle me-1"></i>This is wrong
                                </button>
                            </div>
                    </div>
                </div>
            `;
            
            return itemDiv;
        }
        
        // Populate items with error handling
        try {
        // Add high confidence items section
        if (highConf.length > 0) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'mb-4';
            sectionDiv.innerHTML = `
                <h6 class="mb-3" style="color: #10B981; font-weight: 600;">
                    <i class="bi bi-shield-check-fill me-2"></i>High Confidence Items (${highConf.length})
                    <small class="text-muted ms-2"> Automatically added to your pantry</small>
                </h6>
            `;
            itemsList.appendChild(sectionDiv);
            
                highConf.forEach((item, index) => {
                    try {
                itemsList.appendChild(createItemCard(item, 'high'));
                    } catch (itemError) {
                        console.error(`Error creating card for high confidence item ${index}:`, itemError, item);
                    }
            });
        }
        
        // Add medium confidence items section
        if (mediumConf.length > 0) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'mb-4';
            sectionDiv.innerHTML = `
                <h6 class="mb-3" style="color: #F59E0B; font-weight: 600;">
                    <i class="bi bi-exclamation-triangle-fill me-2"></i>Needs Confirmation (${mediumConf.length})
                    <small class="text-muted ms-2">Please review and confirm</small>
                </h6>
            `;
            itemsList.appendChild(sectionDiv);
            
                mediumConf.forEach((item, index) => {
                    try {
                itemsList.appendChild(createItemCard(item, 'medium'));
                    } catch (itemError) {
                        console.error(`Error creating card for medium confidence item ${index}:`, itemError, item);
                    }
            });
        }
        
        // Add low confidence items section
        if (lowConf.length > 0) {
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'mb-4';
            sectionDiv.innerHTML = `
                <h6 class="mb-3" style="color: #EF4444; font-weight: 600;">
                    <i class="bi bi-question-circle-fill me-2"></i>Uncertain Items (${lowConf.length})
                    <small class="text-muted ms-2">Verify these items carefully</small>
                </h6>
            `;
            itemsList.appendChild(sectionDiv);
            
                lowConf.forEach((item, index) => {
                    try {
                itemsList.appendChild(createItemCard(item, 'low'));
                    } catch (itemError) {
                        console.error(`Error creating card for low confidence item ${index}:`, itemError, item);
                    }
            });
        }
        
        // Update selected count
        const checked = confidenceModal.querySelectorAll('input[type="checkbox"]:checked:not([disabled])').length;
        const selectedCountEl = document.getElementById('selectedCount');
        if (selectedCountEl) {
            selectedCountEl.textContent = checked;
            }
        
        // CRITICAL: Re-attach button handler AFTER items are populated
        // This ensures the button works even if modal was reused or items were re-rendered
        setTimeout(() => {
            attachAddButtonHandler();
            console.log(' Button handler re-attached after items populated');
        }, 100);
        } catch (populateError) {
            console.error(' Error populating items list:', populateError);
            console.error('Error stack:', populateError.stack);
            // Show a fallback message in the modal
            if (itemsList) {
                itemsList.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <strong>Error displaying items:</strong> ${populateError.message}
                        <br><small>Please refresh the page and try again.</small>
                    </div>
                    <div class="mt-3">
                        <p><strong>Detected ${allItems.length} items:</strong></p>
                        <ul>
                            ${allItems.map(item => `<li>${item.name || 'Unknown'} (${Math.round((item.confidence || 0) * 100)}%)</li>`).join('')}
                        </ul>
                    </div>
                `;
            }
            throw populateError; // Re-throw to be caught by outer try-catch
        }
        
        // Show modal - ensure it's visible with multiple fallback methods
        console.log(' Attempting to show verification modal...');
        
        // First, ensure photo modal is closed and hidden
        const photoModal = document.getElementById('photoModal');
        if (photoModal) {
        if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                const photoModalInstance = bootstrap.Modal.getInstance(photoModal);
                if (photoModalInstance) {
                    photoModalInstance.hide();
                }
            }
            // Force hide photo modal
            photoModal.style.zIndex = '1050';
            photoModal.style.display = 'none';
            photoModal.classList.remove('show');
            photoModal.setAttribute('aria-hidden', 'true');
        }
        
        // Ensure confidence modal has highest z-index and is visible
        confidenceModal.style.zIndex = '1060';
        confidenceModal.style.display = 'block';
        confidenceModal.style.visibility = 'visible';
        confidenceModal.style.opacity = '1';
        confidenceModal.style.position = 'fixed';
        confidenceModal.setAttribute('aria-hidden', 'false');
        confidenceModal.setAttribute('aria-modal', 'true');
        confidenceModal.classList.add('show');
        
        // Remove any conflicting backdrops (lower z-index)
        const existingBackdrops = document.querySelectorAll('.modal-backdrop');
        existingBackdrops.forEach(b => {
            const zIndex = parseInt(b.style.zIndex || '0');
            if (zIndex < 1055 || isNaN(zIndex)) {
                b.remove();
            }
        });
        
        // Create new backdrop for confidence modal
        let backdrop = document.querySelector('.modal-backdrop');
        if (!backdrop || parseInt(backdrop.style.zIndex || '0') < 1055) {
            if (backdrop) backdrop.remove();
            backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop fade show';
            backdrop.style.zIndex = '1055';
            backdrop.style.opacity = '0.5';
            backdrop.style.backgroundColor = '#000';
            document.body.appendChild(backdrop);
        }
        
        document.body.classList.add('modal-open');
        document.body.style.overflow = 'hidden';
        
        // Try Bootstrap show first
        if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
            try {
                let modalInstance = bootstrap.Modal.getInstance(confidenceModal);
                if (!modalInstance) {
                    modalInstance = new bootstrap.Modal(confidenceModal, {
                        backdrop: 'static',
                        keyboard: false
                    });
                }
            modalInstance.show();
                console.log(' Bootstrap modal.show() called');
            } catch (bootstrapError) {
                console.warn('Bootstrap modal show failed, using manual display:', bootstrapError);
            }
        }
        
        // Force show with multiple checks
        const forceShowModal = (attempt = 1, maxAttempts = 5) => {
            if (attempt > maxAttempts) {
                console.error(' Modal failed to show after all attempts');
                // Last resort: show alert with option to try again
                const itemCount = allItems.length;
                if (confirm(` ${itemCount} item(s) were detected!\n\nWould you like to view them?`)) {
            confidenceModal.style.display = 'block';
                    confidenceModal.style.visibility = 'visible';
                    confidenceModal.style.opacity = '1';
            confidenceModal.classList.add('show');
        }
                return;
            }
            
            const isVisible = confidenceModal.classList.contains('show') && 
                             (confidenceModal.style.display === 'block' || confidenceModal.style.display === 'flex') &&
                             window.getComputedStyle(confidenceModal).display !== 'none';
            
            if (!isVisible) {
                console.warn(` Modal not visible (attempt ${attempt}/${maxAttempts}), forcing display...`);
                confidenceModal.classList.add('show');
                confidenceModal.style.display = 'block';
                confidenceModal.style.visibility = 'visible';
                confidenceModal.style.opacity = '1';
                confidenceModal.style.zIndex = '1060';
                confidenceModal.setAttribute('aria-hidden', 'false');
                document.body.classList.add('modal-open');
                
                // Ensure backdrop exists
                if (!document.querySelector('.modal-backdrop')) {
                    const newBackdrop = document.createElement('div');
                    newBackdrop.className = 'modal-backdrop fade show';
                    newBackdrop.style.zIndex = '1055';
                    document.body.appendChild(newBackdrop);
                }
                
                setTimeout(() => forceShowModal(attempt + 1, maxAttempts), 200);
            } else {
                console.log(' Verification modal is now visible!');
            }
        };
        
        // Start checking immediately, then at intervals
        setTimeout(() => forceShowModal(1, 5), 50);
        setTimeout(() => forceShowModal(2, 5), 150);
        setTimeout(() => forceShowModal(3, 5), 300);
        setTimeout(() => forceShowModal(4, 5), 500);
        
        console.log(' Modal display initiated. Items count:', {
            high: highConf.length,
            medium: mediumConf.length,
            low: lowConf.length,
            total: allItems.length
        });
    }
    
    // Helper function to reset photo upload state
    function resetPhotoUploadState() {
        selectedFile = null;
        if (photoInput) photoInput.value = '';
        if (mobileCameraInput) mobileCameraInput.value = '';
        
        // Reset preview section
        if (previewSection) {
            previewSection.style.display = 'none';
        }
        if (uploadZone) {
            uploadZone.style.display = 'block';
            uploadZone.style.opacity = '1';
        }
        if (imagePreview) {
            imagePreview.src = '';
            imagePreview.style.display = 'none';
        }
        
        // Clear progress feedback
        const progressFeedback = document.getElementById('uploadProgressFeedback');
        if (progressFeedback) {
            progressFeedback.style.display = 'none';
        }
        
        // Clear feedback message
        const uploadFeedback = document.getElementById('uploadFeedback');
        if (uploadFeedback) {
            uploadFeedback.style.display = 'none';
            uploadFeedback.className = 'feedback-message';
            uploadFeedback.innerHTML = '';
        }
        
        // Reset display states with smooth transitions
        if (cameraView) {
            cameraView.style.opacity = '0';
            setTimeout(() => {
                cameraView.style.display = 'none';
                cameraView.style.opacity = '1';
            }, 150);
        }
        if (previewSection) {
            previewSection.style.opacity = '0';
            setTimeout(() => {
                previewSection.style.display = 'none';
                previewSection.style.opacity = '1';
            }, 150);
        }
        if (uploadZone) {
            uploadZone.style.display = 'block';
            uploadZone.style.opacity = '0';
            setTimeout(() => {
                uploadZone.style.opacity = '1';
            }, 50);
        }
        
        // Reset drag over state
        if (dropZone) {
            dropZone.classList.remove('dragover');
        }
        
        // Clear image preview
        if (imagePreview) {
            imagePreview.src = '';
        }
        
        stopCamera();
        resetPhotoUploadButton();
    }
    
    // Helper function to reset upload button
    function resetPhotoUploadButton() {
        if (uploadBtn) {
            uploadBtn.disabled = false;
            uploadBtn.classList.remove('loading');
        }
        if (uploadBtnText) {
            uploadBtnText.textContent = 'Analyze & Add Items';
        }
    }

    // Reset modal when closed
    if (photoModal) {
        // Handle modal shown
        photoModal.addEventListener('show.bs.modal', () => {
            // Prevent body scroll when modal opens (simplified - no position locking)
            document.body.style.overflow = 'hidden';
            document.body.classList.add('modal-open');
            
            // Ensure backdrop doesn't block clicks
            setTimeout(() => {
                const backdrop = document.querySelector('.modal-backdrop');
                if (backdrop) {
                    backdrop.style.pointerEvents = 'auto';
                    backdrop.style.zIndex = '1040';
                }
            }, 10);
            
            // Ensure modal content and all children are clickable
            const modalContent = photoModal.querySelector('.modal-content');
            const modalDialog = photoModal.querySelector('.modal-dialog');
            if (modalContent) {
                modalContent.style.pointerEvents = 'auto';
                modalContent.style.zIndex = '10000';
                modalContent.style.position = 'relative';
                // Ensure all interactive elements are clickable
                const allElements = modalContent.querySelectorAll('*');
                allElements.forEach(el => {
                    el.style.pointerEvents = 'auto';
                    if (el.tagName === 'BUTTON' || el.tagName === 'INPUT' || el.tagName === 'A' || el.getAttribute('role') === 'button') {
                        el.style.cursor = 'pointer';
                        el.style.zIndex = '10001';
                        el.style.position = 'relative';
                    }
                });
                // Specifically ensure preview section buttons are clickable
                const previewSection = modalContent.querySelector('#previewSection');
                if (previewSection) {
                    previewSection.style.pointerEvents = 'auto';
                    previewSection.style.zIndex = '1000';
                    previewSection.style.position = 'relative';
                    const previewButtons = previewSection.querySelectorAll('button');
                    previewButtons.forEach(btn => {
                        btn.style.pointerEvents = 'auto';
                        btn.style.zIndex = '1001';
                        btn.style.position = 'relative';
                        btn.style.cursor = 'pointer';
                        // Ensure buttons are not disabled unless they should be
                        if (btn.id !== 'uploadBtn' || !btn.classList.contains('loading')) {
                            btn.disabled = false;
                        }
                    });
                }
            }
            if (modalDialog) {
                modalDialog.style.pointerEvents = 'auto';
                modalDialog.style.zIndex = '9999';
                modalDialog.style.position = 'relative';
            }
            
            // Force enable pointer events on modal
            photoModal.style.pointerEvents = 'auto';
            photoModal.style.zIndex = '9999';
        });
        
        // Also handle when modal is fully shown - focus trap
        photoModal.addEventListener('shown.bs.modal', () => {
            // Ensure preview section buttons are clickable when modal is shown
            const previewSection = photoModal.querySelector('#previewSection');
            if (previewSection && previewSection.style.display !== 'none') {
                const previewButtons = previewSection.querySelectorAll('button');
                previewButtons.forEach(btn => {
                    btn.style.pointerEvents = 'auto';
                    btn.style.zIndex = '1001';
                    btn.style.position = 'relative';
                    btn.style.cursor = 'pointer';
                    if (btn.id !== 'uploadBtn' || !btn.classList.contains('loading')) {
                        btn.disabled = false;
                    }
                });
            }
            // Focus trap - focus first focusable element
            const firstFocusable = photoModal.querySelector('button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])');
            if (firstFocusable) {
                firstFocusable.focus();
            }
            
            // Double-check all elements are clickable
            const modalContent = photoModal.querySelector('.modal-content');
            const modalDialog = photoModal.querySelector('.modal-dialog');
            if (modalContent) {
                modalContent.style.pointerEvents = 'auto';
                modalContent.style.zIndex = '10000';
                modalContent.style.position = 'relative';
                const allButtons = modalContent.querySelectorAll('button, input, a, [role="button"], .btn, .btn-close, select');
                allButtons.forEach(btn => {
                    btn.style.pointerEvents = 'auto';
                    btn.style.cursor = btn.tagName === 'INPUT' || btn.tagName === 'SELECT' ? 'default' : 'pointer';
                    btn.style.zIndex = '10';
                    btn.style.position = 'relative';
                });
            }
            if (modalDialog) {
                modalDialog.style.pointerEvents = 'auto';
                modalDialog.style.zIndex = '9999';
                modalDialog.style.position = 'relative';
            }
            
            // Ensure backdrop is properly configured - but don't close on click (backdrop is static)
            setTimeout(() => {
                const backdrop = document.querySelector('.modal-backdrop');
                if (backdrop) {
                    // Backdrop should not close modal (static backdrop)
                    backdrop.style.pointerEvents = 'auto';
                    backdrop.style.zIndex = '9998';
                    // Remove any existing click handlers that might close the modal
                    backdrop.onclick = null;
                }
            }, 50);
            
            // Ensure close button works
            const closeBtn = photoModal.querySelector('[data-bs-dismiss="modal"]');
            if (closeBtn) {
                closeBtn.style.pointerEvents = 'auto';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.zIndex = '10';
                closeBtn.style.position = 'relative';
            }
        });
        
        // Add escape key handler
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && photoModal.classList.contains('show')) {
                const bootstrapModal = bootstrap.Modal.getInstance(photoModal);
                if (bootstrapModal) {
                    bootstrapModal.hide();
                } else {
                    const closeBtn = photoModal.querySelector('[data-bs-dismiss="modal"]');
                    if (closeBtn) {
                        closeBtn.click();
                    }
                }
            }
        });
        
        // Handle modal hiding (before close animation)
        photoModal.addEventListener('hide.bs.modal', () => {
            // Start cleanup early
            stopCamera();
            
            // Remove animation-disabling class (if it exists)
            document.body.classList.remove('modal-open-no-animations');
        });
        
        // Handle modal fully closed (after animation) - restore body scroll
        photoModal.addEventListener('hidden.bs.modal', () => {
            resetPhotoUploadState();
            
            // Restore body scroll position
            const scrollY = document.body.style.top;
            document.body.style.position = '';
            document.body.style.top = '';
            document.body.style.width = '';
            if (scrollY) {
                window.scrollTo(0, parseInt(scrollY || '0') * -1);
            }
            
            // Comprehensive cleanup - remove all backdrops and restore body
            const cleanup = () => {
                // Remove all modal backdrops
                const backdrops = document.querySelectorAll('.modal-backdrop');
                backdrops.forEach(backdrop => {
                    backdrop.style.display = 'none';
                    backdrop.style.opacity = '0';
                    backdrop.style.visibility = 'hidden';
                    backdrop.style.pointerEvents = 'none';
                    backdrop.remove();
                });
                
                // Remove modal-open class from body
                document.body.classList.remove('modal-open');
                
                // Restore body styles completely
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
                document.body.style.pointerEvents = '';
                document.body.style.position = '';
                document.body.style.overflowX = '';
                document.body.style.overflowY = '';
                
                // Ensure modal is properly hidden
                if (photoModal) {
                    photoModal.classList.remove('show');
                    photoModal.style.display = 'none';
                    photoModal.setAttribute('aria-hidden', 'true');
                    photoModal.removeAttribute('aria-modal');
                }
                
                // Force remove any remaining backdrop elements
                const remainingBackdrops = document.querySelectorAll('.modal-backdrop');
                remainingBackdrops.forEach(backdrop => {
                    backdrop.style.display = 'none';
                    backdrop.style.pointerEvents = 'none';
                    backdrop.remove();
                });
                
                // Ensure no backdrop classes remain
                document.body.classList.remove('modal-open');
                
                // Force enable pointer events on body
                document.body.style.pointerEvents = 'auto';
            };
            
            // Cleanup immediately and also after delays to catch any delayed Bootstrap cleanup
            cleanup();
            setTimeout(cleanup, 50);
            setTimeout(cleanup, 100);
            setTimeout(cleanup, 200);
            setTimeout(cleanup, 500);
            setTimeout(cleanup, 1000);
        });
        
        // Focus trap - prevent tabbing outside modal
        photoModal.addEventListener('keydown', (e) => {
            if (e.key === 'Tab' && photoModal.classList.contains('show')) {
                const focusableElements = photoModal.querySelectorAll(
                    'button:not([disabled]), [href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
                );
                const firstElement = focusableElements[0];
                const lastElement = focusableElements[focusableElements.length - 1];
                
                if (e.shiftKey) {
                    // Shift + Tab
                    if (document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    }
                } else {
                    // Tab
                    if (document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            }
        });
    }

    // Check camera availability on page load
    window.addEventListener('DOMContentLoaded', () => {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            // Disable live camera button (getUserMedia not available)
            if (openCameraBtn) {
            openCameraBtn.disabled = true;
            openCameraBtn.innerHTML = '<i class="bi bi-camera-video-off me-2"></i>HTTPS Only';
            openCameraBtn.title = 'Live camera requires HTTPS or localhost. Use "Take Photo" button instead.';
            openCameraBtn.classList.add('opacity-50');
            }
            
            // Make "Take Photo" button more prominent
            if (mobileCameraBtn) {
            mobileCameraBtn.classList.remove('btn-success');
            mobileCameraBtn.classList.add('btn-success', 'pulse');
            }
        }

        // Handle expiration days selector for recipe suggestions
        const recipeBtn = document.getElementById('recipeBtn');
        const expiringDaysSelect = document.getElementById('expiringDays');
        
        if (recipeBtn && expiringDaysSelect) {
            // Update recipe button state based on pantry items
            function updateRecipeButtonState() {
                const items = document.querySelectorAll('.pantry-item-wrapper');
                const hasItems = items.length > 0;
                
                if (hasItems) {
                    recipeBtn.disabled = false;
                    recipeBtn.style.opacity = '1';
                    recipeBtn.style.cursor = 'pointer';
                    recipeBtn.title = 'Get recipe suggestions based on your pantry items';
                } else {
                    recipeBtn.disabled = true;
                    recipeBtn.style.opacity = '0.6';
                    recipeBtn.style.cursor = 'not-allowed';
                    recipeBtn.title = 'Add items to your pantry first to get recipe suggestions';
                }
            }
            
            // Check state on load and when items change
            updateRecipeButtonState();
            
            // Monitor for pantry changes
            const observer = new MutationObserver(() => {
                updateRecipeButtonState();
            });
            const pantryContainer = document.getElementById('pantryItemsContainer');
            if (pantryContainer) {
                observer.observe(pantryContainer, { childList: true, subtree: true });
            }
            
            recipeBtn.addEventListener('click', (e) => {
                const items = document.querySelectorAll('.pantry-item-wrapper');
                if (items.length === 0) {
                    e.preventDefault();
                    showFeedback('Please add items to your pantry first to get recipe suggestions!', 'warning');
                    return false;
                }
                
                const expiringDays = expiringDaysSelect.value;
                if (expiringDays && expiringDays.trim() !== '') {
                    // If expiring days is selected, add it to the URL
                    e.preventDefault();
                    const baseUrl = recipeBtn.getAttribute('href') || '{{ url_for("suggest_recipe") }}';
                    window.location.href = `${baseUrl}?expiring_days=${expiringDays}`;
                }
                // If no expiring days selected, let the link work normally (don't prevent default)
            });
        }
    });
    
    // Function to update expiration badge colors and card backgrounds - can be called multiple times
    function updateExpirationBadges() {
        // Update badges
        const badges = document.querySelectorAll('[data-exp-date]');
        if (!badges || badges.length === 0) {
            return;  // No badges to update
        }
        
        badges.forEach(function(badge) {
            try {
                if (!badge || !badge.getAttribute) {
                    return;  // Invalid badge element
                }
                
                const expDateStr = badge.getAttribute('data-exp-date');
                if (!expDateStr || expDateStr.trim() === '' || expDateStr === '9999-12-31' || expDateStr === 'None' || expDateStr === 'null') {
                    badge.classList.remove('expiration-expired', 'expiration-soon', 'expiration-fresh');
                    badge.classList.add('expiration-none');
                    return;
                }
                
                // Parse date string - handle both YYYY-MM-DD and ISO datetime formats
                let expiration;
                const dateStr = expDateStr.trim();
                
                // Check if it's a simple date format (YYYY-MM-DD)
                if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                    // Parse YYYY-MM-DD format (most reliable)
                    const parts = dateStr.split('-').map(Number);
                    if (parts.length === 3 && parts[0] > 1900 && parts[0] < 2100 && parts[1] >= 1 && parts[1] <= 12 && parts[2] >= 1 && parts[2] <= 31) {
                        expiration = new Date(parts[0], parts[1] - 1, parts[2]);
                    } else {
                        throw new Error('Invalid date parts');
                    }
                } else if (dateStr.includes('T')) {
                    // ISO datetime format
                    expiration = new Date(dateStr);
                } else {
                    // Try parsing as date string
                    expiration = new Date(dateStr);
                }
                
                // Check if date is valid
                if (!expiration || isNaN(expiration.getTime())) {
                    console.warn('Invalid expiration date format:', dateStr);
                    badge.classList.remove('expiration-expired', 'expiration-soon', 'expiration-fresh');
                    badge.classList.add('expiration-none');
                    return;
                }
                
                // Calculate days difference
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                expiration.setHours(0, 0, 0, 0);
                const daysDiff = Math.floor((expiration - today) / (1000 * 60 * 60 * 24));
                
                // Remove all expiration classes first
                badge.classList.remove('expiration-expired', 'expiration-soon', 'expiration-fresh', 'expiration-none');
                
                // Apply appropriate class based on days until expiration
                let expirationClass = '';
                if (daysDiff < 0) {
                    // Expired (past date)
                    expirationClass = 'expiration-expired';
                    badge.classList.add('expiration-expired');
                } else if (daysDiff < 3) {
                    // Expiring very soon (0-2 days) - red/orange
                    expirationClass = 'expiration-soon';
                    badge.classList.add('expiration-soon');
                } else if (daysDiff < 7) {
                    // Expiring soon (3-6 days) - orange/yellow
                    expirationClass = 'expiration-soon';
                    badge.classList.add('expiration-soon');
                } else {
                    // Fresh (7+ days) - green
                    expirationClass = 'expiration-fresh';
                    badge.classList.add('expiration-fresh');
                }
                
                // Also update the parent card background
                const card = badge.closest('.pantry-item-card');
                if (card) {
                    card.classList.remove('expiration-expired-card', 'expiration-soon-card', 'expiration-fresh-card');
                    card.classList.add(expirationClass + '-card');
                }
            } catch (e) {
                // If there's any error parsing the date, use default styling
                console.error('Error parsing expiration date:', badge?.getAttribute('data-exp-date'), e);
                if (badge && badge.classList) {
                    badge.classList.remove('expiration-expired', 'expiration-soon', 'expiration-fresh');
                    badge.classList.add('expiration-none');
                }
            }
        });
    }
    
    // Set default expiration date to one week from now
    function setDefaultExpirationDate() {
        const expirationInput = document.getElementById('expirationInput');
        if (expirationInput && !expirationInput.value) {
            const today = new Date();
            const oneWeekLater = new Date(today);
            oneWeekLater.setDate(today.getDate() + 7);
            const year = oneWeekLater.getFullYear();
            const month = String(oneWeekLater.getMonth() + 1).padStart(2, '0');
            const day = String(oneWeekLater.getDate()).padStart(2, '0');
            expirationInput.value = `${year}-${month}-${day}`;
        }
    }
    
    // Update pantry item card backgrounds based on expiration dates
    function updatePantryCardBackgrounds() {
        const wrappers = document.querySelectorAll('.pantry-item-wrapper[data-expiration-date]');
        wrappers.forEach(function(wrapper) {
            try {
                const expDateStr = wrapper.getAttribute('data-expiration-date');
                if (!expDateStr || expDateStr.trim() === '' || expDateStr === '9999-12-31' || expDateStr === 'None' || expDateStr === 'null') {
                    return;
                }
                
                // Parse date string
                let expiration;
                const dateStr = expDateStr.trim();
                
                if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                    const parts = dateStr.split('-').map(Number);
                    if (parts.length === 3 && parts[0] > 1900 && parts[0] < 2100 && parts[1] >= 1 && parts[1] <= 12 && parts[2] >= 1 && parts[2] <= 31) {
                        expiration = new Date(parts[0], parts[1] - 1, parts[2]);
                    } else {
                        return;
                    }
                } else if (dateStr.includes('T')) {
                    expiration = new Date(dateStr);
                } else {
                    expiration = new Date(dateStr);
                }
                
                if (!expiration || isNaN(expiration.getTime())) {
                    return;
                }
                
                // Calculate days difference
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                expiration.setHours(0, 0, 0, 0);
                const daysDiff = Math.floor((expiration - today) / (1000 * 60 * 60 * 24));
                
                // Update card background
                const card = wrapper.querySelector('.pantry-item-card');
                if (card) {
                    card.classList.remove('expiration-expired-card', 'expiration-soon-card', 'expiration-fresh-card');
                    if (daysDiff < 0) {
                        card.classList.add('expiration-expired-card');
                    } else if (daysDiff < 7) {
                        card.classList.add('expiration-soon-card');
                    } else {
                        card.classList.add('expiration-fresh-card');
                    }
                }
            } catch (e) {
                // Silently ignore errors
            }
        });
    }
    
    // Sort pantry items
    // Enhanced category detection function with better accuracy
    function getItemCategory(itemName) {
        const name = itemName.toLowerCase().trim();
        
        // More specific matching - check exact matches first, then partial
        // Proteins (meat, poultry, seafood, eggs)
        const proteins = {
            exact: ['chicken', 'beef', 'pork', 'fish', 'salmon', 'tuna', 'turkey', 'egg', 'eggs', 'tofu', 'meat', 'steak', 'bacon', 'sausage', 'ham', 'shrimp', 'prawn', 'crab', 'lobster', 'lamb', 'duck', 'pork', 'veal', 'venison', 'bison', 'chicken breast', 'chicken thigh', 'ground beef', 'ground turkey', 'ribeye', 'sirloin', 'tilapia', 'cod', 'halibut', 'mackerel', 'sardine', 'anchovy'],
            partial: ['chicken', 'beef', 'pork', 'fish', 'salmon', 'tuna', 'turkey', 'egg', 'eggs', 'tofu', 'meat', 'protein', 'steak', 'bacon', 'sausage', 'ham', 'shrimp', 'prawn', 'crab', 'lobster', 'lamb', 'duck', 'seafood', 'poultry']
        };
        if (proteins.exact.includes(name) || proteins.partial.some(p => name.includes(p))) return 'proteins';
        
        // Vegetables (more comprehensive list)
        const vegetables = {
            exact: ['broccoli', 'carrot', 'tomato', 'onion', 'garlic', 'lettuce', 'spinach', 'cucumber', 'pepper', 'potato', 'celery', 'corn', 'peas', 'bean', 'cabbage', 'cauliflower', 'zucchini', 'eggplant', 'asparagus', 'mushroom', 'kale', 'arugula', 'beet', 'bell pepper', 'brussels sprout', 'cabbage', 'carrot', 'celery', 'corn', 'cucumber', 'eggplant', 'green bean', 'leek', 'lettuce', 'onion', 'pepper', 'potato', 'radish', 'spinach', 'squash', 'tomato', 'zucchini'],
            partial: ['broccoli', 'carrot', 'tomato', 'onion', 'garlic', 'lettuce', 'spinach', 'cucumber', 'pepper', 'potato', 'celery', 'corn', 'peas', 'bean', 'vegetable', 'cabbage', 'cauliflower', 'zucchini', 'eggplant', 'asparagus', 'mushroom', 'kale', 'lettuce', 'greens', 'sprout']
        };
        if (vegetables.exact.includes(name) || vegetables.partial.some(v => name.includes(v))) return 'vegetables';
        
        // Dairy (milk products, cheese, yogurt)
        const dairy = {
            exact: ['milk', 'cheese', 'yogurt', 'butter', 'cream', 'sour cream', 'cottage cheese', 'mozzarella', 'cheddar', 'parmesan', 'feta', 'swiss', 'gouda', 'brie', 'ricotta', 'cream cheese', 'heavy cream', 'half and half', 'buttermilk', 'greek yogurt', 'yogurt'],
            partial: ['milk', 'cheese', 'yogurt', 'butter', 'cream', 'dairy', 'sour cream', 'cottage cheese', 'mozzarella', 'cheddar', 'parmesan', 'feta', 'dairy']
        };
        if (dairy.exact.includes(name) || dairy.partial.some(d => name.includes(d))) return 'dairy';
        
        // Fruits (fresh and dried)
        const fruits = {
            exact: ['apple', 'banana', 'orange', 'berry', 'strawberry', 'blueberry', 'grape', 'mango', 'pineapple', 'peach', 'pear', 'cherry', 'kiwi', 'lemon', 'lime', 'avocado', 'watermelon', 'cantaloupe', 'honeydew', 'plum', 'apricot', 'nectarine', 'grapefruit', 'tangerine', 'coconut', 'papaya', 'dragon fruit', 'passion fruit'],
            partial: ['apple', 'banana', 'orange', 'berry', 'strawberry', 'blueberry', 'grape', 'mango', 'pineapple', 'peach', 'pear', 'cherry', 'kiwi', 'lemon', 'lime', 'fruit', 'avocado']
        };
        if (fruits.exact.includes(name) || fruits.partial.some(f => name.includes(f))) return 'fruits';
        
        // Snacks (chips, crackers, sweets)
        const snacks = {
            exact: ['chip', 'cracker', 'cookie', 'biscuit', 'pretzel', 'popcorn', 'nuts', 'almond', 'peanut', 'cashew', 'trail mix', 'granola', 'bar', 'candy', 'chocolate', 'chips', 'crackers', 'cookies', 'pretzels', 'popcorn', 'almonds', 'peanuts', 'cashews', 'walnuts', 'pecans', 'pistachios'],
            partial: ['chip', 'cracker', 'cookie', 'biscuit', 'pretzel', 'popcorn', 'nuts', 'almond', 'peanut', 'cashew', 'trail mix', 'granola', 'bar', 'candy', 'chocolate', 'snack']
        };
        if (snacks.exact.includes(name) || snacks.partial.some(s => name.includes(s))) return 'snacks';
        
        // Grains (bread, rice, pasta, cereals)
        const grains = {
            exact: ['bread', 'rice', 'pasta', 'noodle', 'flour', 'wheat', 'oats', 'quinoa', 'barley', 'cereal', 'bagel', 'muffin', 'roll', 'bun', 'tortilla', 'wrap', 'pita', 'naan', 'white rice', 'brown rice', 'wild rice', 'spaghetti', 'penne', 'macaroni', 'fettuccine', 'linguine'],
            partial: ['bread', 'rice', 'pasta', 'noodle', 'flour', 'wheat', 'oats', 'quinoa', 'barley', 'cereal', 'grain']
        };
        if (grains.exact.includes(name) || grains.partial.some(g => name.includes(g))) return 'grains';
        
        // Beverages (drinks, juices, coffee, tea)
        const beverages = {
            exact: ['juice', 'soda', 'water', 'coffee', 'tea', 'beer', 'wine', 'drink', 'beverage', 'orange juice', 'apple juice', 'cranberry juice', 'lemonade', 'iced tea', 'green tea', 'black tea', 'herbal tea', 'espresso', 'latte', 'cappuccino', 'smoothie', 'shake'],
            partial: ['juice', 'soda', 'water', 'coffee', 'tea', 'beer', 'wine', 'drink', 'beverage']
        };
        if (beverages.exact.includes(name) || beverages.partial.some(b => name.includes(b))) return 'beverages';
        
        // Default
        return 'other';
    }
    
    // Get category display name, icon, and color (supports both frontend and backend category names)
    function getCategoryDisplay(category) {
        if (!category) category = 'other';
        category = category.toLowerCase().trim();
        
        const categoryInfo = {
            'proteins': { name: 'Proteins', icon: 'bi-droplet-fill', color: '#EF4444', gradient: 'linear-gradient(90deg, #EF4444 0%, #DC2626 100%)' },
            'meat': { name: 'Meat', icon: 'bi-droplet-fill', color: '#EF4444', gradient: 'linear-gradient(90deg, #EF4444 0%, #DC2626 100%)' },
            'vegetables': { name: 'Vegetables', icon: 'bi-flower1', color: '#10B981', gradient: 'linear-gradient(90deg, #10B981 0%, #059669 100%)' },
            'produce': { name: 'Produce', icon: 'bi-flower1', color: '#10B981', gradient: 'linear-gradient(90deg, #10B981 0%, #059669 100%)' },
            'fruits': { name: 'Fruits', icon: 'bi-apple', color: '#F59E0B', gradient: 'linear-gradient(90deg, #F59E0B 0%, #D97706 100%)' },
            'dairy': { name: 'Dairy', icon: 'bi-cup-straw', color: '#3B82F6', gradient: 'linear-gradient(90deg, #3B82F6 0%, #2563EB 100%)' },
            'grains': { name: 'Grains', icon: 'bi-wheat', color: '#8B5CF6', gradient: 'linear-gradient(90deg, #8B5CF6 0%, #7C3AED 100%)' },
            'snacks': { name: 'Snacks', icon: 'bi-bag', color: '#EC4899', gradient: 'linear-gradient(90deg, #EC4899 0%, #DB2777 100%)' },
            'beverages': { name: 'Beverages', icon: 'bi-cup', color: '#06B6D4', gradient: 'linear-gradient(90deg, #06B6D4 0%, #0891B2 100%)' },
            'bakery': { name: 'Bakery', icon: 'bi-bread-slice', color: '#F59E0B', gradient: 'linear-gradient(90deg, #F59E0B 0%, #D97706 100%)' },
            'canned_goods': { name: 'Canned Goods', icon: 'bi-box-seam', color: '#F97316', gradient: 'linear-gradient(90deg, #F97316 0%, #EA580C 100%)' },
            'canned goods': { name: 'Canned Goods', icon: 'bi-box-seam', color: '#F97316', gradient: 'linear-gradient(90deg, #F97316 0%, #EA580C 100%)' },
            'condiments': { name: 'Condiments', icon: 'bi-droplet', color: '#8B5CF6', gradient: 'linear-gradient(90deg, #8B5CF6 0%, #7C3AED 100%)' },
            'frozen': { name: 'Frozen', icon: 'bi-snow', color: '#06B6D4', gradient: 'linear-gradient(90deg, #06B6D4 0%, #0891B2 100%)' },
            'other': { name: 'Other', icon: 'bi-box', color: '#64748B', gradient: 'linear-gradient(90deg, #64748B 0%, #475569 100%)' }
        };
        return categoryInfo[category] || categoryInfo['other'];
    }
    
    // Update all category accent bars with their category colors
    function updateCategoryAccentBars() {
        const accentBars = document.querySelectorAll('.category-accent-bar');
        accentBars.forEach(bar => {
            const category = bar.getAttribute('data-category');
            if (category && typeof getCategoryDisplay === 'function') {
                const catInfo = getCategoryDisplay(category);
                if (catInfo && catInfo.gradient) {
                    bar.style.background = catInfo.gradient;
                }
            }
        });
    }
    
    // Category order for sorting
    const categoryOrder = {
        'proteins': 1,
        'vegetables': 2,
        'fruits': 3,
        'dairy': 4,
        'grains': 5,
        'snacks': 6,
        'beverages': 7,
        'other': 8
    };
    
    // Store current sort type to re-apply after reload
    let currentSortType = null;
    let currentSearchTerm = '';
    
    // Search functionality with case-insensitive filtering and debouncing
    let searchTimeout = null;
    const searchInput = document.getElementById('searchItemsInput');
    if (searchInput) {
        searchInput.addEventListener('input', function(e) {
            const searchTerm = e.target.value.trim().toLowerCase();
            currentSearchTerm = searchTerm;
            
            // Debounce search to avoid excessive filtering
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                filterPantryItems(searchTerm);
            }, 300); // 300ms delay
        });
        
        // Clear search on Escape key
        searchInput.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                e.target.value = '';
                currentSearchTerm = '';
                filterPantryItems('');
            }
        });
    }
    
    // Filter pantry items by search term (case-insensitive)
    function filterPantryItems(searchTerm) {
        const container = document.getElementById('pantryItemsContainer');
        if (!container) return;
        
        const items = container.querySelectorAll('.pantry-item-wrapper');
        let visibleCount = 0;
        
        items.forEach(item => {
            const itemName = item.getAttribute('data-item-name') || '';
            const itemNameLower = itemName.toLowerCase();
            
            // Case-insensitive search
            if (!searchTerm || itemNameLower.includes(searchTerm.toLowerCase())) {
                item.style.display = '';
                visibleCount++;
            } else {
                item.style.display = 'none';
            }
        });
        
        // Show/hide "no results" message
        let noResultsMsg = document.getElementById('noSearchResults');
        if (!noResultsMsg && searchTerm && visibleCount === 0) {
            noResultsMsg = document.createElement('div');
            noResultsMsg.id = 'noSearchResults';
            noResultsMsg.className = 'col-12 text-center py-5';
            noResultsMsg.innerHTML = `
                <i class="bi bi-search display-4 text-muted mb-3"></i>
                <h5 class="text-muted">No matching items</h5>
                <p class="text-muted small">Try a different search term</p>
            `;
            container.appendChild(noResultsMsg);
        } else if (noResultsMsg && (!searchTerm || visibleCount > 0)) {
            noResultsMsg.remove();
        }
    }
    
    function sortPantry(sortType) {
        console.log(' Sorting pantry by:', sortType);
        const container = document.getElementById('pantryItemsContainer');
        if (!container) {
            console.error(' Pantry container not found');
            return;
        }
        
        // Get all items first (including hidden ones for proper sorting)
        const allItems = Array.from(container.querySelectorAll('.pantry-item-wrapper'));
        
        if (allItems.length === 0) {
            console.warn(' No items found in pantry container');
            return;
        }
        
        console.log(` Found ${allItems.length} total items`);
        
        // Get only visible items (respecting search and filter)
        const visibleItems = allItems.filter(item => {
            const style = window.getComputedStyle(item);
            return style.display !== 'none' && style.visibility !== 'hidden';
        });
        
        // Use visible items for sorting, but keep track of all items
        // If no visible items (all filtered), sort all items anyway
        const itemsToSort = visibleItems.length > 0 ? visibleItems : allItems;
        
        console.log(` ${visibleItems.length} visible items, sorting ${itemsToSort.length} items`);
        
        if (itemsToSort.length === 0) {
            console.warn(' No items to sort');
            return;
        }
        
        // Store sort type for re-application after reload
        currentSortType = sortType;
        sessionStorage.setItem('pantrySortType', sortType);
        
        // Helper function to get display name from item
        const getItemDisplayName = (item) => {
            const nameElement = item.querySelector('h6');
            if (nameElement) {
                return nameElement.textContent.trim() || nameElement.getAttribute('title') || '';
            }
            // Fallback to data attribute if h6 not found
            return item.getAttribute('data-item-name') || '';
        };
        
        itemsToSort.sort((a, b) => {
            if (sortType === 'category') {
                const nameA = getItemDisplayName(a);
                const nameB = getItemDisplayName(b);
                const catA = getItemCategory(nameA.toLowerCase());
                const catB = getItemCategory(nameB.toLowerCase());
                
                // Sort by category first
                if (catA !== catB) {
                    return (categoryOrder[catA] || 99) - (categoryOrder[catB] || 99);
                }
                // Then by name within category
                return nameA.localeCompare(nameB);
            } else if (sortType === 'name') {
                const nameA = getItemDisplayName(a);
                const nameB = getItemDisplayName(b);
                return nameA.localeCompare(nameB);
            } else if (sortType === 'name-desc') {
                const nameA = getItemDisplayName(a);
                const nameB = getItemDisplayName(b);
                return nameB.localeCompare(nameA);
            } else if (sortType === 'expiration') {
                const dateA = a.getAttribute('data-expiration-date') || '9999-12-31';
                const dateB = b.getAttribute('data-expiration-date') || '9999-12-31';
                // Handle expired items (dates in the past) - put them first
                const today = new Date().toISOString().split('T')[0];
                const isExpiredA = dateA < today && dateA !== '9999-12-31';
                const isExpiredB = dateB < today && dateB !== '9999-12-31';
                if (isExpiredA !== isExpiredB) {
                    return isExpiredA ? -1 : 1;
                }
                return dateA.localeCompare(dateB);
            } else if (sortType === 'expiration-desc') {
                const dateA = a.getAttribute('data-expiration-date') || '9999-12-31';
                const dateB = b.getAttribute('data-expiration-date') || '9999-12-31';
                return dateB.localeCompare(dateA);
            } else if (sortType === 'recent') {
                // Sort by recently added
                const dateA = a.getAttribute('data-added-date') || '';
                const dateB = b.getAttribute('data-added-date') || '';
                // Most recent first (descending)
                return dateB.localeCompare(dateA);
            }
            return 0;
        });
        
        // Clear container and re-append sorted items with category grouping
        // Store which items should be hidden (filters) - check BEFORE clearing
        const itemsToHide = new Set();
        allItems.forEach(item => {
            const style = window.getComputedStyle(item);
            const inlineStyle = item.getAttribute('style') || '';
            if (style.display === 'none' || style.visibility === 'hidden' || inlineStyle.includes('display: none')) {
                itemsToHide.add(item);
            }
        });
        
        // Preserve container classes when clearing
        const containerClasses = container.className;
        
        // IMPORTANT: Remove items from DOM but keep references
        // This preserves the item elements so we can re-append them
        allItems.forEach(item => {
            if (item.parentNode === container) {
                container.removeChild(item);
            }
        });
        
        // Clear any remaining children (like category headers, empty states, etc.)
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
        container.className = containerClasses; // Restore classes
        
        if (sortType === 'category') {
            // Group items by category for better visual organization
            const categoryGroups = {};
            itemsToSort.forEach(item => {
                const name = getItemDisplayName(item);
                const category = getItemCategory(name.toLowerCase());
                if (!categoryGroups[category]) {
                    categoryGroups[category] = [];
                }
                categoryGroups[category].push(item);
            });
            
            // Add category headers and items
            const categoryKeys = Object.keys(categoryGroups).sort((a, b) => {
                return (categoryOrder[a] || 99) - (categoryOrder[b] || 99);
            });
            
            // Only show category headers if we have multiple categories or multiple items
            const totalItems = itemsToSort.length;
            const showCategoryHeaders = categoryKeys.length > 1 || totalItems > 3;
            
            categoryKeys.forEach((category, categoryIndex) => {
                const categoryInfo = getCategoryDisplay(category);
                const groupItems = categoryGroups[category];
                
                // Add category header only if we should show them
                if (showCategoryHeaders) {
                    const categoryHeader = document.createElement('div');
                    // First category header shouldn't have top margin
                    const marginTop = categoryIndex === 0 ? '0' : '24px';
                    categoryHeader.style.cssText = `grid-column: 1 / -1; margin-top: ${marginTop}; margin-bottom: 12px; padding: 12px 16px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.08) 0%, rgba(59, 130, 246, 0.05) 100%); border-radius: 12px; border-left: 4px solid ${categoryInfo.color}; width: 100%;`;
                    categoryHeader.innerHTML = `
                        <div class="d-flex align-items-center gap-2">
                            <i class="bi ${categoryInfo.icon}" style="color: ${categoryInfo.color}; font-size: 1.1rem;"></i>
                            <h6 class="mb-0 fw-bold" style="color: #1e293b; font-size: 0.95rem;">${categoryInfo.name}</h6>
                            <span class="badge" style="background: ${categoryInfo.color}; color: white; font-size: 0.75rem; padding: 4px 8px; border-radius: 6px;">${groupItems.length} ${groupItems.length === 1 ? 'item' : 'items'}</span>
                        </div>
                    `;
                    container.appendChild(categoryHeader);
                }
                
                // Add items in this category
                groupItems.forEach((item, index) => {
                    const card = item.querySelector('.pantry-item-card');
                    if (card) {
                        card.style.animationDelay = (index * 0.05) + 's';
                    }
                    // Restore visibility state if item was hidden
                    if (itemsToHide.has(item)) {
                        item.style.display = 'none';
                    } else {
                        item.style.display = '';
                    }
                    // No need for column classes - grid handles layout
                    container.appendChild(item);
                });
            });
            
            // Show category info only if headers are shown
            const categoryInfo = document.getElementById('categoryGroupInfo');
            if (categoryInfo) {
                categoryInfo.style.display = showCategoryHeaders ? 'block' : 'none';
            }
        } else {
            // Regular sorting without category grouping
            itemsToSort.forEach((item, index) => {
                // Item is already in fragment, just append it
                const card = item.querySelector('.pantry-item-card');
                if (card) {
                    card.style.animationDelay = (index * 0.05) + 's';
                }
                // Restore visibility state if item was hidden
                if (itemsToHide.has(item)) {
                    item.style.display = 'none';
                } else {
                    item.style.display = '';
                    item.style.visibility = 'visible';
                }
                // Append item to container (it will be moved from fragment)
                container.appendChild(item);
            });
            
            // Hide category info
            const categoryInfo = document.getElementById('categoryGroupInfo');
            if (categoryInfo) {
                categoryInfo.style.display = 'none';
            }
        }
        
        // Ensure container is visible
        container.style.display = '';
        
        // Hide empty state if it exists
        const emptyState = container.closest('.card-body')?.querySelector('.empty-state');
        if (emptyState) {
            emptyState.style.display = 'none';
        }
        
        console.log(' Sorting complete, re-initializing interactive elements...');
        
        // Re-initialize interactive elements after sorting
        setTimeout(() => {
            initializeDeleteButtons();
            initializeQuantityEditing();
            initializeExpirationEditing();
            
            // Update expiration badges and card backgrounds after sorting
            updateExpirationBadges();
            if (typeof updatePantryCardBackgrounds === 'function') {
                updatePantryCardBackgrounds();
            }
        }, 50);
        
        // Re-apply all active filters after sorting to maintain filter state
        if (typeof applyAllFilters === 'function') {
            setTimeout(() => {
                applyAllFilters();
            }, 100);
        }
        
        // Show feedback for category sort
        if (sortType === 'category') {
            const feedback = document.getElementById('addItemFeedback');
            if (feedback) {
                showFeedback('Items grouped by category', 'success');
            }
        }
    }
    
    // Update sort label
    function updateSortLabel(label) {
        const labelElement = document.getElementById('currentSortLabel');
        if (labelElement) {
            labelElement.textContent = label;
        }
    }
    
    // Get label for sort type
    function getSortLabel(sortType) {
        const labels = {
            'category': 'Category',
            'name': 'Name (A-Z)',
            'name-desc': 'Name (Z-A)',
            'expiration': 'Expiration (Soonest)',
            'expiration-desc': 'Expiration (Latest)'
        };
        return labels[sortType] || 'Category';
    }
    
    // Run expiration badge updates on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            setDefaultExpirationDate();
            updateExpirationBadges();
            updatePantryCardBackgrounds();
            // Also run after a short delay to ensure all elements are rendered
            setTimeout(() => {
                updateExpirationBadges();
                updatePantryCardBackgrounds();
            }, 200);
        });
    } else {
        // DOM already loaded
        setDefaultExpirationDate();
        updateExpirationBadges();
        updatePantryCardBackgrounds();
        updateExpiringSoonBanner();
        setTimeout(() => {
            updateExpirationBadges();
            updatePantryCardBackgrounds();
        }, 200);
    }
    
    // Handle add item form submission
    // Track if form is currently submitting to prevent race conditions
    let isSubmitting = false;
    
    // Make handleAddItem globally accessible
    window.handleAddItem = function(event) {
        // Always prevent default form submission
        if (event) {
            event.preventDefault();
        }
        
        // Prevent race conditions - check if already submitting
        if (isSubmitting) {
            console.log('Form submission already in progress, ignoring duplicate request');
            return false;
        }
        
        // Try modal form first, then fallback to regular form
        let form = document.getElementById('addItemModalForm');
        let itemInput = document.getElementById('addItemModalInput');
        let quantityInput = document.getElementById('addItemModalQuantity');
        let expirationDateInput = document.getElementById('addItemModalExpiration');
        let btn = document.getElementById('addItemModalBtn');
        let btnText = document.getElementById('addItemModalBtnText');
        let feedback = document.getElementById('addItemModalFeedback');
        let isModal = true;
        
        // Fallback to regular form if modal form doesn't exist
        if (!form) {
            form = document.getElementById('addItemForm');
            itemInput = document.getElementById('itemInput');
            quantityInput = document.getElementById('quantityInput');
            expirationDateInput = document.getElementById('expirationInput');
            btn = document.getElementById('addItemBtn');
            btnText = document.getElementById('addItemBtnText');
            feedback = document.getElementById('addItemFeedback');
            isModal = false;
        }
        
        if (!form) {
            console.error('Form not found');
            return false;
        }
        
        const formData = new FormData(form);
        const itemName = formData.get('item');
        
        // Validate quantity input
        if (quantityInput) {
            const quantityValue = quantityInput.value.trim() || '1';
            const quantityNum = parseInt(quantityValue, 10);
            if (isNaN(quantityNum) || quantityNum < 0) {
                if (feedback) {
                    showFeedback('Quantity must be a positive number', 'danger');
                }
                if (quantityInput) {
                    quantityInput.focus();
                    quantityInput.select();
                }
                return false;
            }
            formData.set('quantity', Math.max(0, quantityNum).toString());
        }
        
        // Ensure expiration_date is included in FormData (even if empty)
        if (expirationDateInput) {
            const expirationDateValue = expirationDateInput.value || '';
            formData.set('expiration_date', expirationDateValue);
        }
        
        // Validate input - Enhanced validation
        if (!itemName || !itemName.trim()) {
            if (feedback) {
                showFeedback(' Please enter an item name', 'danger');
            } else {
                alert('Please enter an item name');
            }
            if (itemInput) {
                itemInput.focus();
                itemInput.classList.add('is-invalid');
                setTimeout(() => itemInput.classList.remove('is-invalid'), 3000);
            }
            isSubmitting = false; // Reset flag on validation failure
            return false;
        }
        
        // Validate item name length
        if (itemName.trim().length > 100) {
            if (feedback) {
                showFeedback(' Item name is too long (max 100 characters)', 'danger');
            }
            if (itemInput) {
                itemInput.focus();
                itemInput.select();
                itemInput.classList.add('is-invalid');
                setTimeout(() => itemInput.classList.remove('is-invalid'), 3000);
            }
            isSubmitting = false;
            return false;
        }
        
        // Validate expiration date format if provided
        if (expirationDateInput && expirationDateInput.value) {
            const expDate = expirationDateInput.value.trim();
            // Basic date format validation (YYYY-MM-DD)
            const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
            if (!dateRegex.test(expDate)) {
                if (feedback) {
                    showFeedback(' Invalid date format. Please use YYYY-MM-DD', 'danger');
                }
                if (expirationDateInput) {
                    expirationDateInput.focus();
                    expirationDateInput.classList.add('is-invalid');
                    setTimeout(() => expirationDateInput.classList.remove('is-invalid'), 3000);
                }
                isSubmitting = false;
                return false;
            }
        }
        
        // Set submitting flag and disable button
        isSubmitting = true;
        if (btn) {
            btn.disabled = true;
        }
        if (btnText) {
            btnText.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Adding...';
        }
        
        // Submit form using fetch with timeout
        fetchWithTimeout('/add', {
            method: 'POST',
            body: formData,
            credentials: 'same-origin', // Include cookies for session
            headers: {
                'X-Requested-With': 'XMLHttpRequest' // Identify as AJAX request
            }
        })
        .then(async response => {
            // Check if response is JSON (success) or HTML (redirect/error)
            const contentType = response.headers.get('content-type');
            if (contentType && contentType.includes('application/json')) {
                // JSON response (AJAX mode)
                // Parse JSON even for error responses
                const data = await response.json().catch(async (parseError) => {
                    // If JSON parsing fails, try to get text
                    const text = await response.text().catch(() => 'Unknown error');
                    console.error('Failed to parse JSON response:', text);
                    return { success: false, error: text || 'Unknown error' };
                });
                
                // Check if response is OK
                if (!response.ok) {
                    // Server returned error status with JSON
                    const errorMsg = data.error || `Server error (${response.status})`;
                    if (feedback) {
                        showFeedback(errorMsg, 'danger');
                    } else {
                        alert(errorMsg);
                    }
                    resetButton();
                    return;
                }
                
                if (data.success) {
                        // Success - show feedback and reload
                        if (feedback) {
                            showFeedback(data.message || 'Item added successfully!', 'success');
                        }
                        // Clear form
                        if (form) {
                            form.reset();
                            if (quantityInput) quantityInput.value = '1';
                            if (expirationDateInput) expirationDateInput.value = '';
                        }
                        // Reset button state immediately
                        resetButton();
                        // Close modal if it's the modal form
                        if (isModal) {
                            setTimeout(() => {
                                closeModalSafely('addItemModal');
                            }, 1500); // Close after showing success message
                        }
                        // Optimistic UI update - show item count immediately
                        const statsCountElement = document.getElementById('pantryStatsCount');
                        if (statsCountElement) {
                            const currentCount = parseInt(statsCountElement.textContent) || 0;
                            statsCountElement.textContent = currentCount + 1; // Optimistic update
                        }
                        
                        // Update pantry items without reloading page
                        // Use API endpoint directly for more reliable reload
                        // Increase delay for Firebase to ensure data is saved
                        // Firebase writes can take longer than file-based storage
                        setTimeout(async () => {
                            try {
                                // Try API endpoint first (more reliable than HTML parsing)
                                await reloadPantryItemsFromAPI();
                                // Update empty state and progress after reload
                                if (typeof updateEmptyState === 'function') {
                                    updateEmptyState();
                                }
                                if (typeof updateProgressIndicator === 'function') {
                                    updateProgressIndicator();
                                }
                                if (typeof updateSmartSuggestions === 'function') {
                                    updateSmartSuggestions();
                                }
                                
                                // Retry once more after a longer delay if Firebase might be slow
                                setTimeout(async () => {
                                    try {
                                        const container = document.getElementById('pantryItemsContainer');
                                        const expectedItems = data.items_added || 1;
                                        const currentItems = container ? container.querySelectorAll('.pantry-item-wrapper').length : 0;
                                        // Only retry if items are still not showing
                                        if (currentItems === 0) {
                                            console.log('Retrying reload after Firebase save delay...');
                                            await reloadPantryItemsFromAPI();
                                            // Update again after retry
                                            if (typeof updateEmptyState === 'function') {
                                                updateEmptyState();
                                            }
                                            if (typeof updateProgressIndicator === 'function') {
                                                updateProgressIndicator();
                                            }
                                        }
                                    } catch (retryError) {
                                        console.error('Error in reload retry:', retryError);
                                    }
                                }, 1500);
                            } catch (reloadError) {
                                console.error('Error reloading pantry items:', reloadError);
                                // Fallback to HTML parsing method
                                try {
                                    await reloadPantryItems();
                                } catch (fallbackError) {
                                    console.error('Fallback reload also failed:', fallbackError);
                                // Show user-friendly error
                                const feedback = document.getElementById('addItemFeedback') || document.getElementById('addItemModalFeedback');
                                if (feedback) {
                                    showFeedback('Items added but failed to refresh. Please refresh the page.', 'warning');
                                }
                            }
                            }
                        }, 800);
                } else {
                    // Error from server
                    if (feedback) {
                        showFeedback(data.error || 'Failed to add item. Please try again.', 'danger');
                    }
                    resetButton();
                }
            } else {
                // HTML response (redirect) - Flask redirects return 302, then 200
                if (response.ok || response.status === 200 || response.status === 302) {
                    // Success - show feedback and reload
                    if (feedback) {
                        showFeedback('Item added successfully!', 'success');
                    }
                    // Clear form
                    if (form) {
                        form.reset();
                        if (quantityInput) quantityInput.value = '1';
                        if (expirationDateInput) expirationDateInput.value = '';
                    }
                    // Reset button state
                    resetButton();
                    // Close modal if it's the modal form
                    if (isModal) {
                        setTimeout(() => {
                            closeModalSafely('addItemModal');
                        }, 1500); // Close after showing success message
                    }
                    // Update pantry items without reloading page
                    // Increase delay for Firebase to ensure data is saved
                    // Firebase writes can take longer than file-based storage
                    setTimeout(async () => {
                        try {
                            await reloadPantryItems();
                            // Update empty state and progress after reload
                            if (typeof updateEmptyState === 'function') {
                                updateEmptyState();
                            }
                            if (typeof updateProgressIndicator === 'function') {
                                updateProgressIndicator();
                            }
                            if (typeof updateSmartSuggestions === 'function') {
                                updateSmartSuggestions();
                            }
                            
                            // Retry once more after a longer delay if Firebase might be slow
                            setTimeout(async () => {
                                try {
                                    const container = document.getElementById('pantryItemsContainer');
                                    const currentItems = container ? container.children.length : 0;
                                    // Only retry if items are still not showing
                                    if (currentItems === 0) {
                                        console.log('Retrying reload after Firebase save delay...');
                                        await reloadPantryItems();
                                        // Update again after retry
                                        if (typeof updateEmptyState === 'function') {
                                            updateEmptyState();
                                        }
                                        if (typeof updateProgressIndicator === 'function') {
                                            updateProgressIndicator();
                                        }
                                    }
                                } catch (retryError) {
                                    console.error('Error in reload retry:', retryError);
                                }
                            }, 800);
                        } catch (reloadError) {
                            console.error('Error reloading pantry items:', reloadError);
                            // Try to reload one more time with a longer delay
                            // Progressive retry with increasing delays (for Firebase sync)
                            let retryCount = 0;
                            const maxRetries = 3;
                            const retryDelays = [1500, 2500, 4000]; // Progressive delays for Firebase
                            
                            const retryReload = async () => {
                                if (retryCount >= maxRetries) {
                                    // All retries failed, show error message
                            const feedback = document.getElementById('addItemFeedback') || document.getElementById('addItemModalFeedback');
                            if (feedback) {
                                showFeedback('Items added but failed to refresh. Please refresh the page.', 'warning');
                            }
                                    return;
                                }
                                
                                setTimeout(async () => {
                                    try {
                                        console.log(`Retrying reload (attempt ${retryCount + 1}/${maxRetries})...`);
                                        await reloadPantryItems();
                                        
                                        // Check if items are now visible
                                        const container = document.getElementById('pantryItemsContainer');
                                        if (container && container.children.length > 0) {
                                            // Success! Update UI
                                            if (typeof updateEmptyState === 'function') {
                                                updateEmptyState();
                                            }
                                            if (typeof updateProgressIndicator === 'function') {
                                                updateProgressIndicator();
                                            }
                                            console.log(' Reload successful after retry');
                                            return;
                                        }
                                        
                                        // Items still not visible, try again
                                        retryCount++;
                                        retryReload();
                                    } catch (retryError) {
                                        console.error(`Retry ${retryCount + 1} failed:`, retryError);
                                        retryCount++;
                                        retryReload();
                                    }
                                }, retryDelays[retryCount] || 4000);
                            };
                            
                            retryReload();
                        }
                    }, 500);
                } else {
                    // Error response
                    return response.text().then(text => {
                        console.error('Server error:', text);
                        if (feedback) {
                            showFeedback('Failed to add item. Please try again.', 'danger');
                        }
                        resetButton();
                    });
                }
            }
        })
        .catch(error => {
            console.error('Error adding item:', error);
            let errorMessage = 'Failed to add item. Please try again.';
            if (error.name === 'AbortError') {
                errorMessage = 'Request timed out. Please check your connection and try again.';
            } else if (error.message) {
                errorMessage = 'Failed to add item: ' + error.message;
            }
            if (feedback) {
                showFeedback(errorMessage, 'danger');
            } else {
                alert(errorMessage);
            }
            resetButton();
        });
        
        function resetButton() {
            isSubmitting = false; // Reset submitting flag
            // Reset modal button
            let btn = document.getElementById('addItemModalBtn');
            let btnText = document.getElementById('addItemModalBtnText');
            if (btn) {
                btn.disabled = false;
            }
            if (btnText) {
                btnText.innerHTML = '<i class="bi bi-plus-circle-fill me-2"></i>Add to Pantry';
            }
            // Reset regular form button (fallback)
            btn = document.getElementById('addItemBtn');
            btnText = document.getElementById('addItemBtnText');
            if (btn) {
                btn.disabled = false;
            }
            if (btnText) {
                btnText.innerHTML = '<i class="bi bi-plus-circle-fill me-2"></i>Add to Pantry';
            }
        }
        
        return false; // Prevent default form submission
    };
    
    // Make reloadPantryItems globally accessible
    window.reloadPantryItems = reloadPantryItems;
    
    function showFeedback(message, type) {
        try {
            // Try modal feedback first, then fallback to regular feedback
            let feedback = document.getElementById('addItemModalFeedback');
            if (!feedback) {
                feedback = document.getElementById('addItemFeedback');
            }
            // Try upload feedback as third option
            if (!feedback) {
                feedback = document.getElementById('uploadFeedback');
            }
            
            // If still no feedback element, create one or use alert
            if (!feedback) {
                console.warn('Feedback element not found, using alert fallback');
                console.log(`[${type.toUpperCase()}] ${message}`);
                alert(message);
                return;
            }
        
        feedback.className = `alert alert-${type} alert-dismissible fade show mt-3`;
        feedback.innerHTML = `
            <strong>${type === 'success' ? '' : type === 'danger' ? '' : ''}</strong> ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        `;
        feedback.style.display = 'block';
        feedback.style.visibility = 'visible';
        feedback.style.opacity = '1';
        
        // Scroll to feedback if it's not visible
        if (feedback.scrollIntoView) {
            feedback.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
                if (feedback && feedback.parentNode) {
                feedback.style.transition = 'opacity 0.5s ease';
                feedback.style.opacity = '0';
        setTimeout(() => {
                if (feedback && feedback.parentNode) {
                feedback.style.display = 'none';
                    }
                }, 500);
            }
        }, 5000);
        } catch (error) {
            console.error('Error showing feedback:', error);
            // Fallback to alert if feedback element fails
            alert(message);
        }
    }
    
    // Reload pantry items without refreshing the page
    // Make reloadPantryItems globally accessible
    let reloadInProgress = false;  // Prevent concurrent reloads
    let reloadTimeoutId = null;  // Timeout to reset flag if reload gets stuck
    
    // New function: Reload pantry items directly from API endpoint (more reliable)
    window.reloadPantryItemsFromAPI = async function reloadPantryItemsFromAPI() {
        const container = document.getElementById('pantryItemsContainer');
        if (!container) {
            console.warn('Pantry items container not found');
            return;
        }
        
        try {
            console.log('Reloading pantry items from API...');
            const response = await fetchWithTimeout('/api/pantry', {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                },
                cache: 'no-cache'
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            if (!data || !data.success) {
                throw new Error(data.error || 'Failed to fetch pantry items');
            }
            
            const items = data.items || [];
            console.log(`Fetched ${items.length} items from API`);
            
            // Clear container
            container.innerHTML = '';
            
            if (items.length === 0) {
                // Show empty state
                const pantryCard = container.closest('.card');
                const cardBody = pantryCard ? pantryCard.querySelector('.card-body') : null;
                if (cardBody) {
                    const emptyState = cardBody.querySelector('.empty-state');
                    if (emptyState) {
                        emptyState.style.display = '';
                    }
                }
                // Update stats
                const statsCount = document.getElementById('pantryStatsCount');
                if (statsCount) {
                    statsCount.textContent = '0';
                }
                // Update badge
                const pantryCardHeader = pantryCard ? pantryCard.querySelector('.card-header') : null;
                if (pantryCardHeader) {
                    const badge = pantryCardHeader.querySelector('.badge');
                    if (badge) {
                        badge.style.display = 'none';
                    }
                }
                return;
            }
            
            // Hide empty state
            const pantryCard = container.closest('.card');
            const cardBody = pantryCard ? pantryCard.querySelector('.card-body') : null;
            if (cardBody) {
                const emptyState = cardBody.querySelector('.empty-state');
                if (emptyState) {
                    emptyState.style.display = 'none';
                }
            }
            
            // Helper to escape HTML
            const escapeHtml = (text) => {
                const div = document.createElement('div');
                div.textContent = text || '';
                return div.innerHTML;
            };
            
            // Helper to format date
            const formatDate = (dateStr) => {
                if (!dateStr || dateStr === 'None' || dateStr === 'null' || dateStr === '') {
                    return '';
                }
                const dateStrTrimmed = dateStr.trim();
                if (dateStrTrimmed.length >= 10 && dateStrTrimmed.indexOf('-') >= 0) {
                    return dateStrTrimmed.substring(0, 10);
                }
                return dateStrTrimmed;
            };
            
            // Helper to get category icon - More symbolic and colorful icons
            const getCategoryIcon = (category) => {
                const catLower = (category || 'other').toLowerCase().trim();
                if (catLower === 'dairy') return '<i class="bi bi-cup-hot" style="font-size: 1.5rem; color: #3B82F6;"></i>'; // Blue cup (milk/dairy)
                if (catLower === 'produce' || catLower === 'vegetables') return '<i class="bi bi-pepper-hot" style="font-size: 1.5rem; color: #10B981;"></i>'; // Green pepper (vegetables)
                if (catLower === 'fruits') return '<i class="bi bi-apple" style="font-size: 1.5rem; color: #F59E0B;"></i>'; // Orange apple
                if (catLower === 'meat' || catLower === 'proteins' || catLower === 'protein') return '<i class="bi bi-fire" style="font-size: 1.5rem; color: #EF4444;"></i>'; // Red fire (cooked meat)
                if (catLower === 'beverages') return '<i class="bi bi-cup-straw" style="font-size: 1.5rem; color: #06B6D4;"></i>'; // Cyan cup with straw
                if (catLower === 'bakery') return '<i class="bi bi-bread-slice" style="font-size: 1.5rem; color: #D97706;"></i>'; // Brown bread
                if (catLower === 'canned goods' || catLower === 'canned_goods') return '<i class="bi bi-box" style="font-size: 1.5rem; color: #8B5CF6;"></i>'; // Purple box
                if (catLower === 'snacks') return '<i class="bi bi-cookie" style="font-size: 1.5rem; color: #EC4899;"></i>'; // Pink cookie
                if (catLower === 'condiments') return '<i class="bi bi-droplet-half" style="font-size: 1.5rem; color: #F97316;"></i>'; // Orange droplet (sauce)
                if (catLower === 'grains') return '<i class="bi bi-grid-3x3" style="font-size: 1.5rem; color: #A855F7;"></i>'; // Purple grid (cereal/grains)
                if (catLower === 'frozen') return '<i class="bi bi-snow" style="font-size: 1.5rem; color: #06B6D4;"></i>'; // Cyan snowflake
                return '<i class="bi bi-box-seam-fill" style="font-size: 1.5rem; color: #64748B;"></i>'; // Gray default
            };
            
            // Helper to get category display info
            const getCategoryInfo = (category) => {
                const catLower = (category || 'other').toLowerCase();
                const categoryMap = {
                    'fruits': { name: 'Fruits', gradient: 'linear-gradient(135deg, rgba(245, 158, 11, 0.12) 0%, rgba(217, 119, 6, 0.1) 100%)', color: '#92400E' },
                    'vegetables': { name: 'Vegetables', gradient: 'linear-gradient(135deg, rgba(16, 185, 129, 0.12) 0%, rgba(5, 150, 105, 0.1) 100%)', color: '#047857' },
                    'proteins': { name: 'Meat', gradient: 'linear-gradient(135deg, rgba(239, 68, 68, 0.12) 0%, rgba(220, 38, 38, 0.1) 100%)', color: '#991B1B' },
                    'protein': { name: 'Meat', gradient: 'linear-gradient(135deg, rgba(239, 68, 68, 0.12) 0%, rgba(220, 38, 38, 0.1) 100%)', color: '#991B1B' },
                    'meat': { name: 'Meat', gradient: 'linear-gradient(135deg, rgba(239, 68, 68, 0.12) 0%, rgba(220, 38, 38, 0.1) 100%)', color: '#991B1B' },
                    'dairy': { name: 'Dairy', gradient: 'linear-gradient(135deg, rgba(59, 130, 246, 0.12) 0%, rgba(37, 99, 235, 0.1) 100%)', color: '#1E40AF' },
                    'grains': { name: 'Grains', gradient: 'linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(124, 58, 237, 0.1) 100%)', color: '#6D28D9' },
                    'bakery': { name: 'Bakery', gradient: 'linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(124, 58, 237, 0.1) 100%)', color: '#6D28D9' },
                    'beverages': { name: 'Beverages', gradient: 'linear-gradient(135deg, rgba(6, 182, 212, 0.12) 0%, rgba(8, 145, 178, 0.1) 100%)', color: '#155E75' },
                    'snacks': { name: 'Snacks', gradient: 'linear-gradient(135deg, rgba(236, 72, 153, 0.12) 0%, rgba(219, 39, 119, 0.1) 100%)', color: '#9F1239' },
                    'condiments': { name: 'Condiments', gradient: 'linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(124, 58, 237, 0.1) 100%)', color: '#6D28D9' },
                    'canned goods': { name: 'Canned Goods', gradient: 'linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(124, 58, 237, 0.1) 100%)', color: '#6D28D9' },
                    'frozen': { name: 'Frozen', gradient: 'linear-gradient(135deg, rgba(6, 182, 212, 0.12) 0%, rgba(8, 145, 178, 0.1) 100%)', color: '#155E75' }
                };
                return categoryMap[catLower] || { name: 'Other', gradient: 'linear-gradient(135deg, rgba(100, 116, 139, 0.12) 0%, rgba(71, 85, 105, 0.1) 100%)', color: '#475569' };
            };
            
            // Render items
            items.forEach(item => {
                const itemName = escapeHtml(item.name || 'Unnamed Item');
                const itemQuantity = escapeHtml(item.quantity || '1');
                const itemId = escapeHtml(item.id || '');
                const expDate = formatDate(item.expirationDate);
                const addedDate = formatDate(item.addedDate || item.added_date);
                const category = item.category || 'other';
                const categoryInfo = getCategoryInfo(category);
                
                const itemWrapper = document.createElement('div');
                itemWrapper.className = 'pantry-item-wrapper';
                itemWrapper.setAttribute('data-item-name', itemName.toLowerCase());
                itemWrapper.setAttribute('data-item-id', itemId);
                itemWrapper.setAttribute('data-expiration-date', expDate || '9999-12-31');
                itemWrapper.setAttribute('data-added-date', addedDate || new Date().toISOString().substring(0, 10));
                itemWrapper.style.cssText = 'position: relative; z-index: 10;';
                
                // Build expiration badge HTML
                let expirationBadgeHtml = '';
                if (expDate && expDate !== '' && expDate !== '9999-12-31') {
                    const expDateAttr = escapeHtml(expDate);
                    expirationBadgeHtml = `
                        <span class="metadata-badge expiration-badge-modern fresh editable-expiration" 
                              data-item-id="${itemId}"
                              data-item-name="${itemName}"
                              data-current-quantity="${itemQuantity}"
                              data-current-expiration="${expDateAttr}"
                              data-added-date="${addedDate}"
                              data-exp-date="${expDateAttr}" 
                              style="font-size: 0.75rem; font-weight: 600; padding: 0.4rem 0.6rem; border-radius: 10px; cursor: pointer; transition: all 0.2s ease; border: 1px solid rgba(16, 185, 129, 0.2); min-width: 150px; max-width: 100%; display: inline-flex; align-items: center; justify-content: flex-start; overflow: visible;"
                              title="Click to edit expiration date">
                            <i class="bi bi-calendar3 me-1" style="font-size: 0.75rem;"></i>
                            <span class="expiration-value" style="white-space: nowrap; overflow: visible; text-overflow: clip;">${expDateAttr}</span>
                        </span>
                    `;
                }
                
                // Build quantity badge HTML
                let quantityBadgeHtml = '';
                if (itemId) {
                    quantityBadgeHtml = `
                        <span class="metadata-badge quantity-badge editable-quantity" 
                              data-item-id="${itemId}"
                              data-item-name="${itemName}"
                              data-current-quantity="${itemQuantity}"
                              data-expiration-date="${expDate}"
                              data-added-date="${addedDate}"
                              style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(59, 130, 246, 0.12) 100%); color: #8B5CF6; border-radius: 10px; font-size: 0.8rem; font-weight: 600; padding: 0.5rem 0.75rem; cursor: pointer; transition: all 0.2s ease; border: 1px solid rgba(139, 92, 246, 0.2);"
                              title="Click to edit quantity">
                            <i class="bi bi-hash me-1" style="font-size: 0.85rem;"></i><span class="quantity-value fw-bold">${itemQuantity}</span>
                        </span>
                    `;
                } else if (itemQuantity !== '1') {
                    quantityBadgeHtml = `
                        <span class="badge" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.12) 0%, rgba(59, 130, 246, 0.12) 100%); color: #8B5CF6; border-radius: 10px; font-size: 0.8rem; font-weight: 600; padding: 0.5rem 0.75rem; border: 1px solid rgba(139, 92, 246, 0.2);">
                            <i class="bi bi-hash me-1" style="font-size: 0.85rem;"></i>${itemQuantity}
                        </span>
                    `;
                }
                
                // Escape values for use in onclick handler
                const escapedItemId = (itemId || '').replace(/'/g, "\\'");
                const escapedItemName = (itemName || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                const escapedQuantity = (itemQuantity || '1').replace(/'/g, "\\'");
                const escapedExpDate = (expDate || '').replace(/'/g, "\\'");
                const escapedAddedDate = (addedDate || '').replace(/'/g, "\\'");
                
                itemWrapper.innerHTML = `
                    <div class="pantry-item-card card border-0 bg-white h-100" 
                         style="border-radius: 20px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); border: 1px solid #e2e8f0; cursor: default; overflow: hidden; position: relative;"
                         onmouseover="this.style.transform='translateY(-8px) scale(1.02)'; this.style.boxShadow='0 16px 32px rgba(139, 92, 246, 0.2)'; this.style.borderColor='#8B5CF6';"
                         onmouseout="this.style.transform='translateY(0) scale(1)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.08)'; this.style.borderColor='#e2e8f0';">
                        <div class="category-accent-bar" 
                             data-category="${category.toLowerCase()}"
                             style="height: 4px; width: 100%; background: linear-gradient(90deg, #8B5CF6 0%, #3B82F6 100%);"></div>
                        <div class="card-body p-4">
                            <div class="d-flex justify-content-between align-items-start mb-3">
                                <div class="flex-grow-1" style="min-width: 0; overflow: visible;">
                                    ${category !== 'other' ? `
                                    <span class="category-badge-card" style="background: ${categoryInfo.gradient}; color: ${categoryInfo.color}; border: 1px solid rgba(139, 92, 246, 0.2);" data-category="${category.toLowerCase()}">
                                        <i class="bi bi-tag-fill" style="font-size: 0.7rem;"></i>
                                        <span>${escapeHtml(categoryInfo.name)}</span>
                                    </span>
                                    ` : ''}
                                    <div class="d-flex align-items-center mb-3">
                                        <div class="me-3 item-icon-wrapper" style="width: 52px; height: 52px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.15) 0%, rgba(59, 130, 246, 0.15) 100%); border-radius: 14px; display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                            ${getCategoryIcon(category)}
                                        </div>
                                        <div class="flex-grow-1" style="min-width: 120px; flex: 1 1 auto; max-width: 100%; overflow: visible;">
                                            <h6 class="mb-0 fw-bold text-dark" style="font-size: 1.1rem; line-height: 1.5; word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; white-space: normal; display: block; overflow: visible; text-overflow: unset; max-width: 100%;" title="${itemName}">
                                                ${itemName}
                                            </h6>
                                        </div>
                                    </div>
                                    <div class="d-flex flex-wrap gap-2 align-items-center">
                                        ${quantityBadgeHtml}
                                        ${expirationBadgeHtml}
                                    </div>
                                </div>
                                <button type="button" class="item-delete-btn delete-item-btn" 
                                        data-item-name="${itemName}" 
                                        data-item-id="${itemId}" 
                                        title="Remove item"
                                        style="flex-shrink: 0; margin-left: 0.5rem; border-radius: 12px; width: 40px; height: 40px; padding: 0; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; background: rgba(239, 68, 68, 0.08); border: none; color: #EF4444; pointer-events: auto; cursor: pointer; z-index: 1001; position: relative;">
                                    <i class="bi bi-trash3-fill" style="font-size: 1rem; pointer-events: none;"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                
                container.appendChild(itemWrapper);
            });
            
            // Reinitialize interactive elements
            initializeDeleteButtons();
            initializeQuantityEditing();
            initializeExpirationEditing();
            
            // Update category accent bars
            if (typeof updateCategoryAccentBars === 'function') {
                updateCategoryAccentBars();
            }
            
            // Update stats
            const statsCount = document.getElementById('pantryStatsCount');
            if (statsCount) {
                statsCount.textContent = items.length.toString();
            }
            
            // Update badge
            const pantryCardHeader = pantryCard ? pantryCard.querySelector('.card-header') : null;
            if (pantryCardHeader) {
                const headerDiv = pantryCardHeader.querySelector('.d-flex');
                if (headerDiv) {
                    let badge = headerDiv.querySelector('.badge');
                    if (!badge) {
                        badge = document.createElement('span');
                        badge.className = 'badge bg-primary ms-2';
                        const dropdown = headerDiv.querySelector('.dropdown');
                        if (dropdown) {
                            headerDiv.insertBefore(badge, dropdown);
                        } else {
                            headerDiv.appendChild(badge);
                        }
                    }
                    badge.textContent = items.length.toString();
                    badge.style.display = items.length > 0 ? '' : 'none';
                }
            }
            
            // Show/hide sort controls
            const sortControlsSection = cardBody ? cardBody.querySelector('.d-flex.justify-content-between.align-items-center.mb-3.pb-3') : null;
            if (sortControlsSection) {
                sortControlsSection.style.display = items.length > 1 ? 'flex' : 'none';
            }
            
            const sortDropdown = cardBody ? cardBody.querySelector('#sortDropdown') : document.querySelector('#sortDropdown');
            if (sortDropdown) {
                sortDropdown.style.display = items.length > 1 ? '' : 'none';
            }
            
            // Update empty state
            if (typeof updateEmptyState === 'function') {
                updateEmptyState();
            }
            
            // Update progress indicator
            if (typeof updateProgressIndicator === 'function') {
                updateProgressIndicator();
            }
            
            // Re-apply filters if active
            if (typeof applyAllFilters === 'function') {
                setTimeout(() => {
                    applyAllFilters();
                }, 100);
            }
            
            console.log(`Successfully reloaded ${items.length} items from API`);
        } catch (error) {
            console.error('Error reloading pantry items from API:', error);
            throw error; // Re-throw to allow fallback
        }
    };
    
    window.reloadPantryItems = async function reloadPantryItems() {
        // Prevent concurrent reloads
        if (reloadInProgress) {
            console.log('Reload already in progress, skipping...');
            return;
        }
        reloadInProgress = true;
        
        // Set timeout to reset flag if reload gets stuck (30 seconds)
        if (reloadTimeoutId) {
            clearTimeout(reloadTimeoutId);
        }
        reloadTimeoutId = setTimeout(() => {
            if (reloadInProgress) {
                console.warn(' Reload timeout - resetting flag');
                reloadInProgress = false;
            }
        }, 30000);
        
        // Ensure we have a valid container before proceeding
        const container = document.getElementById('pantryItemsContainer');
        if (!container) {
            console.warn('Pantry items container not found, cannot reload');
            reloadInProgress = false;
            return;
        }
        
        // Store scroll position before reload
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
        
        try {
            // Add cache busting to ensure we get fresh data (especially important for Firebase)
            const url = window.location.pathname + '?t=' + Date.now() + '&_=' + Math.random();
            const response = await fetchWithTimeout(url, {
                method: 'GET',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache',
                    'Expires': '0'
                },
                cache: 'no-cache'  // Prevent browser caching
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const html = await response.text();
            if (!html || html.trim().length === 0) {
                throw new Error('Empty response from server');
            }
            
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // Check for parsing errors
            const parserError = doc.querySelector('parsererror');
            if (parserError) {
                throw new Error('Failed to parse HTML response');
            }
            
            // Extract pantry items container and related elements
            // Find the pantry card by locating the container first, then finding its parent card
            const newContainer = doc.querySelector('#pantryItemsContainer');
            if (!newContainer) {
                console.error('Pantry items container not found in response, attempting full page reload');
                // Fallback: reload the entire page if container is missing from response
                window.location.reload();
                return;
            }
            
            // Find the parent card by traversing up the DOM tree
            let pantryCard = newContainer.closest('.card');
            if (!pantryCard) {
                // Fallback: try to find card containing "Your Pantry" text
                const allCards = doc.querySelectorAll('.card');
                pantryCard = Array.from(allCards).find(card => {
                    const header = card.querySelector('.card-header');
                    return header && header.textContent.includes('Your Pantry');
                }) || null;
            }
            
            const newCardBody = pantryCard ? pantryCard.querySelector('.card-body') : newContainer.parentElement;
            // Select the badge specifically from the pantry card header, not any badge on the page
            const pantryCardHeader = pantryCard ? pantryCard.querySelector('.card-header') : null;
            const newBadge = pantryCardHeader ? pantryCardHeader.querySelector('.badge') : null;
            const newEmptyState = (pantryCard || newCardBody) ? (pantryCard || newCardBody).querySelector('.empty-state') : doc.querySelector('.empty-state');
            const newSortDropdown = doc.querySelector('#sortDropdown')?.parentElement;
            
            // Find current elements - use the same reliable method
            const currentContainer = document.getElementById('pantryItemsContainer');
            if (!currentContainer) {
                console.warn('Current pantry items container not found, attempting full page reload');
                // Fallback: reload the entire page if container is missing
                window.location.reload();
                return;
            }
            
            // Find the current pantry card by traversing up from the container
            let currentPantryCard = currentContainer.closest('.card');
            if (!currentPantryCard) {
                // Fallback: try to find card containing "Your Pantry" text
                const allCards = document.querySelectorAll('.card');
                currentPantryCard = Array.from(allCards).find(card => {
                    const header = card.querySelector('.card-header');
                    return header && header.textContent.includes('Your Pantry');
                }) || null;
            }
            
            const currentCardBody = currentPantryCard ? currentPantryCard.querySelector('.card-body') : currentContainer.parentElement;
            const currentCardHeader = currentPantryCard ? currentPantryCard.querySelector('.card-header') : null;
            
            // Check if we have items or empty state
            // Always update if we have both containers
            if (newContainer && currentContainer) {
                // Update items container content
                currentContainer.innerHTML = newContainer.innerHTML;
                currentContainer.style.display = '';
                
                // Check if we have items or empty state
                if (newContainer.children.length > 0) {
                    // Items exist - hide empty state if it exists
                const emptyState = currentCardBody?.querySelector('.empty-state');
                if (emptyState) {
                    emptyState.style.display = 'none';
                }
                
                // Update item count badge - select specifically from pantry card header
                if (newBadge && currentCardHeader) {
                    const headerDiv = currentCardHeader.querySelector('.d-flex');
                    if (headerDiv) {
                        // Find existing badge in header
                        const currentBadge = headerDiv.querySelector('.badge');
                        if (currentBadge) {
                            currentBadge.outerHTML = newBadge.outerHTML;
                        } else {
                            // Insert badge if it doesn't exist
                            const dropdown = headerDiv.querySelector('.dropdown');
                            if (dropdown) {
                                headerDiv.insertBefore(newBadge.cloneNode(true), dropdown);
                            } else {
                                headerDiv.appendChild(newBadge.cloneNode(true));
                            }
                        }
                    }
                }
                
                // Update pantry stats card with actual item count (use current container after update)
                const itemCount = currentContainer.querySelectorAll('.pantry-item-wrapper').length;
                const statsCountElement = document.getElementById('pantryStatsCount');
                if (statsCountElement) {
                    statsCountElement.textContent = itemCount;
                }
                
                // Show/hide sort controls section based on item count
                const sortControlsSection = currentCardBody ? currentCardBody.querySelector('.d-flex.justify-content-between.align-items-center.mb-3.pb-3') : null;
                if (sortControlsSection) {
                    // Check if sort controls section exists (it's the one with border-bottom)
                    const hasMultipleItems = newContainer.children.length > 1;
                    sortControlsSection.style.display = hasMultipleItems ? 'flex' : 'none';
                }
                
                // Also update sort dropdown visibility (now in card body, not header)
                const currentSortDropdown = currentCardBody ? currentCardBody.querySelector('#sortDropdown') : document.querySelector('#sortDropdown');
                if (currentSortDropdown) {
                    currentSortDropdown.style.display = newContainer.children.length > 1 ? '' : 'none';
                }
                
                // Re-initialize delete buttons
                initializeDeleteButtons();
                
                    // Re-initialize quantity editing
                    initializeQuantityEditing();
                    
                    // Re-initialize expiration date editing
                    initializeExpirationEditing();
                    
                    // Update category accent bars with category colors
                    if (typeof updateCategoryAccentBars === 'function') {
                        updateCategoryAccentBars();
                    }
                
                // CRITICAL: Update empty state after reloading items
                if (typeof updateEmptyState === 'function') {
                    updateEmptyState();
                }
                
                // CRITICAL: Update stats based on actual rendered items (not optimistic)
                const actualItemCount = currentContainer.querySelectorAll('.pantry-item-wrapper').length;
                const statsCountElement2 = document.getElementById('pantryStatsCount');
                if (statsCountElement2) {
                    statsCountElement2.textContent = actualItemCount;
                }
                
                // Re-apply sort if one was active
                const savedSortType = sessionStorage.getItem('pantrySortType');
                if (savedSortType && currentSortType === null) {
                    currentSortType = savedSortType;
                }
                if (currentSortType) {
                    // Update sort label
                    updateSortLabel(getSortLabel(currentSortType));
                    setTimeout(() => {
                        sortPantry(currentSortType);
                    }, 100);
                }
                
                // Re-apply search filter if one was active
                const searchInput = document.getElementById('searchItemsInput');
                if (currentSearchTerm && searchInput) {
                    searchInput.value = currentSearchTerm;
                    setTimeout(() => {
                        filterPantryItems(currentSearchTerm);
                    }, 150);
                }
                
                // Update expiration badges
                setTimeout(() => {
                    updateExpirationBadges();
                    updatePantryCardBackgrounds();
                }, 100);
                } else {
                    // No items - ensure empty state is visible
                    // The empty state should already be in the container.innerHTML we just set
                    // But let's make sure it's displayed
                    const emptyState = currentCardBody?.querySelector('.empty-state');
                    if (emptyState) {
                        emptyState.style.display = '';
                    }
                    
                    // Update pantry stats card to show 0 items
                    const statsCountElement = document.getElementById('pantryStatsCount');
                    if (statsCountElement) {
                        statsCountElement.textContent = '0';
                    }
                    
                    // Hide sort controls section
                    const sortControlsSection = currentCardBody ? currentCardBody.querySelector('.d-flex.justify-content-between.align-items-center.mb-3.pb-3') : null;
                    if (sortControlsSection) {
                        sortControlsSection.style.display = 'none';
                    }
                    
                    // Hide sort dropdown
                    const sortDropdown = currentCardBody ? currentCardBody.querySelector('#sortDropdown') : document.querySelector('#sortDropdown');
                    if (sortDropdown) {
                        sortDropdown.style.display = 'none';
                    }
                    
                    // Hide badge
                    if (currentCardHeader) {
                        const headerDiv = currentCardHeader.querySelector('.d-flex');
                        if (headerDiv) {
                            const badge = headerDiv.querySelector('.badge');
                            if (badge) {
                                badge.style.display = 'none';
                            }
                        }
                    }
                    
                    // Clear sort type when empty
                    currentSortType = null;
                    sessionStorage.removeItem('pantrySortType');
                }
            } else if (newEmptyState && currentCardBody) {
                // If no items, show empty state
                currentCardBody.innerHTML = newCardBody.innerHTML;
                
                // Hide container if it exists
                if (currentContainer) {
                    currentContainer.style.display = 'none';
                }
                
                // Hide sort controls section if it exists
                const sortControlsSection = currentCardBody ? currentCardBody.querySelector('.d-flex.justify-content-between.align-items-center.mb-3.pb-3') : null;
                if (sortControlsSection) {
                    sortControlsSection.style.display = 'none';
                }
                
                // Hide sort dropdown if it exists
                const sortDropdown = currentCardBody ? currentCardBody.querySelector('#sortDropdown') : document.querySelector('#sortDropdown');
                if (sortDropdown) {
                    sortDropdown.style.display = 'none';
                }
                
                // Hide badge if it exists - select specifically from pantry card header
                if (currentCardHeader) {
                    const headerDiv = currentCardHeader.querySelector('.d-flex');
                    if (headerDiv) {
                        const badge = headerDiv.querySelector('.badge');
                        if (badge) {
                            badge.style.display = 'none';
                        }
                    }
                }
                
                // Clear sort type when empty
                currentSortType = null;
                sessionStorage.removeItem('pantrySortType');
            } else if (currentContainer && newContainer) {
                // Fallback: just update the container
                currentContainer.innerHTML = newContainer.innerHTML;
                initializeDeleteButtons();
                initializeQuantityEditing();
                initializeExpirationEditing();
                
                // Re-apply sort if one was active
                const savedSortType = sessionStorage.getItem('pantrySortType');
                if (savedSortType && currentSortType === null) {
                    currentSortType = savedSortType;
                }
                if (currentSortType) {
                    setTimeout(() => {
                        sortPantry(currentSortType);
                    }, 100);
                }
                
                setTimeout(() => {
                    updateExpirationBadges();
                    updatePantryCardBackgrounds();
                    updateExpiringSoonBanner();
                }, 100);
            }
            
            // Restore scroll position
            window.scrollTo(0, scrollPosition);
            
        } catch (error) {
            console.error('Error reloading pantry items:', error);
            // Handle timeout errors specifically
            if (error.name === 'AbortError') {
                console.warn('Reload request timed out, trying API fallback...');
            }
            
            // Try alternative method: fetch pantry data via API endpoint
            try {
                console.log('Trying alternative reload method via API...');
                const apiResponse = await fetchWithTimeout('/api/pantry', {
                    method: 'GET',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'Cache-Control': 'no-cache'
                    },
                    cache: 'no-cache'
                });
                
                if (apiResponse.ok) {
                    const apiData = await apiResponse.json();
                    if (apiData && apiData.success && Array.isArray(apiData.items)) {
                        // Update pantry items from API response
                        const container = document.getElementById('pantryItemsContainer');
                        if (container) {
                            // Preserve row classes when clearing
                            const hasRowClasses = container.classList.contains('row');
                            container.innerHTML = '';
                            if (hasRowClasses) {
                                container.classList.add('row', 'g-3');
                            }
                            // Render items from API data
                            if (apiData.items.length > 0) {
                                // Use existing item rendering logic if available
                                // Helper function to escape HTML
                                const escapeHtml = (text) => {
                                    if (!text) return '';
                                    const div = document.createElement('div');
                                    div.textContent = String(text);
                                    return div.innerHTML;
                                };
                                
                                apiData.items.forEach(item => {
                                    // Validate item structure
                                    if (!item || typeof item !== 'object') {
                                        console.warn('Invalid item structure:', item);
                                        return;
                                    }
                                    
                                    const itemWrapper = document.createElement('div');
                                    itemWrapper.className = 'pantry-item-wrapper';
                                    
                                    const itemId = item.id || `item_${Date.now()}_${Math.random()}`;
                                    const itemName = escapeHtml(item.name || 'Unnamed Item');
                                    const itemQuantity = escapeHtml(item.quantity || '1');
                                    const itemExpDate = item.expirationDate ? escapeHtml(item.expirationDate) : '';
                                    const itemCategory = escapeHtml(item.category || 'other').toLowerCase();
                                    const itemAddedDate = item.addedDate ? escapeHtml(item.addedDate) : '';
                                    
                                    // Set wrapper data attributes
                                    itemWrapper.setAttribute('data-item-name', itemName.toLowerCase());
                                    itemWrapper.setAttribute('data-item-id', itemId);
                                    itemWrapper.setAttribute('data-expiration-date', itemExpDate || '9999-12-31');
                                    itemWrapper.setAttribute('data-added-date', itemAddedDate || new Date().toISOString().split('T')[0]);
                                    
                                    // Create the modern card element
                                    const card = document.createElement('div');
                                    card.className = 'pantry-card-modern pantry-item-card';
                                    card.setAttribute('data-item-id', itemId);
                                    card.setAttribute('data-item-name', itemName);
                                    card.setAttribute('data-quantity', itemQuantity);
                                    card.setAttribute('data-expiration-date', itemExpDate || '');
                                    card.setAttribute('data-category', itemCategory);
                                    card.setAttribute('data-added-date', itemAddedDate);
                                    
                                    // Determine expiration badge class
                                    let expBadgeClass = 'none';
                                    if (itemExpDate) {
                                        const expDate = new Date(itemExpDate);
                                        const today = new Date();
                                        today.setHours(0, 0, 0, 0);
                                        const daysUntil = Math.ceil((expDate - today) / (1000 * 60 * 60 * 24));
                                        if (daysUntil < 0) expBadgeClass = 'expired';
                                        else if (daysUntil <= 7) expBadgeClass = 'warning';
                                        else expBadgeClass = 'fresh';
                                    }
                                    
                                    // Get category icon (handle both naming conventions) - More symbolic colorful icons
                                    let categoryIcon = 'bi-box-seam-fill';
                                    let categoryColor = '#64748B';
                                    if (itemCategory === 'dairy') {
                                        categoryIcon = 'bi-cup-hot';
                                        categoryColor = '#3B82F6';
                                    } else if (itemCategory === 'vegetables' || itemCategory === 'produce') {
                                        categoryIcon = 'bi-pepper-hot';
                                        categoryColor = '#10B981';
                                    } else if (itemCategory === 'fruits') {
                                        categoryIcon = 'bi-apple';
                                        categoryColor = '#F59E0B';
                                    } else if (itemCategory === 'meat' || itemCategory === 'proteins') {
                                        categoryIcon = 'bi-fire';
                                        categoryColor = '#EF4444';
                                    } else if (itemCategory === 'beverages') {
                                        categoryIcon = 'bi-cup-straw';
                                        categoryColor = '#06B6D4';
                                    } else if (itemCategory === 'bakery') {
                                        categoryIcon = 'bi-bread-slice';
                                        categoryColor = '#D97706';
                                    } else if (itemCategory === 'canned goods' || itemCategory === 'canned_goods') {
                                        categoryIcon = 'bi-box';
                                        categoryColor = '#8B5CF6';
                                    } else if (itemCategory === 'snacks') {
                                        categoryIcon = 'bi-cookie';
                                        categoryColor = '#EC4899';
                                    } else if (itemCategory === 'condiments') {
                                        categoryIcon = 'bi-droplet-half';
                                        categoryColor = '#F97316';
                                    } else if (itemCategory === 'grains') {
                                        categoryIcon = 'bi-grid-3x3';
                                        categoryColor = '#A855F7';
                                    } else if (itemCategory === 'frozen') {
                                        categoryIcon = 'bi-snow';
                                        categoryColor = '#06B6D4';
                                    }
                                    
                                    card.innerHTML = `
                                        <div class="category-indicator category-${itemCategory}" data-category="${itemCategory}"></div>
                                        <div class="pantry-card-content">
                                            <div class="item-header">
                                                <div class="item-icon-wrapper">
                                                    <i class="bi ${categoryIcon}" style="color: ${categoryColor};"></i>
                                                    </div>
                                                <div class="item-info">
                                                    <h6 class="item-name" title="${itemName}">${itemName}</h6>
                                                </div>
                                                <button type="button" class="item-delete-btn delete-item-btn" 
                                                        title="Remove item" 
                                                        data-item-id="${itemId}"
                                                        data-item-name="${itemName}">
                                                    <i class="bi bi-trash3-fill"></i>
                                                </button>
                                            </div>
                                            <div class="item-metadata">
                                                <span class="metadata-badge quantity-badge editable-quantity" 
                                                      data-item-id="${itemId}"
                                                      data-item-name="${itemName}"
                                                      data-current-quantity="${itemQuantity}"
                                                      data-expiration-date="${itemExpDate}"
                                                      data-added-date="${itemAddedDate}"
                                                      title="Click to edit quantity">
                                                    <i class="bi bi-hash"></i>
                                                    <span class="quantity-value">${itemQuantity}</span>
                                                </span>
                                                <span class="metadata-badge expiration-badge-modern ${expBadgeClass} editable-expiration" 
                                                      data-item-id="${itemId}"
                                                      data-item-name="${itemName}"
                                                      data-current-quantity="${itemQuantity}"
                                                      data-current-expiration="${itemExpDate}"
                                                      data-added-date="${itemAddedDate}"
                                                      data-exp-date="${itemExpDate}"
                                                      title="Click to ${itemExpDate ? 'edit' : 'add'} expiration">
                                                    <i class="bi bi-${itemExpDate ? 'calendar3' : 'calendar-plus'}"></i>
                                                    <span class="expiration-value">${itemExpDate ? itemExpDate.substring(0, 10) : 'Add Date'}</span>
                                                </span>
                                            </div>
                                        </div>
                                    `;
                                    
                                    itemWrapper.appendChild(card);
                                    container.appendChild(itemWrapper);
                                });
                                // Reinitialize interactive elements
                                initializeDeleteButtons();
                                initializeQuantityEditing();
                                initializeExpirationEditing();
                                // Update category accent bars with category colors
                                if (typeof updateCategoryAccentBars === 'function') {
                                    updateCategoryAccentBars();
                                }
                                // Update empty state and stats
                                if (typeof updateEmptyState === 'function') {
                                    updateEmptyState();
                                }
                                if (typeof updateProgressIndicator === 'function') {
                                    updateProgressIndicator();
                                }
                                // Update stats
                                const statsCount = document.getElementById('pantryStatsCount');
                                if (statsCount) {
                                    statsCount.textContent = apiData.items.length;
                                }
                                // Update badge
                                const pantryCard = container.closest('.card');
                                if (pantryCard) {
                                    const header = pantryCard.querySelector('.card-header');
                                    if (header) {
                                        let badge = header.querySelector('.badge');
                                        if (!badge) {
                                            badge = document.createElement('span');
                                            badge.className = 'badge bg-primary ms-2';
                                            const headerDiv = header.querySelector('.d-flex');
                                            if (headerDiv) {
                                                headerDiv.appendChild(badge);
                                            }
                                        }
                                        badge.textContent = apiData.items.length;
                                        badge.style.display = apiData.items.length > 0 ? '' : 'none';
                                    }
                                }
                                console.log('Successfully reloaded via API fallback');
                                return; // Success, exit early
                            } else {
                                // No items - show empty state
                                if (typeof updateEmptyState === 'function') {
                                    updateEmptyState();
                                }
                            }
                        }
                    }
                }
            } catch (apiError) {
                console.error('API fallback also failed:', apiError);
            }
            
            // If all methods fail, show error message
            const feedback = document.getElementById('addItemFeedback') || document.getElementById('addItemModalFeedback');
            if (feedback) {
                try {
                    showFeedback('Items added but failed to refresh. Please refresh the page.', 'warning');
                } catch (feedbackError) {
                    console.error('Error showing feedback:', feedbackError);
                }
            }
        } finally {
            // Always reset the reload flag
            reloadInProgress = false;
            if (reloadTimeoutId) {
                clearTimeout(reloadTimeoutId);
                reloadTimeoutId = null;
            }
            
            // CRITICAL: Update empty state and stats after reload completes
            setTimeout(() => {
                if (typeof updateEmptyState === 'function') {
                    updateEmptyState();
                }
                if (typeof updateProgressIndicator === 'function') {
                    updateProgressIndicator();
                }
            }, 100);
            
            // Re-apply all active filters after reload to maintain filter state
            if (typeof applyAllFilters === 'function') {
                setTimeout(() => {
                    applyAllFilters();
                    // Update empty state again after filters are applied
                    if (typeof updateEmptyState === 'function') {
                        updateEmptyState();
                    }
                }, 200);
            }
        }
    }
    
    // Handle delete item via AJAX - uses API endpoint with item ID or name
    async function handleDeleteItem(itemIdOrName) {
        if (!itemIdOrName) {
            console.error('Item identifier is required for deletion');
            alert('Error: Item identifier is missing. Please try again.');
            return;
        }
        
        // Store scroll position before deletion
        const scrollPosition = window.pageYOffset || document.documentElement.scrollTop;
        
        // Use item identifier as-is for display
        const displayName = itemIdOrName.trim();
        
        // Confirm deletion
        if (!confirm(`Remove "${displayName}" from pantry?`)) {
            return;
        }
        
        try {
            // Properly encode the item ID/name for URL
            const encodedId = encodeURIComponent(itemIdOrName.trim());
            console.log(' Deleting item:', itemIdOrName, 'Encoded:', encodedId);
            
            // Use the API endpoint with DELETE method
            const response = await fetchWithTimeout(`/api/pantry/${encodedId}`, {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-Client-Type': 'web'
                },
                cache: 'no-cache',  // Prevent caching
                credentials: 'same-origin'
            });
            
            console.log(' Delete response status:', response.status);
            
            if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                    console.log(' Delete successful:', data.message);
                
                // Add small delay to ensure server has finished processing
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Reload items (this will restore scroll position internally)
                try {
                    await reloadPantryItems();
                    
                    // Restore scroll position after reload
                    setTimeout(() => {
                        try {
                            window.scrollTo(0, scrollPosition);
                        } catch (scrollError) {
                            console.error('Error restoring scroll position:', scrollError);
                        }
                    }, 100);
                } catch (reloadError) {
                    console.error('Error reloading after delete:', reloadError);
                    // Still show success message even if reload fails
                }
                
                // Show success feedback
                    showFeedback('Item removed successfully!', 'success');
                } else {
                    throw new Error(data.error || 'Failed to delete item');
                }
            } else {
                const errorText = await response.text();
                let errorData;
                try {
                    errorData = JSON.parse(errorText);
                } catch (e) {
                    errorData = { error: errorText || 'Unknown error' };
                }
                console.error(' Delete failed:', errorData);
                throw new Error(errorData.error || `Failed to delete item (Status: ${response.status})`);
            }
        } catch (error) {
            console.error(' Delete error:', error);
                showFeedback('Failed to delete item: ' + error.message, 'danger');
        }
    }
    
    // Initialize delete buttons
    function initializeDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.delete-item-btn');
        console.log(` Initializing ${deleteButtons.length} delete buttons...`);
        
        deleteButtons.forEach((btn, index) => {
            // Skip if button is not in DOM
            if (!btn.parentNode) {
                console.warn(` Delete button ${index} has no parent, skipping`);
                return;
            }
            
            // Remove any existing listeners by cloning (but remove inline onclick)
            const newBtn = btn.cloneNode(true);
            // Remove inline onclick handler that might interfere
            newBtn.removeAttribute('onclick');
            // Ensure button is clickable
            newBtn.style.pointerEvents = 'auto';
            newBtn.style.cursor = 'pointer';
            newBtn.style.zIndex = '1001';
            newBtn.style.position = 'relative';
            
            try {
            btn.parentNode.replaceChild(newBtn, btn);
            } catch (replaceError) {
                console.error(` Failed to replace delete button ${index}:`, replaceError);
                return;
            }
            
            // Add click listener with event delegation
            newBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                
                console.log(' Delete button clicked');
                
                // Try to get item ID first (preferred), then fall back to item name
                let itemId = this.getAttribute('data-item-id');
                let itemName = this.getAttribute('data-item-name');
                
                // Validate that we have at least one identifier
                if (!itemId && (!itemName || !itemName.trim())) {
                    console.error(' Item identifier is missing for delete button', {
                        itemId: itemId,
                        itemName: itemName,
                        button: this
                    });
                    showFeedback('Error: Item identifier is missing. Please refresh the page.', 'danger');
                    return;
                }
                
                // Decode if it was URL-encoded, but keep original for API call
                try {
                    if (itemName) {
                    itemName = decodeURIComponent(itemName);
                    }
                    if (itemId) {
                        itemId = decodeURIComponent(itemId);
                    }
                } catch (decodeError) {
                    // If decode fails, use as-is
                    console.warn(' Failed to decode item identifier:', decodeError);
                }
                
                console.log(' Delete button clicked for item:', { itemId, itemName });
                
                // Use itemId if available, otherwise use itemName
                const identifier = itemId || itemName;
                handleDeleteItem(identifier);
            }, true); // Use capture phase to ensure it fires before other handlers
        });
        
        console.log(` Initialized ${deleteButtons.length} delete buttons`);
    }
    
    // Scroll to add item form function
    function scrollToAddItemForm() {
        const addItemForm = document.getElementById('addItemForm');
        if (addItemForm) {
            addItemForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Focus on the input after scrolling
            setTimeout(() => {
                const itemInput = document.getElementById('itemInput');
                if (itemInput) {
                    itemInput.focus();
                }
            }, 500);
        } else {
            // Fallback: scroll to top where the form should be
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
    }
    
    // Make function globally available
    window.scrollToAddItemForm = scrollToAddItemForm;
    
    // Open edit item modal
    function openEditItemModal(itemId, itemName, quantity, expirationDate, addedDate) {
        console.log('openEditItemModal called with:', { itemId, itemName, quantity, expirationDate, addedDate });
        try {
            // Check if modal elements exist
            const modalElement = document.getElementById('editItemModal');
            if (!modalElement) {
                console.error('Edit item modal not found in DOM');
                showFeedback('Edit modal not available. Please refresh the page.', 'danger');
                return;
            }
            
            // Populate form fields with null checks
            const editItemId = document.getElementById('editItemId');
            const editItemName = document.getElementById('editItemName');
            const editItemQuantity = document.getElementById('editItemQuantity');
            const editItemAddedDate = document.getElementById('editItemAddedDate');
            const editItemExpiration = document.getElementById('editItemExpiration');
            
            if (!editItemId || !editItemName || !editItemQuantity || !editItemAddedDate || !editItemExpiration) {
                console.error('Edit modal form fields not found');
                showFeedback('Edit form not available. Please refresh the page.', 'danger');
                return;
            }
            
            editItemId.value = itemId || '';
            editItemName.value = itemName || '';
            editItemQuantity.value = quantity || '1';
            editItemAddedDate.value = addedDate || '';
            
            // Set expiration date (format: YYYY-MM-DD)
            let expDateValue = '';
            if (expirationDate && expirationDate.trim() && expirationDate !== 'None' && expirationDate !== 'null') {
                // Try to extract date part if it's a full datetime string
                const dateMatch = expirationDate.match(/^(\d{4}-\d{2}-\d{2})/);
                if (dateMatch) {
                    expDateValue = dateMatch[1];
                } else if (expirationDate.length >= 10) {
                    expDateValue = expirationDate.substring(0, 10);
                }
            }
            editItemExpiration.value = expDateValue;
            
            // Show modal
            if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                const modal = new bootstrap.Modal(modalElement);
                modal.show();
            } else {
                console.error('Bootstrap Modal not available');
                showFeedback('Modal library not loaded. Please refresh the page.', 'danger');
            }
        } catch (error) {
            console.error('Error opening edit modal:', error);
            showFeedback('Failed to open edit form: ' + (error.message || 'Unknown error'), 'danger');
        }
    }
    
    // Make function globally available
    window.openEditItemModal = openEditItemModal;
    
    // Add event delegation for pantry item clicks (works for both server-rendered and dynamically-rendered items)
    document.addEventListener('click', function(e) {
        // Check if click is on a pantry-item-card
        const pantryCard = e.target.closest('.pantry-item-card');
        if (pantryCard && !e.target.closest('.delete-item-btn') && !e.target.closest('.editable-quantity') && !e.target.closest('.editable-expiration')) {
            // Get item data from the card first (preferred), then fall back to wrapper
            const itemWrapper = pantryCard.closest('.pantry-item-wrapper');
            
            // Try to get data from card's data attributes first
            let itemId = pantryCard.getAttribute('data-item-id') || '';
            let itemName = pantryCard.getAttribute('data-item-name') || '';
            let quantity = pantryCard.getAttribute('data-quantity') || '1';
            let expDate = pantryCard.getAttribute('data-expiration-date') || '';
            let addedDate = pantryCard.getAttribute('data-added-date') || '';
            
            // Fall back to wrapper or element-based extraction if card doesn't have data attributes
            if (!itemName && itemWrapper) {
                itemId = itemWrapper.getAttribute('data-item-id') || itemId;
                // Get item name from the h6 element (actual display name, not lowercase)
                const itemNameElement = pantryCard.querySelector('h6');
                itemName = itemNameElement ? itemNameElement.textContent.trim() : '';
                
                // Get quantity from badge or default to 1
                const quantityBadge = itemWrapper.querySelector('.editable-quantity');
                quantity = quantityBadge ? (quantityBadge.getAttribute('data-current-quantity') || quantityBadge.querySelector('.quantity-value')?.textContent?.trim() || '1') : quantity;
                
                // Get expiration date
                const expDateBadge = itemWrapper.querySelector('.editable-expiration');
                expDate = expDateBadge ? (expDateBadge.getAttribute('data-current-expiration') || expDateBadge.getAttribute('data-exp-date') || '') : 
                         (itemWrapper.getAttribute('data-expiration-date') || expDate);
                
                // Get added date
                addedDate = itemWrapper.getAttribute('data-added-date') || addedDate;
            } else if (!itemName) {
                // Last resort: try to get from h6 element
                const itemNameElement = pantryCard.querySelector('h6');
                itemName = itemNameElement ? itemNameElement.textContent.trim() : '';
            }
                
            if (itemName) {
                e.preventDefault();
                e.stopPropagation();
                if (typeof openEditItemModal === 'function') {
                    openEditItemModal(itemId, itemName, quantity, expDate, addedDate);
                } else {
                    console.error('openEditItemModal function not found');
                }
            }
        }
    });
    
    // Handle edit item form submission
    async function handleEditItemSubmit(event) {
        event.preventDefault();
        
        try {
            // Get form elements with null checks
            const editItemId = document.getElementById('editItemId');
            const editItemName = document.getElementById('editItemName');
            const editItemQuantity = document.getElementById('editItemQuantity');
            const editItemExpiration = document.getElementById('editItemExpiration');
            const editItemAddedDate = document.getElementById('editItemAddedDate');
            const saveBtn = document.getElementById('editItemSaveBtn');
            
            if (!editItemId || !editItemName || !editItemQuantity || !editItemExpiration || !editItemAddedDate || !saveBtn) {
                console.error('Edit form elements not found');
                showFeedback('Edit form not available. Please refresh the page.', 'danger');
                return false;
            }
            
            const itemId = editItemId.value;
            const itemName = editItemName.value.trim();
            const quantity = editItemQuantity.value || '1';
            const expirationDate = editItemExpiration.value || null;
            const addedDate = editItemAddedDate.value || new Date().toISOString();
            
            // Validate item name
            if (!itemName) {
                showFeedback('Item name cannot be empty', 'danger');
                return false;
            }
            
            // Disable save button and show loading state
            const originalBtnText = saveBtn.innerHTML;
            saveBtn.disabled = true;
            saveBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Saving...';
            
            try {
                // Call the existing update function
                await handleUpdateItem(itemId, itemName, quantity, expirationDate, addedDate, 'item');
                
                // Close modal on success
                if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                    const modal = bootstrap.Modal.getInstance(document.getElementById('editItemModal'));
                    if (modal) {
                        modal.hide();
                    }
                }
            } catch (error) {
                console.error('Error updating item:', error);
                showFeedback('Failed to update item: ' + (error.message || 'Unknown error'), 'danger');
            } finally {
                // Restore button state
                saveBtn.disabled = false;
                saveBtn.innerHTML = originalBtnText;
            }
        } catch (error) {
            console.error('Error in handleEditItemSubmit:', error);
            showFeedback('Failed to process edit: ' + (error.message || 'Unknown error'), 'danger');
        }
        
        return false;
    }
    
    // Handle item update via API (for both quantity and expiration date)
    async function handleUpdateItem(itemId, itemName, quantity, expirationDate, addedDate, updateType = 'item') {
        // Allow empty itemId - backend will fallback to name matching
        if (!itemName || !itemName.trim()) {
            console.error('Item name is required for update');
            showFeedback('Error: Item name missing', 'danger');
            return;
        }
        
        try {
            // Prepare update data
            const updateData = {
                name: itemName,
                quantity: quantity || '1',
                expirationDate: expirationDate || null,
                addedDate: addedDate || new Date().toISOString()
            };
            
            // Get user ID and client type from headers (if available)
            // For web requests, we rely on session cookies, but set X-Client-Type for clarity
            const headers = {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest',
                'X-Client-Type': 'web'  // Explicitly identify as web client
            };
            
            // Encode item ID for URL (use 'unknown' if empty to avoid invalid URL)
            const encodedItemId = itemId && itemId.trim() ? encodeURIComponent(itemId) : 'unknown';
            
            const response = await fetchWithTimeout(`/api/pantry/${encodedItemId}`, {
                method: 'PUT',
                headers: headers,
                body: JSON.stringify(updateData),
                credentials: 'same-origin'
            });
            
            if (response.ok) {
                let data;
                try {
                    data = await response.json();
                } catch (jsonError) {
                    console.error('Failed to parse JSON response:', jsonError);
                    throw new Error('Invalid response from server');
                }
                
                if (data && data.success) {
                    // Check if item was deleted (quantity reached 0)
                    if (data.deleted) {
                        const feedback = document.getElementById('addItemFeedback');
                        if (feedback) {
                            showFeedback(data.message || 'Item removed (quantity reached 0)', 'info');
                        }
                    } else {
                        // Show success feedback
                        const feedback = document.getElementById('addItemFeedback');
                        if (feedback) {
                            const message = updateType === 'expiration' ? 'Expiration date updated successfully!' : 'Item updated successfully!';
                            showFeedback(message, 'success');
                        }
                    }
                    
                    // Reload pantry items to reflect the change - with retries
                    let reloadAttempts = 0;
                    const maxReloadAttempts = 3;
                    const reloadWithRetry = async () => {
                        reloadAttempts++;
                        try {
                            console.log(` Reloading pantry (attempt ${reloadAttempts}/${maxReloadAttempts})...`);
                            // Prefer API-based reload for consistency with other flows
                            if (typeof reloadPantryItemsFromAPI === 'function') {
                                await reloadPantryItemsFromAPI();
                            } else if (typeof reloadPantryItems === 'function') {
                                await reloadPantryItems();
                            } else {
                                // Fallback: full page reload if no helper is available
                                console.warn('No pantry reload function available after edit, reloading page');
                                window.location.reload();
                                return;
                            }
                            
                            // Verify items were reloaded
                            setTimeout(() => {
                                const container = document.getElementById('pantryItemsContainer');
                                if (container && container.children.length === 0 && reloadAttempts < maxReloadAttempts) {
                                    console.warn('Pantry appears empty after reload, retrying...');
                                    reloadWithRetry();
                                }
                            }, 500);
                        } catch (reloadError) {
                            console.error(`Error reloading after update (attempt ${reloadAttempts}):`, reloadError);
                            if (reloadAttempts < maxReloadAttempts) {
                                setTimeout(reloadWithRetry, 1000 * reloadAttempts);
                            } else {
                                // Show warning but don't fail completely
                                const feedback = document.getElementById('addItemFeedback');
                                if (feedback) {
                                    showFeedback('Item updated but failed to refresh. Please refresh the page.', 'warning');
                                }
                            }
                        }
                    };
                    
                    // Start reload with delay to ensure backend saved
                    setTimeout(reloadWithRetry, 300);
                } else {
                    throw new Error(data.error || 'Failed to update item');
                }
            } else {
                const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                throw new Error(errorData.error || 'Failed to update item');
            }
        } catch (error) {
            console.error('Error updating item:', error);
            const feedback = document.getElementById('addItemFeedback');
            if (feedback) {
                const message = updateType === 'expiration' ? 'Failed to update expiration date: ' : 'Failed to update item: ';
                showFeedback(message + error.message, 'danger');
            } else {
                alert('Failed to update item: ' + error.message);
            }
        }
    }
    
    // Handle quantity update via API (backward compatibility)
    async function handleUpdateQuantity(itemId, itemName, newQuantity, expirationDate, addedDate) {
        await handleUpdateItem(itemId, itemName, newQuantity, expirationDate, addedDate, 'quantity');
    }
    
    // Handle expiration date update via API
    async function handleUpdateExpiration(itemId, itemName, quantity, newExpirationDate, addedDate) {
        await handleUpdateItem(itemId, itemName, quantity, newExpirationDate, addedDate, 'expiration');
    }
    
    // Initialize quantity editing
    function initializeQuantityEditing() {
        const quantityBadges = document.querySelectorAll('.editable-quantity');
        console.log(` Initializing ${quantityBadges.length} quantity badges for editing...`);
        
        quantityBadges.forEach((badge, index) => {
            // Remove existing listeners by cloning
            if (!badge.parentNode) {
                console.warn(` Quantity badge ${index} has no parent, skipping`);
                return; // Skip if badge is not in DOM
            }
            
            const newBadge = badge.cloneNode(true);
            try {
            badge.parentNode.replaceChild(newBadge, badge);
            } catch (replaceError) {
                console.error(` Failed to replace quantity badge ${index}:`, replaceError);
                return;
            }
            
            // Add click listener - ensure it works
            newBadge.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card click
                e.stopImmediatePropagation(); // Prevent other handlers
                e.preventDefault();
                
                console.log(' Quantity badge clicked');
                
                // Prevent multiple simultaneous edits
                if (this.classList.contains('editing')) {
                    console.log(' Already editing, ignoring click');
                    return;
                }
                this.classList.add('editing');
                
                const itemId = this.getAttribute('data-item-id') || '';
                // Item ID can be empty - backend will use name matching as fallback
                
                const itemName = this.getAttribute('data-item-name');
                if (!itemName || !itemName.trim()) {
                    console.error('Item name is missing for quantity edit');
                    this.classList.remove('editing');
                    return;
                }
                
                const currentQuantity = this.getAttribute('data-current-quantity') || '1';
                // Get expiration date from the expiration badge if it exists, or from data attribute
                const expirationBadge = this.closest('.pantry-item-wrapper')?.querySelector('.editable-expiration');
                const expirationDate = expirationBadge?.getAttribute('data-current-expiration') || 
                                      this.getAttribute('data-expiration-date') || 
                                      null;
                const addedDate = this.getAttribute('data-added-date') || new Date().toISOString();
                
                // Create input field
                const quantityValue = this.querySelector('.quantity-value');
                if (!quantityValue) {
                    this.classList.remove('editing');
                    return;
                }
                
                const oldText = quantityValue.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentQuantity;
                input.style.cssText = 'background: white; border: 2px solid #8B5CF6; border-radius: 6px; padding: 2px 6px; font-size: 0.75rem; width: 60px; text-align: center; color: #8B5CF6;';
                input.className = 'quantity-input';
                
                // Replace text with input
                quantityValue.textContent = '';
                quantityValue.appendChild(input);
                input.focus();
                input.select();
                
                // Handle save on blur or Enter
                const saveQuantity = async () => {
                    // Remove event listeners to prevent double calls
                    input.removeEventListener('blur', saveQuantity);
                    
                    let newQuantity = input.value.trim() || '1';
                    // Validate quantity: must be a positive integer
                    const quantityNum = parseInt(newQuantity, 10);
                    if (isNaN(quantityNum) || quantityNum < 0) {
                        // Invalid input - restore original value
                        if (quantityValue) {
                            quantityValue.textContent = oldText;
                        }
                        newBadge.classList.remove('editing');
                        showFeedback('Quantity must be a positive number', 'danger');
                        return;
                    }
                    // Ensure quantity is at least 0 (0 will delete the item)
                    newQuantity = Math.max(0, quantityNum).toString();
                    
                    if (newQuantity !== currentQuantity) {
                        // Show loading state
                        quantityValue.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Saving...';
                        
                        try {
                            // Update the badge attribute
                            newBadge.setAttribute('data-current-quantity', newQuantity);
                            // Call API to update
                            await handleUpdateQuantity(itemId, itemName, newQuantity, expirationDate, addedDate);
                            // The reloadPantryItems() in handleUpdateQuantity will refresh the display
                        } catch (error) {
                            // On error, restore original display
                            if (quantityValue) {
                                quantityValue.textContent = oldText;
                            }
                        } finally {
                            // Always remove editing class
                            newBadge.classList.remove('editing');
                        }
                    } else {
                        // Restore original text if no change
                        if (quantityValue) {
                            quantityValue.textContent = oldText;
                        }
                        newBadge.classList.remove('editing');
                    }
                };
                
                const cancelEdit = () => {
                    if (quantityValue) {
                        quantityValue.textContent = oldText;
                    }
                    newBadge.classList.remove('editing');
                };
                
                input.addEventListener('blur', saveQuantity);
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
            });
        });
    }
    
    // Initialize expiration date editing
    function initializeExpirationEditing() {
        const expirationBadges = document.querySelectorAll('.editable-expiration');
        console.log(` Initializing ${expirationBadges.length} expiration badges...`);
        
        expirationBadges.forEach((badge, index) => {
            // Remove existing listeners by cloning
            if (!badge.parentNode) {
                console.warn(` Expiration badge ${index} has no parent, skipping`);
                return; // Skip if badge is not in DOM
            }
            
            const newBadge = badge.cloneNode(true);
            try {
            badge.parentNode.replaceChild(newBadge, badge);
            } catch (replaceError) {
                console.error(` Failed to replace expiration badge ${index}:`, replaceError);
                return;
            }
            
            // Add click listener - ensure it works
            newBadge.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent card click
                e.stopImmediatePropagation(); // Prevent other handlers
                e.preventDefault();
                
                console.log(' Expiration badge clicked');
                
                // Prevent multiple simultaneous edits
                if (this.classList.contains('editing')) {
                    console.log(' Already editing, ignoring click');
                    return;
                }
                this.classList.add('editing');
                
                const itemId = this.getAttribute('data-item-id') || '';
                // Item ID can be empty - backend will use name matching as fallback
                
                const itemName = this.getAttribute('data-item-name');
                if (!itemName || !itemName.trim()) {
                    console.error(' Item name is missing for expiration date edit');
                    this.classList.remove('editing');
                    showFeedback('Error: Item name missing. Please refresh the page.', 'danger');
                    return;
                }
                
                const currentQuantity = this.getAttribute('data-current-quantity') || '1';
                const currentExpiration = this.getAttribute('data-current-expiration') || '';
                const addedDate = this.getAttribute('data-added-date') || new Date().toISOString();
                
                // Create date input field
                const expirationValue = this.querySelector('.expiration-value');
                if (!expirationValue) {
                    this.classList.remove('editing');
                    return;
                }
                
                const oldText = expirationValue.textContent;
                const input = document.createElement('input');
                input.type = 'date';
                
                // Set current date value (format: YYYY-MM-DD)
                let currentDateValue = '';
                if (currentExpiration && currentExpiration !== 'None' && currentExpiration !== '' && currentExpiration !== 'null') {
                    // Extract date part if it's a full datetime string
                    const trimmedDate = currentExpiration.trim();
                    // Check if it's a valid date format (YYYY-MM-DD or longer)
                    if (trimmedDate.length >= 10) {
                        // Extract first 10 characters (YYYY-MM-DD)
                        const datePart = trimmedDate.substring(0, 10);
                        // Validate it's in YYYY-MM-DD format
                        if (/^\d{4}-\d{2}-\d{2}$/.test(datePart)) {
                            currentDateValue = datePart;
                        } else {
                            // Try to parse and reformat
                            try {
                                const dateObj = new Date(trimmedDate);
                                if (!isNaN(dateObj.getTime())) {
                                    currentDateValue = dateObj.toISOString().split('T')[0];
                                }
                            } catch (e) {
                                console.warn('Failed to parse expiration date:', trimmedDate);
                            }
                        }
                    } else if (trimmedDate.length > 0) {
                        // Try to parse shorter date strings
                        try {
                            const dateObj = new Date(trimmedDate);
                            if (!isNaN(dateObj.getTime())) {
                                currentDateValue = dateObj.toISOString().split('T')[0];
                            } else {
                                currentDateValue = trimmedDate;
                            }
                        } catch (e) {
                            currentDateValue = trimmedDate;
                        }
                    }
                }
                input.value = currentDateValue;
                
                // Set minimum date to today
                const today = new Date().toISOString().split('T')[0];
                input.min = today;
                
                input.style.cssText = 'background: white !important; border: 2px solid #8B5CF6 !important; border-radius: 8px !important; padding: 5px 8px !important; font-size: 0.75rem !important; font-weight: 600 !important; color: #8B5CF6 !important; width: 150px !important; min-width: 150px !important; display: inline-block !important; outline: none !important; box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1) !important;';
                input.className = 'expiration-input';
                
                // Clear and replace content properly
                expirationValue.innerHTML = '';
                expirationValue.style.display = 'inline-block';
                expirationValue.appendChild(input);
                
                // Focus and show picker after a small delay to ensure DOM is ready
            setTimeout(() => {
                    input.focus();
                    input.select();
                    // Try to show date picker if supported
                    if (input.showPicker && typeof input.showPicker === 'function') {
                        try {
                            input.showPicker();
                        } catch (e) {
                            // showPicker not supported, just focus
                            input.focus();
                        }
                    }
                }, 10);
                
                // Handle save on blur or change
                const saveExpiration = async () => {
                    const newExpiration = input.value.trim() || null;
                    const oldExpirationFormatted = currentDateValue || null;
                    
                    // Remove input event listeners to prevent double calls
                    input.removeEventListener('change', saveExpiration);
                    input.removeEventListener('blur', saveExpiration);
                    
                    if (newExpiration !== oldExpirationFormatted) {
                        // Show loading state
                        expirationValue.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Saving...';
                        
                        try {
                            // Update the badge attributes
                            newBadge.setAttribute('data-current-expiration', newExpiration || '');
                            newBadge.setAttribute('data-exp-date', newExpiration || '');
                            
                            // Call API to update
                            await handleUpdateExpiration(itemId, itemName, currentQuantity, newExpiration, addedDate);
                            
                            // The reloadPantryItems() in handleUpdateExpiration will refresh the display
                            // So we don't need to manually update here
                        } catch (error) {
                            // On error, restore original display (just text, icon is already outside)
                            if (expirationValue && oldText && oldText.trim() !== '') {
                                expirationValue.textContent = oldText;
                            } else if (expirationValue) {
                                expirationValue.textContent = 'Add Date';
                            }
                        } finally {
                            // Always remove editing class
                            newBadge.classList.remove('editing');
                        }
                    } else {
                        // Restore original display if no change (just text, icon is already outside)
                        if (expirationValue && oldText && oldText.trim() !== '') {
                            expirationValue.textContent = oldText;
                        } else if (expirationValue) {
                            expirationValue.textContent = 'Add Date';
                        }
                        newBadge.classList.remove('editing');
                    }
                };
                
                const cancelEdit = () => {
                    // Remove input event listeners
                    input.removeEventListener('change', saveExpiration);
                    input.removeEventListener('blur', saveExpiration);
                    
                    // Restore original display (just text, icon is already outside)
                    if (oldText && oldText.trim() !== '') {
                        expirationValue.textContent = oldText;
                    } else {
                        expirationValue.textContent = 'Add Date';
                    }
                };
                
                input.addEventListener('change', saveExpiration);
                input.addEventListener('blur', saveExpiration);
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.blur();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        cancelEdit();
                    }
                });
            });
        });
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        initializeDeleteButtons();
        initializeQuantityEditing();
        initializeExpirationEditing();
        
        // Update expiration badges and card backgrounds on initial load
        updateExpirationBadges();
        updatePantryCardBackgrounds();
        updateExpiringSoonBanner();
        
        // Update category accent bars with category colors
        if (typeof updateCategoryAccentBars === 'function') {
            updateCategoryAccentBars();
        }
        
        // Restore sort type if one was saved
        const savedSortType = sessionStorage.getItem('pantrySortType');
        if (savedSortType) {
            currentSortType = savedSortType;
            // Update sort label
            updateSortLabel(getSortLabel(savedSortType));
            // Apply sort after a short delay to ensure DOM is ready
            setTimeout(() => {
                sortPantry(savedSortType);
                // Update accent bars after sorting
                if (typeof updateCategoryAccentBars === 'function') {
                    updateCategoryAccentBars();
                }
            }, 300);
        } else {
            // Even without sort, update backgrounds after a delay to ensure DOM is ready
            setTimeout(() => {
                updateExpirationBadges();
                updatePantryCardBackgrounds();
                // Update accent bars
                if (typeof updateCategoryAccentBars === 'function') {
                    updateCategoryAccentBars();
                }
            }, 200);
        }
    });
    
    // Update Expiring Soon Banner
    function updateExpiringSoonBanner() {
        const banner = document.getElementById('expiringSoonBanner');
        const bannerText = document.getElementById('expiringSoonText');
        const filterBtn = document.getElementById('filterExpiringBtn');
        if (!banner || !bannerText) return;
        
        const items = document.querySelectorAll('.pantry-item-wrapper');
        if (items.length === 0) {
            banner.style.display = 'none';
            return;
        }
        
        // Count expiring items (within 5 days)
        let expiringCount = 0;
        let expiringItems = [];
        items.forEach(item => {
            const expirationBadge = item.querySelector('.expiration-badge-modern[data-exp-date]');
            if (expirationBadge) {
                const expDate = expirationBadge.getAttribute('data-exp-date');
                if (expDate && expDate !== '9999-12-31') {
                    const daysDiff = getDaysUntilExpiration(expDate);
                    if (daysDiff >= 0 && daysDiff <= 5) {
                        expiringCount++;
                        const itemName = item.querySelector('.fw-bold')?.textContent?.trim() || 'Item';
                        expiringItems.push({ name: itemName, days: daysDiff });
                    }
                }
            }
        });
        
        if (expiringCount > 0) {
            banner.style.display = 'block';
            bannerText.innerHTML = `<strong> ${expiringCount} item${expiringCount > 1 ? 's' : ''} expire in the next 5 days.</strong> ${expiringItems.slice(0, 3).map(item => item.name).join(', ')}${expiringCount > 3 ? '...' : ''}`;
            if (filterBtn) {
                // Remove existing listeners and add new one
                const newFilterBtn = filterBtn.cloneNode(true);
                filterBtn.parentNode.replaceChild(newFilterBtn, filterBtn);
                newFilterBtn.addEventListener('click', () => {
                    // Trigger expiring soon filter
                    const expiringFilter = document.querySelector('.filter-chip[data-filter="expiring-soon"]');
                    if (expiringFilter) {
                        if (!expiringFilter.classList.contains('active')) {
                            expiringFilter.click();
                        }
                        // Scroll to items
                        document.getElementById('pantryItemsContainer')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            }
        } else {
            banner.style.display = 'none';
        }
    }
    
    // Smart Suggestions Banner (legacy - kept for compatibility)
    function updateSmartSuggestions() {
        const banner = document.getElementById('smartSuggestionsBanner');
        const suggestionText = document.getElementById('suggestionText');
        if (!banner || !suggestionText) {
            console.warn(' Smart suggestions banner or text element not found');
            return;
        }
        
        try {
        const items = document.querySelectorAll('.pantry-item-wrapper');
        if (items.length === 0) {
                banner.style.display = 'block'; // Show banner even when empty
            suggestionText.textContent = 'Add items to get smart suggestions!';
            return;
        }
        
        // Count expiring items
        let expiringCount = 0;
        items.forEach(item => {
                const expirationBadge = item.querySelector('.expiration-badge.expiration-soon, .expiration-badge.expiration-expired, .expiration-badge-modern');
            if (expirationBadge) {
                    const expDate = expirationBadge.getAttribute('data-exp-date') || expirationBadge.getAttribute('data-current-expiration');
                    if (expDate && expDate !== '9999-12-31' && expDate !== 'None' && expDate !== 'null' && expDate !== '') {
                        try {
                            const daysDiff = typeof getDaysUntilExpiration === 'function' ? getDaysUntilExpiration(expDate) : null;
                            if (daysDiff !== null && daysDiff >= 0 && daysDiff <= 7) {
                        expiringCount++;
                            }
                        } catch (e) {
                            // Ignore date parsing errors
                    }
                }
            }
        });
        
            banner.style.display = 'block';
            if (expiringCount > 0) {
            suggestionText.textContent = `You have ${expiringCount} item${expiringCount > 1 ? 's' : ''} expiring this week. Consider using them in recipes!`;
        } else {
            suggestionText.textContent = `You have ${items.length} item${items.length > 1 ? 's' : ''} in your pantry. Ready to cook!`;
            }
        } catch (error) {
            console.error('Error updating smart suggestions:', error);
            banner.style.display = 'block';
            const items = document.querySelectorAll('.pantry-item-wrapper');
            suggestionText.textContent = items.length === 0 
                ? 'Add items to get smart suggestions!' 
                : `You have ${items.length} item${items.length > 1 ? 's' : ''} in your pantry.`;
        }
    }
    
    // Initialize suggestions with timeout
    let suggestionTimeout;
    function initializeSuggestions() {
        const suggestionText = document.getElementById('suggestionText');
        if (!suggestionText) return;
        
        // Clear any existing timeout
        if (suggestionTimeout) {
            clearTimeout(suggestionTimeout);
        }
        
        // Set loading state
        suggestionText.textContent = 'Loading suggestions...';
        
        // Update after a short delay (allows DOM to be ready)
        suggestionTimeout = setTimeout(() => {
            try {
                if (typeof updateSmartSuggestions === 'function') {
                    updateSmartSuggestions();
                } else {
                    throw new Error('updateSmartSuggestions function not found');
                }
            } catch (error) {
                console.error('Error updating suggestions:', error);
                // Fallback: show default message
                const items = document.querySelectorAll('.pantry-item-wrapper');
                if (items.length === 0) {
                    suggestionText.textContent = 'Add items to get smart suggestions!';
                } else {
                    suggestionText.textContent = `You have ${items.length} item${items.length > 1 ? 's' : ''} in your pantry.`;
                }
            }
        }, 500);
        
        // Fallback timeout - if still loading after 2 seconds, show default
        setTimeout(() => {
            if (suggestionText && suggestionText.textContent === 'Loading suggestions...') {
                const items = document.querySelectorAll('.pantry-item-wrapper');
                if (items.length === 0) {
                    suggestionText.textContent = 'Add items to get smart suggestions!';
                } else {
                    suggestionText.textContent = `You have ${items.length} item${items.length > 1 ? 's' : ''} in your pantry.`;
                }
                console.log('Suggestions loaded (fallback timeout)');
            }
        }, 2000);
    }
    
    // Progress Indicator
    function updateProgressIndicator() {
        const indicator = document.getElementById('progressIndicator');
        const progressText = document.getElementById('progressText');
        const progressPercent = document.getElementById('progressPercent');
        const progressBar = document.getElementById('progressBar');
        
        if (!indicator || !progressText || !progressPercent || !progressBar) return;
        
        const items = document.querySelectorAll('.pantry-item-wrapper');
        const totalItems = items.length;
        
        if (totalItems === 0) {
            indicator.style.display = 'none';
            return;
        }
        
        // Count items with expiration dates
        let itemsWithDates = 0;
        items.forEach(item => {
            const expirationBadge = item.querySelector('.expiration-badge-modern[data-exp-date]');
            if (expirationBadge) {
                const expDate = expirationBadge.getAttribute('data-exp-date');
                if (expDate && expDate !== '9999-12-31' && expDate !== 'None' && expDate !== '' && expDate !== 'null') {
                    itemsWithDates++;
                }
            }
        });
        
        const completeness = totalItems > 0 ? Math.round((itemsWithDates / totalItems) * 100) : 0;
        
        indicator.style.display = 'block';
        progressText.textContent = `${totalItems} item${totalItems > 1 ? 's' : ''} tracked`;
        progressPercent.textContent = `${completeness}%`;
        progressBar.style.width = `${completeness}%`;
        progressBar.style.background = completeness >= 50 
            ? 'linear-gradient(90deg, #10B981 0%, #059669 100%)' 
            : completeness >= 25 
            ? 'linear-gradient(90deg, #F59E0B 0%, #D97706 100%)'
            : 'linear-gradient(90deg, #EF4444 0%, #DC2626 100%)';
    }
    
    // Monitor pantry changes to update progress and empty state
    let progressObserver;
    function setupProgressObserver() {
        const pantryContainer = document.getElementById('pantryItemsContainer');
        if (pantryContainer && !progressObserver) {
            progressObserver = new MutationObserver(() => {
                updateProgressIndicator();
                updateSmartSuggestions();
                updateEmptyState();
            });
            progressObserver.observe(pantryContainer, { childList: true, subtree: true });
        }
    }
    
    // Update empty state visibility
    function updateEmptyState() {
        const emptyState = document.querySelector('.empty-state');
        const pantryContainer = document.getElementById('pantryItemsContainer');
        
        if (!pantryContainer) {
            console.warn('updateEmptyState: pantryItemsContainer not found');
            return;
        }
        
        // Check for visible items (not hidden by filters)
        const allItems = pantryContainer.querySelectorAll('.pantry-item-wrapper');
        const visibleItems = Array.from(allItems).filter(item => {
            const style = window.getComputedStyle(item);
            return style.display !== 'none' && style.visibility !== 'hidden';
        });
        const hasItems = visibleItems.length > 0;
        
        // Update empty state visibility
        if (emptyState) {
            if (hasItems) {
                emptyState.style.display = 'none';
            } else {
                emptyState.style.display = 'block';
            }
        }
        
        // Also update stats count to match actual visible items
        const statsCountElement = document.getElementById('pantryStatsCount');
        if (statsCountElement) {
            statsCountElement.textContent = visibleItems.length;
        }
        
        console.log('updateEmptyState: visible items =', visibleItems.length, 'total items =', allItems.length);
    }
    
    // Unified function to apply all active filters with AND logic
    // Note: Filter chips have been removed, so this function now just ensures all items are visible
    function applyAllFilters() {
            const items = document.querySelectorAll('.pantry-item-wrapper');
        
        // Since filter chips are removed, show all items
            items.forEach(item => {
                item.style.display = '';
            });
            
        // Re-apply current sort if one is active
        if (currentSortType && typeof sortPantry === 'function') {
                setTimeout(() => {
                    sortPantry(currentSortType);
                }, 50);
            }
    }
    
    // Filter chips have been removed - no event listeners needed
    
    // Helper function to get days until expiration
    function getDaysUntilExpiration(expDate) {
        if (!expDate || expDate === '9999-12-31' || expDate === 'None' || expDate === '') {
            return 999;
        }
        try {
            const exp = new Date(expDate);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            exp.setHours(0, 0, 0, 0);
            const diffTime = exp - today;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return diffDays;
        } catch (e) {
            return 999;
        }
    }
    
    // Update suggestions and progress after pantry reload
    // Wait for reloadPantryItems to be defined, then wrap it
    let wrapReloadAttempts = 0;
    const MAX_WRAP_ATTEMPTS = 50; // Max 5 seconds (50 * 100ms)
    
    function wrapReloadPantryItems() {
        try {
            if (typeof window.reloadPantryItems === 'function') {
                const originalReloadPantryItems = window.reloadPantryItems;
                window.reloadPantryItems = async function() {
                    try {
                        await originalReloadPantryItems();
                        setTimeout(() => {
                            try {
                                if (typeof updateSmartSuggestions === 'function') {
                                    updateSmartSuggestions();
                                }
                                if (typeof updateProgressIndicator === 'function') {
                                    updateProgressIndicator();
                                }
                                if (typeof updateExpiringSoonBanner === 'function') {
                                    updateExpiringSoonBanner();
                                }
                            } catch (error) {
                                console.error('Error updating suggestions/progress:', error);
                            }
                        }, 300);
                    } catch (error) {
                        console.error('Error in wrapped reloadPantryItems:', error);
                        throw error; // Re-throw to allow original error handling
                    }
                };
                wrapReloadAttempts = 0; // Reset on success
            } else {
                wrapReloadAttempts++;
                if (wrapReloadAttempts < MAX_WRAP_ATTEMPTS) {
                    // If not defined yet, try again after a short delay
                    setTimeout(wrapReloadPantryItems, 100);
                } else {
                    console.error('Failed to wrap reloadPantryItems after', MAX_WRAP_ATTEMPTS, 'attempts');
                }
            }
        } catch (error) {
            console.error('Error in wrapReloadPantryItems:', error);
        }
    }
    
    // Start wrapping after DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', wrapReloadPantryItems);
    } else {
        wrapReloadPantryItems();
    }
    
    // Cleanup stuck backdrops function - ALWAYS remove backdrops
    function cleanupStuckBackdrops() {
        try {
            // Always remove all backdrops - we don't want them at all
            const backdrops = document.querySelectorAll('.modal-backdrop');
            backdrops.forEach(backdrop => {
                try {
                    backdrop.style.display = 'none';
                    backdrop.remove();
                } catch (e) {
                    console.warn('Error removing backdrop:', e);
                }
            });
            // Don't remove modal-open class if modals are actually open
            const openModals = document.querySelectorAll('.modal.show');
            if (openModals.length === 0) {
                document.body.classList.remove('modal-open');
                document.body.style.overflow = '';
                document.body.style.paddingRight = '';
            }
        } catch (error) {
            console.error('Error in cleanupStuckBackdrops:', error);
        }
    }
    
    // Consistent modal close helper
    function closeModalSafely(modalId) {
        try {
            const modal = document.getElementById(modalId);
            if (!modal) return;
            
            if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                const modalInstance = bootstrap.Modal.getInstance(modal);
                if (modalInstance) {
                    modalInstance.hide();
                } else {
                    // Fallback: manually hide
                    modal.classList.remove('show');
                    modal.style.display = 'none';
                    modal.setAttribute('aria-hidden', 'true');
                    modal.removeAttribute('aria-modal');
                }
            } else {
                // Fallback: manually hide
                modal.classList.remove('show');
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');
                modal.removeAttribute('aria-modal');
            }
            
            // Always cleanup backdrops after closing
            setTimeout(() => {
                cleanupStuckBackdrops();
            }, 100);
        } catch (error) {
            console.error(`Error closing modal ${modalId}:`, error);
        }
    }
    
    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        try {
            console.log('DOM Content Loaded - Initializing SmartPantry...');
            
            // Clean up any stuck backdrops on page load
            cleanupStuckBackdrops();
            
            // Set up modal event listeners to ensure proper cleanup and prevent backdrop
            const addItemModal = document.getElementById('addItemModal');
            if (addItemModal && typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                // Prevent backdrop from being created
                addItemModal.addEventListener('show.bs.modal', function(e) {
                    // Remove any existing backdrop immediately
                    const backdrops = document.querySelectorAll('.modal-backdrop');
                    backdrops.forEach(backdrop => backdrop.remove());
                    document.body.classList.remove('modal-open');
                });
                
                addItemModal.addEventListener('shown.bs.modal', function() {
                    // Remove any backdrop that was created
                    const backdrops = document.querySelectorAll('.modal-backdrop');
                    backdrops.forEach(backdrop => {
                        backdrop.style.display = 'none';
                        backdrop.remove();
                    });
                    document.body.classList.remove('modal-open');
                    document.body.style.overflow = '';
                    
                    // Ensure modal content is clickable when shown
                    const modalContent = addItemModal.querySelector('.modal-content');
                    if (modalContent) {
                        modalContent.style.pointerEvents = 'auto';
                        // Ensure all interactive elements are clickable
                        const interactiveElements = modalContent.querySelectorAll('input, button, select, textarea, a');
                        interactiveElements.forEach(el => {
                            el.style.pointerEvents = 'auto';
                        });
                    }
                });
                
                addItemModal.addEventListener('hidden.bs.modal', function() {
                    // Clean up backdrop when modal is hidden
                    cleanupStuckBackdrops();
                });
            }
            
            // Also prevent backdrop on photo modal
            const photoModal = document.getElementById('photoModal');
            if (photoModal && typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                photoModal.addEventListener('show.bs.modal', function(e) {
                    const backdrops = document.querySelectorAll('.modal-backdrop');
                    backdrops.forEach(backdrop => backdrop.remove());
                });
                photoModal.addEventListener('shown.bs.modal', function() {
                    const backdrops = document.querySelectorAll('.modal-backdrop');
                    backdrops.forEach(backdrop => {
                        backdrop.style.display = 'none';
                        backdrop.remove();
                    });
                    document.body.classList.remove('modal-open');
                });
            }
            
            // Initialize all UI updates
            if (typeof initializeSuggestions === 'function') {
                initializeSuggestions();
            }
            if (typeof updateSmartSuggestions === 'function') {
                setTimeout(() => {
                    try {
                        updateSmartSuggestions();
                        if (typeof updateProgressIndicator === 'function') {
                            updateProgressIndicator();
                        }
                        if (typeof setupProgressObserver === 'function') {
                            setupProgressObserver();
                        }
                        if (typeof updateEmptyState === 'function') {
                            updateEmptyState();
                        }
                        console.log('Smart suggestions and progress indicator updated');
                    } catch (error) {
                        console.error('Error updating suggestions/progress on load:', error);
                    }
                }, 500);
            } else {
                console.error('updateSmartSuggestions function not found!');
            }
            
            // Ensure handleAddItem is properly attached to forms
            const addItemForm = document.getElementById('addItemForm');
            const addItemModalForm = document.getElementById('addItemModalForm');
            
            // Remove any existing handlers first, then attach
            if (addItemForm) {
                // Remove inline onsubmit and use addEventListener
                addItemForm.removeAttribute('onsubmit');
                addItemForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof window.handleAddItem === 'function') {
                        const result = window.handleAddItem(e);
                        return false;
                    } else {
                        console.error('handleAddItem function not found!');
                        alert('Error: Form handler not loaded. Please refresh the page.');
                        return false;
                    }
                });
                console.log(' Add item form handler attached');
            } else {
                console.warn(' addItemForm not found in DOM');
            }
            
            if (addItemModalForm) {
                // Remove inline onsubmit and use addEventListener
                addItemModalForm.removeAttribute('onsubmit');
                addItemModalForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (typeof window.handleAddItem === 'function') {
                        const result = window.handleAddItem(e);
                        return false;
                    } else {
                        console.error('handleAddItem function not found!');
                        alert('Error: Form handler not loaded. Please refresh the page.');
                        return false;
                    }
                });
                console.log(' Add item modal form handler attached');
            } else {
                console.warn(' addItemModalForm not found in DOM');
            }
            
            // Verify critical functions exist
            if (typeof window.handleAddItem !== 'function') {
                console.error(' handleAddItem is not accessible globally!');
            } else {
                console.log(' handleAddItem is available');
            }
            if (typeof window.reloadPantryItems !== 'function') {
                console.error(' reloadPantryItems is not accessible globally!');
            } else {
                console.log(' reloadPantryItems is available');
            }
            
            // Ensure feedback elements exist and are visible
            const addItemFeedback = document.getElementById('addItemFeedback');
            const addItemModalFeedback = document.getElementById('addItemModalFeedback');
            if (!addItemFeedback) {
                console.warn(' addItemFeedback element not found');
            }
            if (!addItemModalFeedback) {
                console.warn(' addItemModalFeedback element not found');
            }
            
            // Force initial update - ensure suggestions load
            setTimeout(() => {
                try {
                    if (typeof updateSmartSuggestions === 'function') {
                        updateSmartSuggestions();
                        console.log(' Smart suggestions initialized');
                    } else {
                        console.warn(' updateSmartSuggestions function not found');
                        // Fallback: directly update suggestion text
                        const suggestionText = document.getElementById('suggestionText');
                        if (suggestionText && suggestionText.textContent === 'Loading suggestions...') {
                            const items = document.querySelectorAll('.pantry-item-wrapper');
                            if (items.length === 0) {
                                suggestionText.textContent = 'Add items to get smart suggestions!';
                            } else {
                                suggestionText.textContent = `You have ${items.length} item${items.length > 1 ? 's' : ''} in your pantry.`;
                            }
                        }
                    }
                    if (typeof updateProgressIndicator === 'function') {
                        updateProgressIndicator();
                        console.log(' Progress indicator initialized');
                    }
                    if (typeof updateEmptyState === 'function') {
                        updateEmptyState();
                        console.log(' Empty state updated');
                    }
                } catch (error) {
                    console.error('Error in delayed initialization:', error);
                }
            }, 500);
            
            // Also call initializeSuggestions if it exists
            if (typeof initializeSuggestions === 'function') {
                initializeSuggestions();
                console.log(' Suggestions system initialized');
            }
            
            // Periodic cleanup check (every 2 seconds)
            const cleanupIntervalId = setInterval(cleanupStuckBackdrops, 2000);
            
            // Store interval ID for cleanup on unload
            window._smartPantryCleanupInterval = cleanupIntervalId;
        } catch (error) {
            console.error('Error in DOMContentLoaded handler:', error);
        }
    });
    
    // Cleanup on page unload to prevent memory leaks
    window.addEventListener('beforeunload', function() {
        try {
            // Stop camera stream if running
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            // Clear video element source
            const cameraStreamVideo = document.getElementById('cameraStream');
            if (cameraStreamVideo && cameraStreamVideo.srcObject) {
                cameraStreamVideo.srcObject = null;
            }
            
            // Clear cleanup interval
            if (window._smartPantryCleanupInterval) {
                clearInterval(window._smartPantryCleanupInterval);
            }
            
            // Clear selected file
            selectedFile = null;
        } catch (e) {
            console.warn('Error during cleanup:', e);
        }
    });
    
    // Mobile sticky action bar - create after DOM is ready
    function createMobileStickyBar() {
        // Check if already exists
        if (document.querySelector('.sticky-action-bar.d-lg-none')) {
            return;
        }
        
        const mobileStickyBar = document.createElement('div');
        mobileStickyBar.className = 'sticky-action-bar d-lg-none';
        mobileStickyBar.innerHTML = `
            <div class="row g-2 m-0">
                <div class="col-6">
                    <button type="button" class="btn btn-primary w-100" data-bs-toggle="modal" data-bs-target="#addItemModal" style="background: linear-gradient(135deg, #8B5CF6 0%, #3B82F6 100%); border: none; border-radius: 12px; padding: 12px; font-weight: 600; font-size: 0.9rem;">
                        <i class="bi bi-plus-circle-fill me-2"></i>Add Item
                    </button>
                </div>
                <div class="col-6">
                    <button type="button" class="btn btn-success w-100" data-bs-toggle="modal" data-bs-target="#photoModal" style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); border: none; border-radius: 12px; padding: 12px; font-weight: 600; font-size: 0.9rem;">
                        <i class="bi bi-camera-fill me-2"></i>Upload Photo
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(mobileStickyBar);
        document.body.classList.add('has-sticky-bar');
    }
    
    // Create mobile sticky bar after DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', createMobileStickyBar);
    } else {
        createMobileStickyBar();
    }
    }
</script>
{% endblock %}


